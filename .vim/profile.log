SCRIPT  /Applications/MacVim.app/Contents/Resources/vim/runtime/ftoff.vim
Sourced 1 time
Total time:   0.000233
 Self time:   0.000233

count  total (s)   self (s)
                            " Vim support file to switch off detection of file types
                            "
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last change:	2001 Jun 11
                            
    1              0.000005 if exists("did_load_filetypes")
    1              0.000002   unlet did_load_filetypes
    1              0.000001 endif
                            
                            " Remove all autocommands in the filetypedetect group
    1              0.000217 silent! au! filetypedetect *

SCRIPT  /Users/admin/.vim/bundle/tern_for_vim/ftdetect/tern.vim
Sourced 2 times
Total time:   0.000107
 Self time:   0.000107

count  total (s)   self (s)

SCRIPT  /Users/admin/.vim/bundle/vim-javascript/ftdetect/javascript.vim
Sourced 2 times
Total time:   0.000535
 Self time:   0.000535

count  total (s)   self (s)
                            au BufNewFile,BufRead *.js setf javascript
    2              0.000085 au BufNewFile,BufRead *.jsm setf javascript
    2              0.000084 au BufNewFile,BufRead *.json setf javascript
    2              0.000090 au BufNewFile,BufRead Jakefile setf javascript
                            
    2              0.000009 fun! s:SelectJavascript()
                              if getline(1) =~# '^#!.*/bin/env\s\+node\>'
                                set ft=javascript
                              endif
                            endfun
    2              0.000092 au BufNewFile,BufRead * call s:SelectJavascript()

SCRIPT  /Users/admin/.vim/bundle/vim-node.js/ftdetect/node.js.vim
Sourced 2 times
Total time:   0.000136
 Self time:   0.000136

count  total (s)   self (s)
                            " vim-node.js - file type detect plugin for vim which detects node.js shebang
                            " Author:       Maciej Malecki
                            " Version:      1.1.1
                            " License:      MIT
                            "
                            " Install via pathogen by cloning/adding submodule in ~/.vim/bundle or
                            " by dropping this script in ~/vim/ftdetect
                            
    2              0.000007 function! DetectNode()
                              if !did_filetype()
                                if getline(1) =~ '^#.*\<node\>'
                                  setfiletype javascript
                                endif
                              endif
                            endfunction
                            
    2              0.000093 :au BufNewFile,BufRead * call DetectNode()
                            

SCRIPT  /Users/admin/.vim/bundle/vim-json/ftdetect/json.vim
Sourced 2 times
Total time:   0.000329
 Self time:   0.000329

count  total (s)   self (s)
                            autocmd BufNewFile,BufRead *.json set filetype=json
                            
    2              0.000005 augroup json_autocmd
    2              0.000156   autocmd!
    2              0.000015   autocmd FileType json setlocal autoindent
    2              0.000006   autocmd FileType json setlocal formatoptions=tcq2l
    2              0.000006   autocmd FileType json setlocal foldmethod=syntax
    2              0.000008 augroup END

SCRIPT  /Applications/MacVim.app/Contents/Resources/vim/runtime/filetype.vim
Sourced 3 times
Total time:   0.045857
 Self time:   0.044872

count  total (s)   self (s)
                            " Vim support file to detect file types
                            "
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2013 Sep 22
                            
                            " Listen very carefully, I will say this only once
    3              0.000013 if exists("did_load_filetypes")
    2              0.000002   finish
                            endif
    1              0.000003 let did_load_filetypes = 1
                            
                            " Line continuation is used here, remove 'C' from 'cpoptions'
    1              0.000006 let s:cpo_save = &cpo
    1              0.000007 set cpo&vim
                            
    1              0.000010 augroup filetypedetect
                            
                            " Ignored extensions
    1              0.000004 if exists("*fnameescape")
    1              0.000216 au BufNewFile,BufRead ?\+.orig,?\+.bak,?\+.old,?\+.new,?\+.dpkg-dist,?\+.dpkg-old,?\+.dpkg-new,?\+.dpkg-bak,?\+.rpmsave,?\+.rpmnew
                            	\ exe "doau filetypedetect BufRead " . fnameescape(expand("<afile>:r"))
    1              0.000032 au BufNewFile,BufRead *~
                            	\ let s:name = expand("<afile>") |
                            	\ let s:short = substitute(s:name, '\~$', '', '') |
                            	\ if s:name != s:short && s:short != "" |
                            	\   exe "doau filetypedetect BufRead " . fnameescape(s:short) |
                            	\ endif |
                            	\ unlet! s:name s:short
    1              0.000029 au BufNewFile,BufRead ?\+.in
                            	\ if expand("<afile>:t") != "configure.in" |
                            	\   exe "doau filetypedetect BufRead " . fnameescape(expand("<afile>:r")) |
                            	\ endif
    1              0.000002 elseif &verbose > 0
                              echomsg "Warning: some filetypes will not be recognized because this version of Vim does not have fnameescape()"
                            endif
                            
                            " Pattern used to match file names which should not be inspected.
                            " Currently finds compressed files.
    1              0.000003 if !exists("g:ft_ignore_pat")
                              let g:ft_ignore_pat = '\.\(Z\|gz\|bz2\|zip\|tgz\)$'
                            endif
                            
                            " Function used for patterns that end in a star: don't set the filetype if the
                            " file name matches ft_ignore_pat.
    1              0.000004 func! s:StarSetf(ft)
                              if expand("<amatch>") !~ g:ft_ignore_pat
                                exe 'setf ' . a:ft
                              endif
                            endfunc
                            
                            " Abaqus or Trasys
    1              0.000028 au BufNewFile,BufRead *.inp			call s:Check_inp()
                            
    1              0.000002 func! s:Check_inp()
                              if getline(1) =~ '^\*'
                                setf abaqus
                              else
                                let n = 1
                                if line("$") > 500
                                  let nmax = 500
                                else
                                  let nmax = line("$")
                                endif
                                while n <= nmax
                                  if getline(n) =~? "^header surface data"
                            	setf trasys
                            	break
                                  endif
                                  let n = n + 1
                                endwhile
                              endif
                            endfunc
                            
                            " A-A-P recipe
    1              0.000026 au BufNewFile,BufRead *.aap			setf aap
                            
                            " A2ps printing utility
    1              0.000093 au BufNewFile,BufRead */etc/a2ps.cfg,*/etc/a2ps/*.cfg,a2psrc,.a2psrc setf a2ps
                            
                            " ABAB/4
    1              0.000026 au BufNewFile,BufRead *.abap			setf abap
                            
                            " ABC music notation
    1              0.000024 au BufNewFile,BufRead *.abc			setf abc
                            
                            " ABEL
    1              0.000023 au BufNewFile,BufRead *.abl			setf abel
                            
                            " AceDB
    1              0.000027 au BufNewFile,BufRead *.wrm			setf acedb
                            
                            " Ada (83, 9X, 95)
    1              0.000059 au BufNewFile,BufRead *.adb,*.ads,*.ada		setf ada
    1              0.000005 if has("vms")
                              au BufNewFile,BufRead *.gpr,*.ada_m,*.adc	setf ada
                            else
    1              0.000029   au BufNewFile,BufRead *.gpr			setf ada
    1              0.000001 endif
                            
                            " AHDL
    1              0.000027 au BufNewFile,BufRead *.tdf			setf ahdl
                            
                            " AMPL
    1              0.000024 au BufNewFile,BufRead *.run			setf ampl
                            
                            " Ant
    1              0.000026 au BufNewFile,BufRead build.xml			setf ant
                            
                            " Apache style config file
    1              0.000030 au BufNewFile,BufRead proftpd.conf*		call s:StarSetf('apachestyle')
                            
                            " Apache config file
    1              0.000051 au BufNewFile,BufRead .htaccess,*/etc/httpd/*.conf		setf apache
                            
                            " XA65 MOS6510 cross assembler
    1              0.000027 au BufNewFile,BufRead *.a65			setf a65
                            
                            " Applescript
    1              0.000025 au BufNewFile,BufRead *.scpt			setf applescript
                            
                            " Applix ELF
    1              0.000026 au BufNewFile,BufRead *.am
                            	\ if expand("<afile>") !~? 'Makefile.am\>' | setf elf | endif
                            
                            " ALSA configuration
    1              0.000082 au BufNewFile,BufRead .asoundrc,*/usr/share/alsa/alsa.conf,*/etc/asound.conf setf alsaconf
                            
                            " Arc Macro Language
    1              0.000027 au BufNewFile,BufRead *.aml			setf aml
                            
                            " APT config file
    1              0.000027 au BufNewFile,BufRead apt.conf		       setf aptconf
    1              0.000042 au BufNewFile,BufRead */.aptitude/config       setf aptconf
    1              0.000039 au BufNewFile,BufRead */etc/apt/apt.conf.d/{[-_[:alnum:]]\+,[-_.[:alnum:]]\+.conf} setf aptconf
                            
                            " Arch Inventory file
    1              0.000052 au BufNewFile,BufRead .arch-inventory,=tagging-method	setf arch
                            
                            " ART*Enterprise (formerly ART-IM)
    1              0.000026 au BufNewFile,BufRead *.art			setf art
                            
                            " AsciiDoc
    1              0.000025 au BufNewFile,BufRead *.asciidoc		setf asciidoc
                            
                            " ASN.1
    1              0.000048 au BufNewFile,BufRead *.asn,*.asn1		setf asn
                            
                            " Active Server Pages (with Visual Basic Script)
    1              0.000028 au BufNewFile,BufRead *.asa
                            	\ if exists("g:filetype_asa") |
                            	\   exe "setf " . g:filetype_asa |
                            	\ else |
                            	\   setf aspvbs |
                            	\ endif
                            
                            " Active Server Pages (with Perl or Visual Basic Script)
    1              0.000040 au BufNewFile,BufRead *.asp
                            	\ if exists("g:filetype_asp") |
                            	\   exe "setf " . g:filetype_asp |
                            	\ elseif getline(1) . getline(2) . getline(3) =~? "perlscript" |
                            	\   setf aspperl |
                            	\ else |
                            	\   setf aspvbs |
                            	\ endif
                            
                            " Grub (must be before catch *.lst)
    1              0.000074 au BufNewFile,BufRead */boot/grub/menu.lst,*/boot/grub/grub.conf,*/etc/grub.conf setf grub
                            
                            " Assembly (all kinds)
                            " *.lst is not pure assembly, it has two extra columns (address, byte codes)
    1              0.000104 au BufNewFile,BufRead *.asm,*.[sS],*.[aA],*.mac,*.lst	call s:FTasm()
                            
                            " This function checks for the kind of assembly that is wanted by the user, or
                            " can be detected from the first five lines of the file.
    1              0.000003 func! s:FTasm()
                              " make sure b:asmsyntax exists
                              if !exists("b:asmsyntax")
                                let b:asmsyntax = ""
                              endif
                            
                              if b:asmsyntax == ""
                                call s:FTasmsyntax()
                              endif
                            
                              " if b:asmsyntax still isn't set, default to asmsyntax or GNU
                              if b:asmsyntax == ""
                                if exists("g:asmsyntax")
                                  let b:asmsyntax = g:asmsyntax
                                else
                                  let b:asmsyntax = "asm"
                                endif
                              endif
                            
                              exe "setf " . fnameescape(b:asmsyntax)
                            endfunc
                            
    1              0.000001 func! s:FTasmsyntax()
                              " see if file contains any asmsyntax=foo overrides. If so, change
                              " b:asmsyntax appropriately
                              let head = " ".getline(1)." ".getline(2)." ".getline(3)." ".getline(4).
                            	\" ".getline(5)." "
                              let match = matchstr(head, '\sasmsyntax=\zs[a-zA-Z0-9]\+\ze\s')
                              if match != ''
                                let b:asmsyntax = match
                              elseif ((head =~? '\.title') || (head =~? '\.ident') || (head =~? '\.macro') || (head =~? '\.subtitle') || (head =~? '\.library'))
                                let b:asmsyntax = "vmasm"
                              endif
                            endfunc
                            
                            " Macro (VAX)
    1              0.000030 au BufNewFile,BufRead *.mar			setf vmasm
                            
                            " Atlas
    1              0.000044 au BufNewFile,BufRead *.atl,*.as		setf atlas
                            
                            " Autoit v3
    1              0.000031 au BufNewFile,BufRead *.au3			setf autoit
                            
                            " Autohotkey
    1              0.000027 au BufNewFile,BufRead *.ahk			setf autohotkey
                            
                            " Automake
    1              0.000052 au BufNewFile,BufRead [mM]akefile.am,GNUmakefile.am	setf automake
                            
                            " Autotest .at files are actually m4
    1              0.000027 au BufNewFile,BufRead *.at			setf m4
                            
                            " Avenue
    1              0.000026 au BufNewFile,BufRead *.ave			setf ave
                            
                            " Awk
    1              0.000024 au BufNewFile,BufRead *.awk			setf awk
                            
                            " B
    1              0.000066 au BufNewFile,BufRead *.mch,*.ref,*.imp		setf b
                            
                            " BASIC or Visual Basic
    1              0.000026 au BufNewFile,BufRead *.bas			call s:FTVB("basic")
                            
                            " Check if one of the first five lines contains "VB_Name".  In that case it is
                            " probably a Visual Basic file.  Otherwise it's assumed to be "alt" filetype.
    1              0.000003 func! s:FTVB(alt)
                              if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'VB_Name\|Begin VB\.\(Form\|MDIForm\|UserControl\)'
                                setf vb
                              else
                                exe "setf " . a:alt
                              endif
                            endfunc
                            
                            " Visual Basic Script (close to Visual Basic) or Visual Basic .NET
    1              0.000100 au BufNewFile,BufRead *.vb,*.vbs,*.dsm,*.ctl	setf vb
                            
                            " IBasic file (similar to QBasic)
    1              0.000052 au BufNewFile,BufRead *.iba,*.ibi		setf ibasic
                            
                            " FreeBasic file (similar to QBasic)
    1              0.000069 au BufNewFile,BufRead *.fb,*.bi			setf freebasic
                            
                            " Batch file for MSDOS.
    1              0.000053 au BufNewFile,BufRead *.bat,*.sys		setf dosbatch
                            " *.cmd is close to a Batch file, but on OS/2 Rexx files also use *.cmd.
    1              0.000030 au BufNewFile,BufRead *.cmd
                            	\ if getline(1) =~ '^/\*' | setf rexx | else | setf dosbatch | endif
                            
                            " Batch file for 4DOS
    1              0.000028 au BufNewFile,BufRead *.btm			call s:FTbtm()
    1              0.000003 func! s:FTbtm()
                              if exists("g:dosbatch_syntax_for_btm") && g:dosbatch_syntax_for_btm
                                setf dosbatch
                              else
                                setf btm
                              endif
                            endfunc
                            
                            " BC calculator
    1              0.000030 au BufNewFile,BufRead *.bc			setf bc
                            
                            " BDF font
    1              0.000032 au BufNewFile,BufRead *.bdf			setf bdf
                            
                            " BibTeX bibliography database file
    1              0.000028 au BufNewFile,BufRead *.bib			setf bib
                            
                            " BibTeX Bibliography Style
    1              0.000026 au BufNewFile,BufRead *.bst			setf bst
                            
                            " BIND configuration
    1              0.000054 au BufNewFile,BufRead named.conf,rndc.conf	setf named
                            
                            " BIND zone
    1              0.000030 au BufNewFile,BufRead named.root		setf bindzone
    1              0.000028 au BufNewFile,BufRead *.db			call s:BindzoneCheck('')
                            
    1              0.000003 func! s:BindzoneCheck(default)
                              if getline(1).getline(2).getline(3).getline(4) =~ '^; <<>> DiG [0-9.]\+ <<>>\|BIND.*named\|$ORIGIN\|$TTL\|IN\s\+SOA'
                                setf bindzone
                              elseif a:default != ''
                                exe 'setf ' . a:default
                              endif
                            endfunc
                            
                            " Blank
    1              0.000034 au BufNewFile,BufRead *.bl			setf blank
                            
                            " Blkid cache file
    1              0.000057 au BufNewFile,BufRead */etc/blkid.tab,*/etc/blkid.tab.old   setf xml
                            
                            " C or lpc
    1              0.000030 au BufNewFile,BufRead *.c			call s:FTlpc()
                            
    1              0.000007 func! s:FTlpc()
                              if exists("g:lpc_syntax_for_c")
                                let lnum = 1
                                while lnum <= 12
                                  if getline(lnum) =~# '^\(//\|inherit\|private\|protected\|nosave\|string\|object\|mapping\|mixed\)'
                            	setf lpc
                            	return
                                  endif
                                  let lnum = lnum + 1
                                endwhile
                              endif
                              setf c
                            endfunc
                            
                            " Calendar
    1              0.000033 au BufNewFile,BufRead calendar			setf calendar
                            
                            " C#
    1              0.000029 au BufNewFile,BufRead *.cs			setf cs
                            
                            " CSDL
    1              0.000033 au BufNewFile,BufRead *.csdl			setf csdl
                            
                            " Cabal
    1              0.000029 au BufNewFile,BufRead *.cabal			setf cabal
                            
                            " Cdrdao TOC
    1              0.000027 au BufNewFile,BufRead *.toc			setf cdrtoc
                            
                            " Cdrdao config
    1              0.000114 au BufNewFile,BufRead */etc/cdrdao.conf,*/etc/defaults/cdrdao,*/etc/default/cdrdao,.cdrdao	setf cdrdaoconf
                            
                            " Cfengine
    1              0.000029 au BufNewFile,BufRead cfengine.conf		setf cfengine
                            
                            " ChaiScript
    1              0.000025 au BufRead,BufNewFile *.chai			setf chaiscript
                            
                            " Comshare Dimension Definition Language
    1              0.000025 au BufNewFile,BufRead *.cdl			setf cdl
                            
                            " Conary Recipe
    1              0.000031 au BufNewFile,BufRead *.recipe			setf conaryrecipe
                            
                            " Controllable Regex Mutilator
    1              0.000027 au BufNewFile,BufRead *.crm			setf crm
                            
                            " Cyn++
    1              0.000026 au BufNewFile,BufRead *.cyn			setf cynpp
                            
                            " Cynlib
                            " .cc and .cpp files can be C++ or Cynlib.
    1              0.000031 au BufNewFile,BufRead *.cc
                            	\ if exists("cynlib_syntax_for_cc")|setf cynlib|else|setf cpp|endif
    1              0.000042 au BufNewFile,BufRead *.cpp
                            	\ if exists("cynlib_syntax_for_cpp")|setf cynlib|else|setf cpp|endif
                            
                            " C++
    1              0.000203 au BufNewFile,BufRead *.cxx,*.c++,*.hh,*.hxx,*.hpp,*.ipp,*.moc,*.tcc,*.inl setf cpp
    1              0.000006 if has("fname_case")
                              au BufNewFile,BufRead *.C,*.H setf cpp
                            endif
                            
                            " .h files can be C, Ch C++, ObjC or ObjC++.
                            " Set c_syntax_for_h if you want C, ch_syntax_for_h if you want Ch. ObjC is
                            " detected automatically.
    1              0.000030 au BufNewFile,BufRead *.h			call s:FTheader()
                            
    1              0.000003 func! s:FTheader()
                              if match(getline(1, min([line("$"), 200])), '^@\(interface\|end\|class\)') > -1
                                if exists("g:c_syntax_for_h")
                                  setf objc
                                else
                                  setf objcpp
                                endif
                              elseif exists("g:c_syntax_for_h")
                                setf c
                              elseif exists("g:ch_syntax_for_h")
                                setf ch
                              else
                                setf cpp
                              endif
                            endfunc
                            
                            " Ch (CHscript)
    1              0.000030 au BufNewFile,BufRead *.chf			setf ch
                            
                            " TLH files are C++ headers generated by Visual C++'s #import from typelibs
    1              0.000030 au BufNewFile,BufRead *.tlh			setf cpp
                            
                            " Cascading Style Sheets
    1              0.000030 au BufNewFile,BufRead *.css			setf css
                            
                            " Century Term Command Scripts (*.cmd too)
    1              0.000027 au BufNewFile,BufRead *.con			setf cterm
                            
                            " Changelog
    1              0.000101 au BufNewFile,BufRead changelog.Debian,changelog.dch,NEWS.Debian,NEWS.dch
                            					\	setf debchangelog
                            
    1              0.000033 au BufNewFile,BufRead [cC]hange[lL]og
                            	\  if getline(1) =~ '; urgency='
                            	\|   setf debchangelog
                            	\| else
                            	\|   setf changelog
                            	\| endif
                            
    1              0.000033 au BufNewFile,BufRead NEWS
                            	\  if getline(1) =~ '; urgency='
                            	\|   setf debchangelog
                            	\| endif
                            
                            " CHILL
    1              0.000030 au BufNewFile,BufRead *..ch			setf chill
                            
                            " Changes for WEB and CWEB or CHILL
    1              0.000028 au BufNewFile,BufRead *.ch			call s:FTchange()
                            
                            " This function checks if one of the first ten lines start with a '@'.  In
                            " that case it is probably a change file.
                            " If the first line starts with # or ! it's probably a ch file.
                            " If a line has "main", "include", "//" ir "/*" it's probably ch.
                            " Otherwise CHILL is assumed.
    1              0.000002 func! s:FTchange()
                              let lnum = 1
                              while lnum <= 10
                                if getline(lnum)[0] == '@'
                                  setf change
                                  return
                                endif
                                if lnum == 1 && (getline(1)[0] == '#' || getline(1)[0] == '!')
                                  setf ch
                                  return
                                endif
                                if getline(lnum) =~ "MODULE"
                                  setf chill
                                  return
                                endif
                                if getline(lnum) =~ 'main\s*(\|#\s*include\|//'
                                  setf ch
                                  return
                                endif
                                let lnum = lnum + 1
                              endwhile
                              setf chill
                            endfunc
                            
                            " ChordPro
    1              0.000147 au BufNewFile,BufRead *.chopro,*.crd,*.cho,*.crdpro,*.chordpro	setf chordpro
                            
                            " Clean
    1              0.000050 au BufNewFile,BufRead *.dcl,*.icl		setf clean
                            
                            " Clever
    1              0.000028 au BufNewFile,BufRead *.eni			setf cl
                            
                            " Clever or dtd
    1              0.000028 au BufNewFile,BufRead *.ent			call s:FTent()
                            
    1              0.000004 func! s:FTent()
                              " This function checks for valid cl syntax in the first five lines.
                              " Look for either an opening comment, '#', or a block start, '{".
                              " If not found, assume SGML.
                              let lnum = 1
                              while lnum < 6
                                let line = getline(lnum)
                                if line =~ '^\s*[#{]'
                                  setf cl
                                  return
                                elseif line !~ '^\s*$'
                                  " Not a blank line, not a comment, and not a block start,
                                  " so doesn't look like valid cl code.
                                  break
                                endif
                                let lnum = lnum + 1
                              endw
                              setf dtd
                            endfunc
                            
                            " Clipper (or FoxPro; could also be eviews)
    1              0.000036 au BufNewFile,BufRead *.prg
                            	\ if exists("g:filetype_prg") |
                            	\   exe "setf " . g:filetype_prg |
                            	\ else |
                            	\   setf clipper |
                            	\ endif
                            
                            " Clojure
    1              0.000050 au BufNewFile,BufRead *.clj,*.cljs		setf clojure
                            
                            " Cmake
    1              0.000103 au BufNewFile,BufRead CMakeLists.txt,*.cmake,*.cmake.in		setf cmake
                            
                            " Cmusrc
    1              0.000044 au BufNewFile,BufRead */.cmus/{autosave,rc,command-history,*.theme} setf cmusrc
    1              0.000043 au BufNewFile,BufRead */cmus/{rc,*.theme}			setf cmusrc
                            
                            " Cobol
    1              0.000071 au BufNewFile,BufRead *.cbl,*.cob,*.lib	setf cobol
                            "   cobol or zope form controller python script? (heuristic)
    1              0.000031 au BufNewFile,BufRead *.cpy
                            	\ if getline(1) =~ '^##' |
                            	\   setf python |
                            	\ else |
                            	\   setf cobol |
                            	\ endif
                            
                            " Coco/R
    1              0.000029 au BufNewFile,BufRead *.atg			setf coco
                            
                            " Cold Fusion
    1              0.000070 au BufNewFile,BufRead *.cfm,*.cfi,*.cfc		setf cf
                            
                            " Configure scripts
    1              0.000052 au BufNewFile,BufRead configure.in,configure.ac setf config
                            
                            " CUDA  Cumpute Unified Device Architecture
    1              0.000029 au BufNewFile,BufRead *.cu			setf cuda
                            
                            " WildPackets EtherPeek Decoder
    1              0.000030 au BufNewFile,BufRead *.dcd			setf dcd
                            
                            " Enlightenment configuration files
    1              0.000033 au BufNewFile,BufRead *enlightenment/*.cfg	setf c
                            
                            " Eterm
    1              0.000030 au BufNewFile,BufRead *Eterm/*.cfg		setf eterm
                            
                            " Lynx config files
    1              0.000029 au BufNewFile,BufRead lynx.cfg			setf lynx
                            
                            " Quake
    1              0.000055 au BufNewFile,BufRead *baseq[2-3]/*.cfg,*id1/*.cfg	setf quake
    1              0.000032 au BufNewFile,BufRead *quake[1-3]/*.cfg			setf quake
                            
                            " Quake C
    1              0.000029 au BufNewFile,BufRead *.qc			setf c
                            
                            " Configure files
    1              0.000029 au BufNewFile,BufRead *.cfg			setf cfg
                            
                            " Cucumber
    1              0.000030 au BufNewFile,BufRead *.feature			setf cucumber
                            
                            " Communicating Sequential Processes
    1              0.000050 au BufNewFile,BufRead *.csp,*.fdr		setf csp
                            
                            " CUPL logic description and simulation
    1              0.000029 au BufNewFile,BufRead *.pld			setf cupl
    1              0.000029 au BufNewFile,BufRead *.si			setf cuplsim
                            
                            " Debian Control
    1              0.000031 au BufNewFile,BufRead */debian/control		setf debcontrol
    1              0.000032 au BufNewFile,BufRead control
                            	\  if getline(1) =~ '^Source:'
                            	\|   setf debcontrol
                            	\| endif
                            
                            " Debian Sources.list
    1              0.000032 au BufNewFile,BufRead */etc/apt/sources.list		setf debsources
    1              0.000035 au BufNewFile,BufRead */etc/apt/sources.list.d/*.list	setf debsources
                            
                            " Deny hosts
    1              0.000032 au BufNewFile,BufRead denyhosts.conf		setf denyhosts
                            
                            " dnsmasq(8) configuration files
    1              0.000031 au BufNewFile,BufRead */etc/dnsmasq.conf	setf dnsmasq
                            
                            " ROCKLinux package description
    1              0.000030 au BufNewFile,BufRead *.desc			setf desc
                            
                            " the D language or dtrace
    1              0.000043 au BufNewFile,BufRead *.d			call s:DtraceCheck()
                            
    1              0.000006 func! s:DtraceCheck()
                              let lines = getline(1, min([line("$"), 100]))
                              if match(lines, '^module\>\|^import\>') > -1
                                " D files often start with a module and/or import statement.
                                setf d
                              elseif match(lines, '^#!\S\+dtrace\|#pragma\s\+D\s\+option\|:\S\{-}:\S\{-}:') > -1
                                setf dtrace
                              else
                                setf d
                              endif
                            endfunc
                            
                            " Desktop files
    1              0.000073 au BufNewFile,BufRead *.desktop,.directory	setf desktop
                            
                            " Dict config
    1              0.000056 au BufNewFile,BufRead dict.conf,.dictrc		setf dictconf
                            
                            " Dictd config
    1              0.000032 au BufNewFile,BufRead dictd.conf		setf dictdconf
                            
                            " Diff files
    1              0.000074 au BufNewFile,BufRead *.diff,*.rej,*.patch	setf diff
                            
                            " Dircolors
    1              0.000076 au BufNewFile,BufRead .dir_colors,.dircolors,*/etc/DIR_COLORS	setf dircolors
                            
                            " Diva (with Skill) or InstallShield
    1              0.000033 au BufNewFile,BufRead *.rul
                            	\ if getline(1).getline(2).getline(3).getline(4).getline(5).getline(6) =~? 'InstallShield' |
                            	\   setf ishd |
                            	\ else |
                            	\   setf diva |
                            	\ endif
                            
                            " DCL (Digital Command Language - vms) or DNS zone file
    1              0.000031 au BufNewFile,BufRead *.com			call s:BindzoneCheck('dcl')
                            
                            " DOT
    1              0.000030 au BufNewFile,BufRead *.dot			setf dot
                            
                            " Dylan - lid files
    1              0.000030 au BufNewFile,BufRead *.lid			setf dylanlid
                            
                            " Dylan - intr files (melange)
    1              0.000030 au BufNewFile,BufRead *.intr			setf dylanintr
                            
                            " Dylan
    1              0.000030 au BufNewFile,BufRead *.dylan			setf dylan
                            
                            " Microsoft Module Definition
    1              0.000030 au BufNewFile,BufRead *.def			setf def
                            
                            " Dracula
    1              0.000094 au BufNewFile,BufRead *.drac,*.drc,*lvs,*lpe	setf dracula
                            
                            " Datascript
    1              0.000030 au BufNewFile,BufRead *.ds			setf datascript
                            
                            " dsl
    1              0.000030 au BufNewFile,BufRead *.dsl			setf dsl
                            
                            " DTD (Document Type Definition for XML)
    1              0.000034 au BufNewFile,BufRead *.dtd			setf dtd
                            
                            " DTS/DSTI (device tree files)
    1              0.000052 au BufNewFile,BufRead *.dts,*.dtsi		setf dts
                            
                            " EDIF (*.edf,*.edif,*.edn,*.edo)
    1              0.000032 au BufNewFile,BufRead *.ed\(f\|if\|n\|o\)	setf edif
                            
                            " Embedix Component Description
    1              0.000030 au BufNewFile,BufRead *.ecd			setf ecd
                            
                            " Eiffel or Specman
    1              0.000051 au BufNewFile,BufRead *.e,*.E			call s:FTe()
                            
                            " Elinks configuration
    1              0.000057 au BufNewFile,BufRead */etc/elinks.conf,*/.elinks/elinks.conf	setf elinks
                            
    1              0.000003 func! s:FTe()
                              let n = 1
                              while n < 100 && n < line("$")
                                if getline(n) =~ "^\\s*\\(<'\\|'>\\)\\s*$"
                                  setf specman
                                  return
                                endif
                                let n = n + 1
                              endwhile
                              setf eiffel
                            endfunc
                            
                            " ERicsson LANGuage; Yaws is erlang too
    1              0.000082 au BufNewFile,BufRead *.erl,*.hrl,*.yaws	setf erlang
                            
                            " Elm Filter Rules file
    1              0.000045 au BufNewFile,BufRead filter-rules		setf elmfilt
                            
                            " ESMTP rc file
    1              0.000033 au BufNewFile,BufRead *esmtprc			setf esmtprc
                            
                            " ESQL-C
    1              0.000060 au BufNewFile,BufRead *.ec,*.EC			setf esqlc
                            
                            " Esterel
    1              0.000033 au BufNewFile,BufRead *.strl			setf esterel
                            
                            " Essbase script
    1              0.000032 au BufNewFile,BufRead *.csc			setf csc
                            
                            " Exim
    1              0.000032 au BufNewFile,BufRead exim.conf			setf exim
                            
                            " Expect
    1              0.000035 au BufNewFile,BufRead *.exp			setf expect
                            
                            " Exports
    1              0.000034 au BufNewFile,BufRead exports			setf exports
                            
                            " Falcon
    1              0.000031 au BufNewFile,BufRead *.fal			setf falcon
                            
                            " Fantom
    1              0.000053 au BufNewFile,BufRead *.fan,*.fwt		setf fan
                            
                            " Factor
    1              0.000035 au BufNewFile,BufRead *.factor			setf factor
                            
                            " Fetchmail RC file
    1              0.000034 au BufNewFile,BufRead .fetchmailrc		setf fetchmail
                            
                            " FlexWiki - disabled, because it has side effects when a .wiki file
                            " is not actually FlexWiki
                            "au BufNewFile,BufRead *.wiki			setf flexwiki
                            
                            " Focus Executable
    1              0.000054 au BufNewFile,BufRead *.fex,*.focexec		setf focexec
                            
                            " Focus Master file (but not for auto.master)
    1              0.000037 au BufNewFile,BufRead auto.master		setf conf
    1              0.000055 au BufNewFile,BufRead *.mas,*.master		setf master
                            
                            " Forth
    1              0.000057 au BufNewFile,BufRead *.fs,*.ft			setf forth
                            
                            " Reva Forth
    1              0.000034 au BufNewFile,BufRead *.frt			setf reva
                            
                            " Fortran
    1              0.000007 if has("fname_case")
                              au BufNewFile,BufRead *.F,*.FOR,*.FPP,*.FTN,*.F77,*.F90,*.F95,*.F03,*.F08	 setf fortran
                            endif
    1              0.000239 au BufNewFile,BufRead   *.f,*.for,*.fortran,*.fpp,*.ftn,*.f77,*.f90,*.f95,*.f03,*.f08  setf fortran
                            
                            " Framescript
    1              0.000033 au BufNewFile,BufRead *.fsl			setf framescript
                            
                            " FStab
    1              0.000057 au BufNewFile,BufRead fstab,mtab		setf fstab
                            
                            " GDB command files
    1              0.000059 au BufNewFile,BufRead .gdbinit			setf gdb
                            
                            " GDMO
    1              0.000070 au BufNewFile,BufRead *.mo,*.gdmo		setf gdmo
                            
                            " Gedcom
    1              0.000061 au BufNewFile,BufRead *.ged,lltxxxxx.txt	setf gedcom
                            
                            " Git
    1              0.000036 au BufNewFile,BufRead *.git/COMMIT_EDITMSG	setf gitcommit
    1              0.000037 au BufNewFile,BufRead *.git/MERGE_MSG		setf gitcommit
    1              0.000087 au BufNewFile,BufRead *.git/config,.gitconfig,.gitmodules setf gitconfig
    1              0.000037 au BufNewFile,BufRead *.git/modules/*/COMMIT_EDITMSG setf gitcommit
    1              0.000036 au BufNewFile,BufRead *.git/modules/*/config	setf gitconfig
    1              0.000034 au BufNewFile,BufRead */.config/git/config	setf gitconfig
    1              0.000038 au BufNewFile,BufRead git-rebase-todo		setf gitrebase
    1              0.000037 au BufNewFile,BufRead .msg.[0-9]*
                                  \ if getline(1) =~ '^From.*# This line is ignored.$' |
                                  \   setf gitsendemail |
                                  \ endif
    1              0.000039 au BufNewFile,BufRead *.git/*
                                  \ if getline(1) =~ '^\x\{40\}\>\|^ref: ' |
                                  \   setf git |
                                  \ endif
                            
                            " Gkrellmrc
    1              0.000060 au BufNewFile,BufRead gkrellmrc,gkrellmrc_?	setf gkrellmrc
                            
                            " GP scripts (2.0 and onward)
    1              0.000062 au BufNewFile,BufRead *.gp,.gprc		setf gp
                            
                            " GPG
    1              0.000036 au BufNewFile,BufRead */.gnupg/options		setf gpg
    1              0.000037 au BufNewFile,BufRead */.gnupg/gpg.conf		setf gpg
    1              0.000039 au BufNewFile,BufRead */usr/*/gnupg/options.skel setf gpg
                            
                            " gnash(1) configuration files
    1              0.000110 au BufNewFile,BufRead gnashrc,.gnashrc,gnashpluginrc,.gnashpluginrc setf gnash
                            
                            " Gitolite
    1              0.000040 au BufNewFile,BufRead gitolite.conf		setf gitolite
    1              0.000036 au BufNewFile,BufRead */gitolite-admin/conf/*	call s:StarSetf('gitolite')
    1              0.000060 au BufNewFile,BufRead {,.}gitolite.rc,example.gitolite.rc	setf perl
                            
                            " Gnuplot scripts
    1              0.000042 au BufNewFile,BufRead *.gpi			setf gnuplot
                            
                            " GrADS scripts
    1              0.000047 au BufNewFile,BufRead *.gs			setf grads
                            
                            " Gretl
    1              0.000044 au BufNewFile,BufRead *.gretl			setf gretl
                            
                            " Groovy
    1              0.000033 au BufNewFile,BufRead *.groovy			setf groovy
                            
                            " GNU Server Pages
    1              0.000039 au BufNewFile,BufRead *.gsp			setf gsp
                            
                            " Group file
    1              0.000220 au BufNewFile,BufRead */etc/group,*/etc/group-,*/etc/group.edit,*/etc/gshadow,*/etc/gshadow-,*/etc/gshadow.edit,*/var/backups/group.bak,*/var/backups/gshadow.bak  setf group
                            
                            " GTK RC
    1              0.000066 au BufNewFile,BufRead .gtkrc,gtkrc		setf gtkrc
                            
                            " Haml
    1              0.000035 au BufNewFile,BufRead *.haml			setf haml
                            
                            " Hamster Classic | Playground files
    1              0.000062 au BufNewFile,BufRead *.hsc,*.hsm		setf hamster
                            
                            " Haskell
    1              0.000059 au BufNewFile,BufRead *.hs,*.hs-boot		setf haskell
    1              0.000035 au BufNewFile,BufRead *.lhs			setf lhaskell
    1              0.000039 au BufNewFile,BufRead *.chs			setf chaskell
                            
                            " Haste
    1              0.000035 au BufNewFile,BufRead *.ht			setf haste
    1              0.000035 au BufNewFile,BufRead *.htpp			setf hastepreproc
                            
                            " Hercules
    1              0.000135 au BufNewFile,BufRead *.vc,*.ev,*.rs,*.sum,*.errsum	setf hercules
                            
                            " HEX (Intel)
    1              0.000064 au BufNewFile,BufRead *.hex,*.h32		setf hex
                            
                            " Tilde (must be before HTML)
    1              0.000035 au BufNewFile,BufRead *.t.html			setf tilde
                            
                            " HTML (.shtml and .stm for server side)
    1              0.000135 au BufNewFile,BufRead *.html,*.htm,*.shtml,*.stm  call s:FThtml()
                            
                            " Distinguish between HTML, XHTML and Django
    1              0.000004 func! s:FThtml()
                              let n = 1
                              while n < 10 && n < line("$")
                                if getline(n) =~ '\<DTD\s\+XHTML\s'
                                  setf xhtml
                                  return
                                endif
                                if getline(n) =~ '{%\s*\(extends\|block\)\>'
                                  setf htmldjango
                                  return
                                endif
                                let n = n + 1
                              endwhile
                              setf html
                            endfunc
                            
                            " HTML with Ruby - eRuby
    1              0.000067 au BufNewFile,BufRead *.erb,*.rhtml		setf eruby
                            
                            " HTML with M4
    1              0.000036 au BufNewFile,BufRead *.html.m4			setf htmlm4
                            
                            " HTML Cheetah template
    1              0.000034 au BufNewFile,BufRead *.tmpl			setf htmlcheetah
                            
                            " Host config
    1              0.000041 au BufNewFile,BufRead */etc/host.conf		setf hostconf
                            
                            " Hosts access
    1              0.000067 au BufNewFile,BufRead */etc/hosts.allow,*/etc/hosts.deny  setf hostsaccess
                            
                            " Hyper Builder
    1              0.000036 au BufNewFile,BufRead *.hb			setf hb
                            
                            " Httest
    1              0.000064 au BufNewFile,BufRead *.htt,*.htb		setf httest
                            
                            " Icon
    1              0.000037 au BufNewFile,BufRead *.icn			setf icon
                            
                            " IDL (Interface Description Language)
    1              0.000035 au BufNewFile,BufRead *.idl			call s:FTidl()
                            
                            " Distinguish between standard IDL and MS-IDL
    1              0.000002 func! s:FTidl()
                              let n = 1
                              while n < 50 && n < line("$")
                                if getline(n) =~ '^\s*import\s\+"\(unknwn\|objidl\)\.idl"'
                                  setf msidl
                                  return
                                endif
                                let n = n + 1
                              endwhile
                              setf idl
                            endfunc
                            
                            " Microsoft IDL (Interface Description Language)  Also *.idl
                            " MOF = WMI (Windows Management Instrumentation) Managed Object Format
    1              0.000064 au BufNewFile,BufRead *.odl,*.mof		setf msidl
                            
                            " Icewm menu
    1              0.000038 au BufNewFile,BufRead */.icewm/menu		setf icemenu
                            
                            " Indent profile (must come before IDL *.pro!)
    1              0.000036 au BufNewFile,BufRead .indent.pro		setf indent
    1              0.000040 au BufNewFile,BufRead indent.pro		call s:ProtoCheck('indent')
                            
                            " IDL (Interactive Data Language)
    1              0.000037 au BufNewFile,BufRead *.pro			call s:ProtoCheck('idlang')
                            
                            " Distinguish between "default" and Cproto prototype file. */
    1              0.000003 func! s:ProtoCheck(default)
                              " Cproto files have a comment in the first line and a function prototype in
                              " the second line, it always ends in ";".  Indent files may also have
                              " comments, thus we can't match comments to see the difference.
                              " IDL files can have a single ';' in the second line, require at least one
                              " chacter before the ';'.
                              if getline(2) =~ '.;$'
                                setf cpp
                              else
                                exe 'setf ' . a:default
                              endif
                            endfunc
                            
                            
                            " Indent RC
    1              0.000041 au BufNewFile,BufRead indentrc			setf indent
                            
                            " Inform
    1              0.000063 au BufNewFile,BufRead *.inf,*.INF		setf inform
                            
                            " Initng
    1              0.000068 au BufNewFile,BufRead */etc/initng/*/*.i,*.ii	setf initng
                            
                            " Innovation Data Processing
    1              0.000092 au BufRead,BufNewFile upstream.dat\c,upstream.*.dat\c,*.upstream.dat\c 	setf upstreamdat
    1              0.000122 au BufRead,BufNewFile upstream.log\c,upstream.*.log\c,*.upstream.log\c 	setf upstreamlog
    1              0.000128 au BufRead,BufNewFile upstreaminstall.log\c,upstreaminstall.*.log\c,*.upstreaminstall.log\c setf upstreaminstalllog
    1              0.000099 au BufRead,BufNewFile usserver.log\c,usserver.*.log\c,*.usserver.log\c 	setf usserverlog
    1              0.000099 au BufRead,BufNewFile usw2kagt.log\c,usw2kagt.*.log\c,*.usw2kagt.log\c 	setf usw2kagtlog
                            
                            " Ipfilter
    1              0.000102 au BufNewFile,BufRead ipf.conf,ipf6.conf,ipf.rules	setf ipfilter
                            
                            " Informix 4GL (source - canonical, include file, I4GL+M4 preproc.)
    1              0.000100 au BufNewFile,BufRead *.4gl,*.4gh,*.m4gl	setf fgl
                            
                            " .INI file for MSDOS
    1              0.000040 au BufNewFile,BufRead *.ini			setf dosini
                            
                            " SysV Inittab
    1              0.000039 au BufNewFile,BufRead inittab			setf inittab
                            
                            " Inno Setup
    1              0.000040 au BufNewFile,BufRead *.iss			setf iss
                            
                            " J
    1              0.000036 au BufNewFile,BufRead *.ijs			setf j
                            
                            " JAL
    1              0.000066 au BufNewFile,BufRead *.jal,*.JAL		setf jal
                            
                            " Jam
    1              0.000062 au BufNewFile,BufRead *.jpl,*.jpr		setf jam
                            
                            " Java
    1              0.000066 au BufNewFile,BufRead *.java,*.jav		setf java
                            
                            " JavaCC
    1              0.000064 au BufNewFile,BufRead *.jj,*.jjt		setf javacc
                            
                            " JavaScript, ECMAScript
    1              0.000178 au BufNewFile,BufRead *.js,*.javascript,*.es,*.jsx,*.json   setf javascript
                            
                            " Java Server Pages
    1              0.000043 au BufNewFile,BufRead *.jsp			setf jsp
                            
                            " Java Properties resource file (note: doesn't catch font.properties.pl)
    1              0.000104 au BufNewFile,BufRead *.properties,*.properties_??,*.properties_??_??	setf jproperties
    1              0.000054 au BufNewFile,BufRead *.properties_??_??_*	call s:StarSetf('jproperties')
                            
                            " Jess
    1              0.000039 au BufNewFile,BufRead *.clp			setf jess
                            
                            " Jgraph
    1              0.000037 au BufNewFile,BufRead *.jgr			setf jgraph
                            
                            " Jovial
    1              0.000093 au BufNewFile,BufRead *.jov,*.j73,*.jovial	setf jovial
                            
                            " Kixtart
    1              0.000038 au BufNewFile,BufRead *.kix			setf kix
                            
                            " Kimwitu[++]
    1              0.000037 au BufNewFile,BufRead *.k			setf kwt
                            
                            " KDE script
    1              0.000040 au BufNewFile,BufRead *.ks			setf kscript
                            
                            " Kconfig
    1              0.000069 au BufNewFile,BufRead Kconfig,Kconfig.debug	setf kconfig
                            
                            " Lace (ISE)
    1              0.000067 au BufNewFile,BufRead *.ace,*.ACE		setf lace
                            
                            " Latte
    1              0.000068 au BufNewFile,BufRead *.latte,*.lte		setf latte
                            
                            " Limits
    1              0.000104 au BufNewFile,BufRead */etc/limits,*/etc/*limits.conf,*/etc/*limits.d/*.conf	setf limits
                            
                            " LambdaProlog (*.mod too, see Modsim)
    1              0.000040 au BufNewFile,BufRead *.sig			setf lprolog
                            
                            " LDAP LDIF
    1              0.000038 au BufNewFile,BufRead *.ldif			setf ldif
                            
                            " Ld loader
    1              0.000037 au BufNewFile,BufRead *.ld			setf ld
                            
                            " Lex
    1              0.000100 au BufNewFile,BufRead *.lex,*.l			setf lex
                            
                            " Libao
    1              0.000069 au BufNewFile,BufRead */etc/libao.conf,*/.libao	setf libao
                            
                            " Libsensors
    1              0.000072 au BufNewFile,BufRead */etc/sensors.conf,*/etc/sensors3.conf	setf sensors
                            
                            " LFTP
    1              0.000097 au BufNewFile,BufRead lftp.conf,.lftprc,*lftp/rc	setf lftp
                            
                            " Lifelines (or Lex for C++!)
    1              0.000042 au BufNewFile,BufRead *.ll			setf lifelines
                            
                            " Lilo: Linux loader
    1              0.000041 au BufNewFile,BufRead lilo.conf			setf lilo
                            
                            " Lisp (*.el = ELisp, *.cl = Common Lisp, *.jl = librep Lisp)
    1              0.000006 if has("fname_case")
                              au BufNewFile,BufRead *.lsp,*.lisp,*.el,*.cl,*.jl,*.L,.emacs,.sawfishrc setf lisp
                            else
    1              0.000208   au BufNewFile,BufRead *.lsp,*.lisp,*.el,*.cl,*.jl,.emacs,.sawfishrc setf lisp
    1              0.000002 endif
                            
                            " SBCL implementation of Common Lisp
    1              0.000065 au BufNewFile,BufRead sbclrc,.sbclrc		setf lisp
                            
                            " Liquid
    1              0.000043 au BufNewFile,BufRead *.liquid			setf liquid
                            
                            " Lite
    1              0.000071 au BufNewFile,BufRead *.lite,*.lt		setf lite
                            
                            " LiteStep RC files
    1              0.000046 au BufNewFile,BufRead */LiteStep/*/*.rc		setf litestep
                            
                            " Login access
    1              0.000041 au BufNewFile,BufRead */etc/login.access	setf loginaccess
                            
                            " Login defs
    1              0.000044 au BufNewFile,BufRead */etc/login.defs		setf logindefs
                            
                            " Logtalk
    1              0.000040 au BufNewFile,BufRead *.lgt			setf logtalk
                            
                            " LOTOS
    1              0.000069 au BufNewFile,BufRead *.lot,*.lotos		setf lotos
                            
                            " Lout (also: *.lt)
    1              0.000090 au BufNewFile,BufRead *.lou,*.lout		setf lout
                            
                            " Lua
    1              0.000043 au BufNewFile,BufRead *.lua			setf lua
                            
                            " Linden Scripting Language (Second Life)
    1              0.000052 au BufNewFile,BufRead *.lsl			setf lsl
                            
                            " Lynx style file (or LotusScript!)
    1              0.000040 au BufNewFile,BufRead *.lss			setf lss
                            
                            " M4
    1              0.000040 au BufNewFile,BufRead *.m4
                            	\ if expand("<afile>") !~? 'html.m4$\|fvwm2rc' | setf m4 | endif
                            
                            " MaGic Point
    1              0.000040 au BufNewFile,BufRead *.mgp			setf mgp
                            
                            " Mail (for Elm, trn, mutt, muttng, rn, slrn)
    1              0.000378 au BufNewFile,BufRead snd.\d\+,.letter,.letter.\d\+,.followup,.article,.article.\d\+,pico.\d\+,mutt{ng,}-*-\w\+,mutt[[:alnum:]_-]\\\{6\},ae\d\+.txt,/tmp/SLRN[0-9A-Z.]\+,*.eml setf mail
                            
                            " Mail aliases
    1              0.000076 au BufNewFile,BufRead */etc/mail/aliases,*/etc/aliases	setf mailaliases
                            
                            " Mailcap configuration file
    1              0.000073 au BufNewFile,BufRead .mailcap,mailcap		setf mailcap
                            
                            " Makefile
    1              0.000132 au BufNewFile,BufRead *[mM]akefile,*.mk,*.mak,*.dsp setf make
                            
                            " MakeIndex
    1              0.000070 au BufNewFile,BufRead *.ist,*.mst		setf ist
                            
                            " Mallard
    1              0.000042 au BufNewFile,BufRead *.page			setf mallard
                            
                            " Manpage
    1              0.000063 au BufNewFile,BufRead *.man			setf man
                            
                            " Man config
    1              0.000085 au BufNewFile,BufRead */etc/man.conf,man.config	setf manconf
                            
                            " Maple V
    1              0.000099 au BufNewFile,BufRead *.mv,*.mpl,*.mws		setf maple
                            
                            " Map (UMN mapserver config file)
    1              0.000040 au BufNewFile,BufRead *.map			setf map
                            
                            " Markdown
    1              0.000190 au BufNewFile,BufRead *.markdown,*.mdown,*.mkd,*.mkdn,*.mdwn,README.md  setf markdown
                            
                            " Mason
    1              0.000073 au BufNewFile,BufRead *.mason,*.mhtml		setf mason
                            
                            " Matlab or Objective C
    1              0.000042 au BufNewFile,BufRead *.m			call s:FTm()
                            
    1              0.000004 func! s:FTm()
                              let n = 1
                              while n < 10
                                let line = getline(n)
                                if line =~ '^\s*\(#\s*\(include\|import\)\>\|/\*\|//\)'
                                  setf objc
                                  return
                                endif
                                if line =~ '^\s*%'
                                  setf matlab
                                  return
                                endif
                                if line =~ '^\s*(\*'
                                  setf mma
                                  return
                                endif
                                let n = n + 1
                              endwhile
                              if exists("g:filetype_m")
                                exe "setf " . g:filetype_m
                              else
                                setf matlab
                              endif
                            endfunc
                            
                            " Mathematica notebook
    1              0.000042 au BufNewFile,BufRead *.nb			setf mma
                            
                            " Maya Extension Language
    1              0.000045 au BufNewFile,BufRead *.mel			setf mel
                            
                            " Mercurial (hg) commit file
    1              0.000044 au BufNewFile,BufRead hg-editor-*.txt		setf hgcommit
                            
                            " Mercurial config (looks like generic config file)
    1              0.000077 au BufNewFile,BufRead *.hgrc,*hgrc		setf cfg
                            
                            " Messages (logs mostly)
    1              0.000060 au BufNewFile,BufRead */log/{auth,cron,daemon,debug,kern,lpr,mail,messages,news/news,syslog,user}{,.log,.err,.info,.warn,.crit,.notice}{,.[0-9]*,-[0-9]*} setf messages
                            
                            " Metafont
    1              0.000041 au BufNewFile,BufRead *.mf			setf mf
                            
                            " MetaPost
    1              0.000040 au BufNewFile,BufRead *.mp			setf mp
                            
                            " MGL
    1              0.000041 au BufNewFile,BufRead *.mgl			setf mgl
                            
                            " MMIX or VMS makefile
    1              0.000044 au BufNewFile,BufRead *.mms			call s:FTmms()
                            
                            " Symbian meta-makefile definition (MMP)
    1              0.000056 au BufNewFile,BufRead *.mmp			setf mmp
                            
    1              0.000004 func! s:FTmms()
                              let n = 1
                              while n < 10
                                let line = getline(n)
                                if line =~ '^\s*\(%\|//\)' || line =~ '^\*'
                                  setf mmix
                                  return
                                endif
                                if line =~ '^\s*#'
                                  setf make
                                  return
                                endif
                                let n = n + 1
                              endwhile
                              setf mmix
                            endfunc
                            
                            
                            " Modsim III (or LambdaProlog)
    1              0.000056 au BufNewFile,BufRead *.mod
                            	\ if getline(1) =~ '\<module\>' |
                            	\   setf lprolog |
                            	\ else |
                            	\   setf modsim3 |
                            	\ endif
                            
                            " Modula 2
    1              0.000164 au BufNewFile,BufRead *.m2,*.DEF,*.MOD,*.md,*.mi setf modula2
                            
                            " Modula 3 (.m3, .i3, .mg, .ig)
    1              0.000047 au BufNewFile,BufRead *.[mi][3g]		setf modula3
                            
                            " Monk
    1              0.000137 au BufNewFile,BufRead *.isc,*.monk,*.ssc,*.tsc	setf monk
                            
                            " MOO
    1              0.000042 au BufNewFile,BufRead *.moo			setf moo
                            
                            " Modconf
    1              0.000108 au BufNewFile,BufRead */etc/modules.conf,*/etc/modules,*/etc/conf.modules setf modconf
                            
                            " Mplayer config
    1              0.000078 au BufNewFile,BufRead mplayer.conf,*/.mplayer/config	setf mplayerconf
                            
                            " Moterola S record
    1              0.000107 au BufNewFile,BufRead *.s19,*.s28,*.s37		setf srec
                            
                            " Mrxvtrc
    1              0.000077 au BufNewFile,BufRead mrxvtrc,.mrxvtrc		setf mrxvtrc
                            
                            " Msql
    1              0.000042 au BufNewFile,BufRead *.msql			setf msql
                            
                            " Mysql
    1              0.000041 au BufNewFile,BufRead *.mysql			setf mysql
                            
                            " Mutt setup files (must be before catch *.rc)
    1              0.000047 au BufNewFile,BufRead */etc/Muttrc.d/*		call s:StarSetf('muttrc')
                            
                            " M$ Resource files
    1              0.000080 au BufNewFile,BufRead *.rc,*.rch		setf rc
                            
                            " MuPAD source
    1              0.000052 au BufRead,BufNewFile *.mu			setf mupad
                            
                            " Mush
    1              0.000047 au BufNewFile,BufRead *.mush			setf mush
                            
                            " Mutt setup file (also for Muttng)
    1              0.000047 au BufNewFile,BufRead Mutt{ng,}rc		setf muttrc
                            
                            " Nano
    1              0.000083 au BufNewFile,BufRead */etc/nanorc,.nanorc	setf nanorc
                            
                            " Nastran input/DMAP
                            "au BufNewFile,BufRead *.dat			setf nastran
                            
                            " Natural
    1              0.000054 au BufNewFile,BufRead *.NS[ACGLMNPS]		setf natural
                            
                            " Netrc
    1              0.000046 au BufNewFile,BufRead .netrc			setf netrc
                            
                            " Ninja file
    1              0.000043 au BufNewFile,BufRead *.ninja			setf ninja
                            
                            " Novell netware batch files
    1              0.000043 au BufNewFile,BufRead *.ncf			setf ncf
                            
                            " Nroff/Troff (*.ms and *.t are checked below)
    1              0.000045 au BufNewFile,BufRead *.me
                            	\ if expand("<afile>") != "read.me" && expand("<afile>") != "click.me" |
                            	\   setf nroff |
                            	\ endif
    1              0.000170 au BufNewFile,BufRead *.tr,*.nr,*.roff,*.tmac,*.mom	setf nroff
    1              0.000045 au BufNewFile,BufRead *.[1-9]			call s:FTnroff()
                            
                            " This function checks if one of the first five lines start with a dot.  In
                            " that case it is probably an nroff file: 'filetype' is set and 1 is returned.
    1              0.000004 func! s:FTnroff()
                              if getline(1)[0] . getline(2)[0] . getline(3)[0] . getline(4)[0] . getline(5)[0] =~ '\.'
                                setf nroff
                                return 1
                              endif
                              return 0
                            endfunc
                            
                            " Nroff or Objective C++
    1              0.000044 au BufNewFile,BufRead *.mm			call s:FTmm()
                            
    1              0.000002 func! s:FTmm()
                              let n = 1
                              while n < 10
                                let line = getline(n)
                                if line =~ '^\s*\(#\s*\(include\|import\)\>\|/\*\)'
                                  setf objcpp
                                  return
                                endif
                                let n = n + 1
                              endwhile
                              setf nroff
                            endfunc
                            
                            " Not Quite C
    1              0.000045 au BufNewFile,BufRead *.nqc			setf nqc
                            
                            " NSIS
    1              0.000082 au BufNewFile,BufRead *.nsi,*.nsh		setf nsis
                            
                            " OCAML
    1              0.000198 au BufNewFile,BufRead *.ml,*.mli,*.mll,*.mly,.ocamlinit	setf ocaml
                            
                            " Occam
    1              0.000058 au BufNewFile,BufRead *.occ			setf occam
                            
                            " Omnimark
    1              0.000076 au BufNewFile,BufRead *.xom,*.xin		setf omnimark
                            
                            " OpenROAD
    1              0.000043 au BufNewFile,BufRead *.or			setf openroad
                            
                            " OPL
    1              0.000047 au BufNewFile,BufRead *.[Oo][Pp][Ll]		setf opl
                            
                            " Oracle config file
    1              0.000045 au BufNewFile,BufRead *.ora			setf ora
                            
                            " Packet filter conf
    1              0.000043 au BufNewFile,BufRead pf.conf			setf pf
                            
                            " Pam conf
    1              0.000046 au BufNewFile,BufRead */etc/pam.conf		setf pamconf
                            
                            " PApp
    1              0.000104 au BufNewFile,BufRead *.papp,*.pxml,*.pxsl	setf papp
                            
                            " Password file
    1              0.000275 au BufNewFile,BufRead */etc/passwd,*/etc/passwd-,*/etc/passwd.edit,*/etc/shadow,*/etc/shadow-,*/etc/shadow.edit,*/var/backups/passwd.bak,*/var/backups/shadow.bak setf passwd
                            
                            " Pascal (also *.p)
    1              0.000044 au BufNewFile,BufRead *.pas			setf pascal
                            
                            " Delphi project file
    1              0.000046 au BufNewFile,BufRead *.dpr			setf pascal
                            
                            " PDF
    1              0.000044 au BufNewFile,BufRead *.pdf			setf pdf
                            
                            " Perl
    1              0.000006 if has("fname_case")
                              au BufNewFile,BufRead *.pl,*.PL		call s:FTpl()
                            else
    1              0.000044   au BufNewFile,BufRead *.pl			call s:FTpl()
    1              0.000002 endif
    1              0.000080 au BufNewFile,BufRead *.plx,*.al		setf perl
    1              0.000110 au BufNewFile,BufRead *.p6,*.pm6		setf perl6
                            
    1              0.000003 func! s:FTpl()
                              if exists("g:filetype_pl")
                                exe "setf " . g:filetype_pl
                              else
                                " recognize Prolog by specific text in the first non-empty line
                                " require a blank after the '%' because Perl uses "%list" and "%translate"
                                let l = getline(nextnonblank(1))
                                if l =~ '\<prolog\>' || l =~ '^\s*\(%\+\(\s\|$\)\|/\*\)' || l =~ ':-'
                                  setf prolog
                                else
                                  setf perl
                                endif
                              endif
                            endfunc
                            
                            " Perl, XPM or XPM2
    1              0.000049 au BufNewFile,BufRead *.pm
                            	\ if getline(1) =~ "XPM2" |
                            	\   setf xpm2 |
                            	\ elseif getline(1) =~ "XPM" |
                            	\   setf xpm |
                            	\ else |
                            	\   setf perl |
                            	\ endif
                            
                            " Perl POD
    1              0.000049 au BufNewFile,BufRead *.pod			setf pod
                            
                            " Php, php3, php4, etc.
                            " Also Phtml (was used for PHP 2 in the past)
                            " Also .ctp for Cake template file
    1              0.000145 au BufNewFile,BufRead *.php,*.php\d,*.phtml,*.ctp	setf php
                            
                            " Pike
    1              0.000143 au BufNewFile,BufRead *.pike,*.lpc,*.ulpc,*.pmod setf pike
                            
                            " Pinfo config
    1              0.000077 au BufNewFile,BufRead */etc/pinforc,*/.pinforc	setf pinfo
                            
                            " Palm Resource compiler
    1              0.000049 au BufNewFile,BufRead *.rcp			setf pilrc
                            
                            " Pine config
    1              0.000144 au BufNewFile,BufRead .pinerc,pinerc,.pinercex,pinercex		setf pine
                            
                            " PL/1, PL/I
    1              0.000079 au BufNewFile,BufRead *.pli,*.pl1		setf pli
                            
                            " PL/M (also: *.inp)
    1              0.000115 au BufNewFile,BufRead *.plm,*.p36,*.pac		setf plm
                            
                            " PL/SQL
    1              0.000083 au BufNewFile,BufRead *.pls,*.plsql		setf plsql
                            
                            " PLP
    1              0.000059 au BufNewFile,BufRead *.plp			setf plp
                            
                            " PO and PO template (GNU gettext)
    1              0.000116 au BufNewFile,BufRead *.po,*.pot		setf po
                            
                            " Postfix main config
    1              0.000050 au BufNewFile,BufRead main.cf			setf pfmain
                            
                            " PostScript (+ font files, encapsulated PostScript, Adobe Illustrator)
    1              0.000247 au BufNewFile,BufRead *.ps,*.pfa,*.afm,*.eps,*.epsf,*.epsi,*.ai	  setf postscr
                            
                            " PostScript Printer Description
    1              0.000049 au BufNewFile,BufRead *.ppd			setf ppd
                            
                            " Povray
    1              0.000045 au BufNewFile,BufRead *.pov			setf pov
                            
                            " Povray configuration
    1              0.000046 au BufNewFile,BufRead .povrayrc			setf povini
                            
                            " Povray, PHP or assembly
    1              0.000049 au BufNewFile,BufRead *.inc			call s:FTinc()
                            
    1              0.000003 func! s:FTinc()
                              if exists("g:filetype_inc")
                                exe "setf " . g:filetype_inc
                              else
                                let lines = getline(1).getline(2).getline(3)
                                if lines =~? "perlscript"
                                  setf aspperl
                                elseif lines =~ "<%"
                                  setf aspvbs
                                elseif lines =~ "<?"
                                  setf php
                                else
                                  call s:FTasmsyntax()
                                  if exists("b:asmsyntax")
                            	exe "setf " . fnameescape(b:asmsyntax)
                                  else
                            	setf pov
                                  endif
                                endif
                              endif
                            endfunc
                            
                            " Printcap and Termcap
    1              0.000048 au BufNewFile,BufRead *printcap
                            	\ let b:ptcap_type = "print" | setf ptcap
    1              0.000046 au BufNewFile,BufRead *termcap
                            	\ let b:ptcap_type = "term" | setf ptcap
                            
                            " PCCTS / ANTRL
                            "au BufNewFile,BufRead *.g			setf antrl
    1              0.000067 au BufNewFile,BufRead *.g			setf pccts
                            
                            " PPWizard
    1              0.000078 au BufNewFile,BufRead *.it,*.ih			setf ppwiz
                            
                            " Obj 3D file format
                            " TODO: is there a way to avoid MS-Windows Object files?
    1              0.000047 au BufNewFile,BufRead *.obj			setf obj
                            
                            " Oracle Pro*C/C++
    1              0.000046 au BufNewFile,BufRead *.pc			setf proc
                            
                            " Privoxy actions file
    1              0.000049 au BufNewFile,BufRead *.action			setf privoxy
                            
                            " Procmail
    1              0.000113 au BufNewFile,BufRead .procmail,.procmailrc	setf procmail
                            
                            " Progress or CWEB
    1              0.000069 au BufNewFile,BufRead *.w			call s:FTprogress_cweb()
                            
    1              0.000006 func! s:FTprogress_cweb()
                              if exists("g:filetype_w")
                                exe "setf " . g:filetype_w
                                return
                              endif
                              if getline(1) =~ '&ANALYZE' || getline(3) =~ '&GLOBAL-DEFINE'
                                setf progress
                              else
                                setf cweb
                              endif
                            endfunc
                            
                            " Progress or assembly
    1              0.000074 au BufNewFile,BufRead *.i			call s:FTprogress_asm()
                            
    1              0.000003 func! s:FTprogress_asm()
                              if exists("g:filetype_i")
                                exe "setf " . g:filetype_i
                                return
                              endif
                              " This function checks for an assembly comment the first ten lines.
                              " If not found, assume Progress.
                              let lnum = 1
                              while lnum <= 10 && lnum < line('$')
                                let line = getline(lnum)
                                if line =~ '^\s*;' || line =~ '^\*'
                                  call s:FTasm()
                                  return
                                elseif line !~ '^\s*$' || line =~ '^/\*'
                                  " Not an empty line: Doesn't look like valid assembly code.
                                  " Or it looks like a Progress /* comment
                                  break
                                endif
                                let lnum = lnum + 1
                              endw
                              setf progress
                            endfunc
                            
                            " Progress or Pascal
    1              0.000049 au BufNewFile,BufRead *.p			call s:FTprogress_pascal()
                            
    1              0.000003 func! s:FTprogress_pascal()
                              if exists("g:filetype_p")
                                exe "setf " . g:filetype_p
                                return
                              endif
                              " This function checks for valid Pascal syntax in the first ten lines.
                              " Look for either an opening comment or a program start.
                              " If not found, assume Progress.
                              let lnum = 1
                              while lnum <= 10 && lnum < line('$')
                                let line = getline(lnum)
                                if line =~ '^\s*\(program\|unit\|procedure\|function\|const\|type\|var\)\>'
                            	\ || line =~ '^\s*{' || line =~ '^\s*(\*'
                                  setf pascal
                                  return
                                elseif line !~ '^\s*$' || line =~ '^/\*'
                                  " Not an empty line: Doesn't look like valid Pascal code.
                                  " Or it looks like a Progress /* comment
                                  break
                                endif
                                let lnum = lnum + 1
                              endw
                              setf progress
                            endfunc
                            
                            
                            " Software Distributor Product Specification File (POSIX 1387.2-1995)
    1              0.000049 au BufNewFile,BufRead *.psf			setf psf
    1              0.000088 au BufNewFile,BufRead INDEX,INFO
                            	\ if getline(1) =~ '^\s*\(distribution\|installed_software\|root\|bundle\|product\)\s*$' |
                            	\   setf psf |
                            	\ endif
                            
                            " Prolog
    1              0.000047 au BufNewFile,BufRead *.pdb			setf prolog
                            
                            " Promela
    1              0.000046 au BufNewFile,BufRead *.pml			setf promela
                            
                            " Google protocol buffers
    1              0.000046 au BufNewFile,BufRead *.proto			setf proto
                            
                            " Protocols
    1              0.000051 au BufNewFile,BufRead */etc/protocols		setf protocols
                            
                            " Pyrex
    1              0.000082 au BufNewFile,BufRead *.pyx,*.pxd		setf pyrex
                            
                            " Python
    1              0.000086 au BufNewFile,BufRead *.py,*.pyw		setf python
                            
                            " Quixote (Python-based web framework)
    1              0.000046 au BufNewFile,BufRead *.ptl			setf python
                            
                            " Radiance
    1              0.000087 au BufNewFile,BufRead *.rad,*.mat		setf radiance
                            
                            " Ratpoison config/command files
    1              0.000081 au BufNewFile,BufRead .ratpoisonrc,ratpoisonrc	setf ratpoison
                            
                            " RCS file
    1              0.000065 au BufNewFile,BufRead *\,v			setf rcs
                            
                            " Readline
    1              0.000096 au BufNewFile,BufRead .inputrc,inputrc		setf readline
                            
                            " Registry for MS-Windows
    1              0.000053 au BufNewFile,BufRead *.reg
                            	\ if getline(1) =~? '^REGEDIT[0-9]*\s*$\|^Windows Registry Editor Version \d*\.\d*\s*$' | setf registry | endif
                            
                            " Renderman Interface Bytestream
    1              0.000048 au BufNewFile,BufRead *.rib			setf rib
                            
                            " Rexx
    1              0.000330 au BufNewFile,BufRead *.rex,*.orx,*.rxo,*.rxj,*.jrexx,*.rexxj,*.rexx,*.testGroup,*.testUnit	setf rexx
                            
                            " R (Splus)
    1              0.000007 if has("fname_case")
                              au BufNewFile,BufRead *.s,*.S			setf r
                            else
    1              0.000046   au BufNewFile,BufRead *.s			setf r
    1              0.000002 endif
                            
                            " R Help file
    1              0.000005 if has("fname_case")
                              au BufNewFile,BufRead *.rd,*.Rd		setf rhelp
                            else
    1              0.000051   au BufNewFile,BufRead *.rd			setf rhelp
    1              0.000001 endif
                            
                            " R noweb file
    1              0.000004 if has("fname_case")
                              au BufNewFile,BufRead *.Rnw,*.rnw,*.Snw,*.snw		setf rnoweb
                            else
    1              0.000085   au BufNewFile,BufRead *.rnw,*.snw			setf rnoweb
    1              0.000001 endif
                            
                            " Rexx, Rebol or R
    1              0.000082 au BufNewFile,BufRead *.r,*.R			call s:FTr()
                            
    1              0.000003 func! s:FTr()
                              let max = line("$") > 50 ? 50 : line("$")
                            
                              for n in range(1, max)
                                " Rebol is easy to recognize, check for that first
                                if getline(n) =~? '\<REBOL\>'
                                  setf rebol
                                  return
                                endif
                              endfor
                            
                              for n in range(1, max)
                                " R has # comments
                                if getline(n) =~ '^\s*#'
                                  setf r
                                  return
                                endif
                                " Rexx has /* comments */
                                if getline(n) =~ '^\s*/\*'
                                  setf rexx
                                  return
                                endif
                              endfor
                            
                              " Nothing recognized, use user default or assume Rexx
                              if exists("g:filetype_r")
                                exe "setf " . g:filetype_r
                              else
                                " Rexx used to be the default, but R appears to be much more popular.
                                setf r
                              endif
                            endfunc
                            
                            " Remind
    1              0.000131 au BufNewFile,BufRead .reminders,*.remind,*.rem		setf remind
                            
                            " Resolv.conf
    1              0.000048 au BufNewFile,BufRead resolv.conf		setf resolv
                            
                            " Relax NG Compact
    1              0.000067 au BufNewFile,BufRead *.rnc			setf rnc
                            
                            " Relax NG XML
    1              0.000062 au BufNewFile,BufRead *.rng			setf rng
                            
                            " RPL/2
    1              0.000048 au BufNewFile,BufRead *.rpl			setf rpl
                            
                            " Robots.txt
    1              0.000048 au BufNewFile,BufRead robots.txt		setf robots
                            
                            " Rpcgen
    1              0.000046 au BufNewFile,BufRead *.x			setf rpcgen
                            
                            " reStructuredText Documentation Format
    1              0.000051 au BufNewFile,BufRead *.rst			setf rst
                            
                            " RTF
    1              0.000047 au BufNewFile,BufRead *.rtf			setf rtf
                            
                            " Interactive Ruby shell
    1              0.000088 au BufNewFile,BufRead .irbrc,irbrc		setf ruby
                            
                            " Ruby
    1              0.000085 au BufNewFile,BufRead *.rb,*.rbw		setf ruby
                            
                            " RubyGems
    1              0.000046 au BufNewFile,BufRead *.gemspec			setf ruby
                            
                            " Rackup
    1              0.000050 au BufNewFile,BufRead *.ru			setf ruby
                            
                            " Bundler
    1              0.000049 au BufNewFile,BufRead Gemfile			setf ruby
                            
                            " Ruby on Rails
    1              0.000122 au BufNewFile,BufRead *.builder,*.rxml,*.rjs	setf ruby
                            
                            " Rantfile and Rakefile is like Ruby
    1              0.000159 au BufNewFile,BufRead [rR]antfile,*.rant,[rR]akefile,*.rake	setf ruby
                            
                            " S-lang (or shader language, or SmallLisp)
    1              0.000049 au BufNewFile,BufRead *.sl			setf slang
                            
                            " Samba config
    1              0.000061 au BufNewFile,BufRead smb.conf			setf samba
                            
                            " SAS script
    1              0.000063 au BufNewFile,BufRead *.sas			setf sas
                            
                            " Sass
    1              0.000059 au BufNewFile,BufRead *.sass			setf sass
                            
                            " Sather
    1              0.000048 au BufNewFile,BufRead *.sa			setf sather
                            
                            " Scilab
    1              0.000092 au BufNewFile,BufRead *.sci,*.sce		setf scilab
                            
                            " SCSS
    1              0.000048 au BufNewFile,BufRead *.scss			setf scss
                            
                            " SD: Streaming Descriptors
    1              0.000048 au BufNewFile,BufRead *.sd			setf sd
                            
                            " SDL
    1              0.000091 au BufNewFile,BufRead *.sdl,*.pr		setf sdl
                            
                            " sed
    1              0.000049 au BufNewFile,BufRead *.sed			setf sed
                            
                            " Sieve (RFC 3028)
    1              0.000048 au BufNewFile,BufRead *.siv			setf sieve
                            
                            " Sendmail
    1              0.000051 au BufNewFile,BufRead sendmail.cf		setf sm
                            
                            " Sendmail .mc files are actually m4.  Could also be MS Message text file.
    1              0.000049 au BufNewFile,BufRead *.mc			call s:McSetf()
                            
    1              0.000004 func! s:McSetf()
                              " Rely on the file to start with a comment.
                              " MS message text files use ';', Sendmail files use '#' or 'dnl'
                              for lnum in range(1, min([line("$"), 20]))
                                let line = getline(lnum)
                                if line =~ '^\s*\(#\|dnl\)'
                                  setf m4  " Sendmail .mc file
                                  return
                                elseif line =~ '^\s*;'
                                  setf msmessages  " MS Message text file
                                  return
                                endif
                              endfor
                              setf m4  " Default: Sendmail .mc file
                            endfunc
                            
                            " Services
    1              0.000050 au BufNewFile,BufRead */etc/services		setf services
                            
                            " Service Location config
    1              0.000052 au BufNewFile,BufRead */etc/slp.conf		setf slpconf
                            
                            " Service Location registration
    1              0.000049 au BufNewFile,BufRead */etc/slp.reg		setf slpreg
                            
                            " Service Location SPI
    1              0.000051 au BufNewFile,BufRead */etc/slp.spi		setf slpspi
                            
                            " Setserial config
    1              0.000049 au BufNewFile,BufRead */etc/serial.conf		setf setserial
                            
                            " SGML
    1              0.000097 au BufNewFile,BufRead *.sgm,*.sgml
                            	\ if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'linuxdoc' |
                            	\   setf sgmllnx |
                            	\ elseif getline(1) =~ '<!DOCTYPE.*DocBook' || getline(2) =~ '<!DOCTYPE.*DocBook' |
                            	\   let b:docbk_type = "sgml" |
                            	\   let b:docbk_ver = 4 |
                            	\   setf docbk |
                            	\ else |
                            	\   setf sgml |
                            	\ endif
                            
                            " SGMLDECL
    1              0.000146 au BufNewFile,BufRead *.decl,*.dcl,*.dec
                            	\ if getline(1).getline(2).getline(3) =~? '^<!SGML' |
                            	\    setf sgmldecl |
                            	\ endif
                            
                            " SGML catalog file
    1              0.000060 au BufNewFile,BufRead catalog			setf catalog
    1              0.000050 au BufNewFile,BufRead sgml.catalog*		call s:StarSetf('catalog')
                            
                            " Shell scripts (sh, ksh, bash, bash2, csh); Allow .profile_foo etc.
                            " Gentoo ebuilds are actually bash scripts
    1              0.000274 au BufNewFile,BufRead .bashrc*,bashrc,bash.bashrc,.bash_profile*,.bash_logout*,*.bash,*.ebuild call SetFileTypeSH("bash")
    1              0.000087 au BufNewFile,BufRead .kshrc*,*.ksh call SetFileTypeSH("ksh")
    1              0.000170 au BufNewFile,BufRead */etc/profile,.profile*,*.sh,*.env call SetFileTypeSH(getline(1))
                            
                            " Also called from scripts.vim.
    1              0.000002 func! SetFileTypeSH(name)
                              if expand("<amatch>") =~ g:ft_ignore_pat
                                return
                              endif
                              if a:name =~ '\<csh\>'
                                " Some .sh scripts contain #!/bin/csh.
                                call SetFileTypeShell("csh")
                                return
                              elseif a:name =~ '\<tcsh\>'
                                " Some .sh scripts contain #!/bin/tcsh.
                                call SetFileTypeShell("tcsh")
                                return
                              elseif a:name =~ '\<zsh\>'
                                " Some .sh scripts contain #!/bin/zsh.
                                call SetFileTypeShell("zsh")
                                return
                              elseif a:name =~ '\<ksh\>'
                                let b:is_kornshell = 1
                                if exists("b:is_bash")
                                  unlet b:is_bash
                                endif
                                if exists("b:is_sh")
                                  unlet b:is_sh
                                endif
                              elseif exists("g:bash_is_sh") || a:name =~ '\<bash\>' || a:name =~ '\<bash2\>'
                                let b:is_bash = 1
                                if exists("b:is_kornshell")
                                  unlet b:is_kornshell
                                endif
                                if exists("b:is_sh")
                                  unlet b:is_sh
                                endif
                              elseif a:name =~ '\<sh\>'
                                let b:is_sh = 1
                                if exists("b:is_kornshell")
                                  unlet b:is_kornshell
                                endif
                                if exists("b:is_bash")
                                  unlet b:is_bash
                                endif
                              endif
                              call SetFileTypeShell("sh")
                            endfunc
                            
                            " For shell-like file types, check for an "exec" command hidden in a comment,
                            " as used for Tcl.
                            " Also called from scripts.vim, thus can't be local to this script.
    1              0.000002 func! SetFileTypeShell(name)
                              if expand("<amatch>") =~ g:ft_ignore_pat
                                return
                              endif
                              let l = 2
                              while l < 20 && l < line("$") && getline(l) =~ '^\s*\(#\|$\)'
                                " Skip empty and comment lines.
                                let l = l + 1
                              endwhile
                              if l < line("$") && getline(l) =~ '\s*exec\s' && getline(l - 1) =~ '^\s*#.*\\$'
                                " Found an "exec" line after a comment with continuation
                                let n = substitute(getline(l),'\s*exec\s\+\([^ ]*/\)\=', '', '')
                                if n =~ '\<tclsh\|\<wish'
                                  setf tcl
                                  return
                                endif
                              endif
                              exe "setf " . a:name
                            endfunc
                            
                            " tcsh scripts
    1              0.000170 au BufNewFile,BufRead .tcshrc*,*.tcsh,tcsh.tcshrc,tcsh.login	call SetFileTypeShell("tcsh")
                            
                            " csh scripts, but might also be tcsh scripts (on some systems csh is tcsh)
    1              0.000303 au BufNewFile,BufRead .login*,.cshrc*,csh.cshrc,csh.login,csh.logout,*.csh,.alias  call s:CSH()
                            
    1              0.000003 func! s:CSH()
                              if exists("g:filetype_csh")
                                call SetFileTypeShell(g:filetype_csh)
                              elseif &shell =~ "tcsh"
                                call SetFileTypeShell("tcsh")
                              else
                                call SetFileTypeShell("csh")
                              endif
                            endfunc
                            
                            " Z-Shell script
    1              0.000128 au BufNewFile,BufRead .zprofile,*/etc/zprofile,.zfbfmarks  setf zsh
    1              0.000129 au BufNewFile,BufRead .zsh*,.zlog*,.zcompdump*  call s:StarSetf('zsh')
    1              0.000053 au BufNewFile,BufRead *.zsh			setf zsh
                            
                            " Scheme
    1              0.000135 au BufNewFile,BufRead *.scm,*.ss,*.rkt		setf scheme
                            
                            " Screen RC
    1              0.000093 au BufNewFile,BufRead .screenrc,screenrc	setf screen
                            
                            " Simula
    1              0.000052 au BufNewFile,BufRead *.sim			setf simula
                            
                            " SINDA
    1              0.000113 au BufNewFile,BufRead *.sin,*.s85		setf sinda
                            
                            " SiSU
    1              0.000213 au BufNewFile,BufRead *.sst,*.ssm,*.ssi,*.-sst,*._sst setf sisu
    1              0.000153 au BufNewFile,BufRead *.sst.meta,*.-sst.meta,*._sst.meta setf sisu
                            
                            " SKILL
    1              0.000133 au BufNewFile,BufRead *.il,*.ils,*.cdf		setf skill
                            
                            " SLRN
    1              0.000054 au BufNewFile,BufRead .slrnrc			setf slrnrc
    1              0.000051 au BufNewFile,BufRead *.score			setf slrnsc
                            
                            " Smalltalk (and TeX)
    1              0.000050 au BufNewFile,BufRead *.st			setf st
    1              0.000059 au BufNewFile,BufRead *.cls
                            	\ if getline(1) =~ '^%' |
                            	\  setf tex |
                            	\ elseif getline(1)[0] == '#' && getline(1) =~ 'rexx' |
                            	\  setf rexx |
                            	\ else |
                            	\  setf st |
                            	\ endif
                            
                            " Smarty templates
    1              0.000051 au BufNewFile,BufRead *.tpl			setf smarty
                            
                            " SMIL or XML
    1              0.000052 au BufNewFile,BufRead *.smil
                            	\ if getline(1) =~ '<?\s*xml.*?>' |
                            	\   setf xml |
                            	\ else |
                            	\   setf smil |
                            	\ endif
                            
                            " SMIL or SNMP MIB file
    1              0.000053 au BufNewFile,BufRead *.smi
                            	\ if getline(1) =~ '\<smil\>' |
                            	\   setf smil |
                            	\ else |
                            	\   setf mib |
                            	\ endif
                            
                            " SMITH
    1              0.000094 au BufNewFile,BufRead *.smt,*.smith		setf smith
                            
                            " Snobol4 and spitbol
    1              0.000091 au BufNewFile,BufRead *.sno,*.spt		setf snobol4
                            
                            " SNMP MIB files
    1              0.000099 au BufNewFile,BufRead *.mib,*.my		setf mib
                            
                            " Snort Configuration
    1              0.000136 au BufNewFile,BufRead *.hog,snort.conf,vision.conf	setf hog
    1              0.000061 au BufNewFile,BufRead *.rules			call s:FTRules()
                            
    1              0.000008 let s:ft_rules_udev_rules_pattern = '^\s*\cudev_rules\s*=\s*"\([^"]\{-1,}\)/*".*'
    1              0.000003 func! s:FTRules()
                              let path = expand('<amatch>:p')
                              if path =~ '^/\(etc/udev/\%(rules\.d/\)\=.*\.rules\|lib/udev/\%(rules\.d/\)\=.*\.rules\)$'
                                setf udevrules
                                return
                              endif
                              if path =~ '^/etc/ufw/'
                                setf conf  " Better than hog
                                return
                              endif
                              try
                                let config_lines = readfile('/etc/udev/udev.conf')
                              catch /^Vim\%((\a\+)\)\=:E484/
                                setf hog
                                return
                              endtry
                              let dir = expand('<amatch>:p:h')
                              for line in config_lines
                                if line =~ s:ft_rules_udev_rules_pattern
                                  let udev_rules = substitute(line, s:ft_rules_udev_rules_pattern, '\1', "")
                                  if dir == udev_rules
                                    setf udevrules
                                  endif
                                  break
                                endif
                              endfor
                              setf hog
                            endfunc
                            
                            
                            " Spec (Linux RPM)
    1              0.000064 au BufNewFile,BufRead *.spec			setf spec
                            
                            " Speedup (AspenTech plant simulator)
    1              0.000131 au BufNewFile,BufRead *.speedup,*.spdata,*.spd	setf spup
                            
                            " Slice
    1              0.000053 au BufNewFile,BufRead *.ice			setf slice
                            
                            " Spice
    1              0.000091 au BufNewFile,BufRead *.sp,*.spice		setf spice
                            
                            " Spyce
    1              0.000097 au BufNewFile,BufRead *.spy,*.spi		setf spyce
                            
                            " Squid
    1              0.000052 au BufNewFile,BufRead squid.conf		setf squid
                            
                            " SQL for Oracle Designer
    1              0.000223 au BufNewFile,BufRead *.tyb,*.typ,*.tyc,*.pkb,*.pks	setf sql
                            
                            " SQL
    1              0.000055 au BufNewFile,BufRead *.sql			call s:SQL()
                            
    1              0.000003 func! s:SQL()
                              if exists("g:filetype_sql")
                                exe "setf " . g:filetype_sql
                              else
                                setf sql
                              endif
                            endfunc
                            
                            " SQLJ
    1              0.000053 au BufNewFile,BufRead *.sqlj			setf sqlj
                            
                            " SQR
    1              0.000093 au BufNewFile,BufRead *.sqr,*.sqi		setf sqr
                            
                            " OpenSSH configuration
    1              0.000095 au BufNewFile,BufRead ssh_config,*/.ssh/config	setf sshconfig
                            
                            " OpenSSH server configuration
    1              0.000066 au BufNewFile,BufRead sshd_config		setf sshdconfig
                            
                            " Stata
    1              0.000229 au BufNewFile,BufRead *.ado,*.class,*.do,*.imata,*.mata   setf stata
                            
                            " SMCL
    1              0.000137 au BufNewFile,BufRead *.hlp,*.ihlp,*.smcl	setf smcl
                            
                            " Stored Procedures
    1              0.000052 au BufNewFile,BufRead *.stp			setf stp
                            
                            " Standard ML
    1              0.000051 au BufNewFile,BufRead *.sml			setf sml
                            
                            " Sratus VOS command macro
    1              0.000051 au BufNewFile,BufRead *.cm			setf voscm
                            
                            " Sysctl
    1              0.000099 au BufNewFile,BufRead */etc/sysctl.conf,*/etc/sysctl.d/*.conf	setf sysctl
                            
                            " Synopsys Design Constraints
    1              0.000053 au BufNewFile,BufRead *.sdc			setf sdc
                            
                            " Sudoers
    1              0.000096 au BufNewFile,BufRead */etc/sudoers,sudoers.tmp	setf sudoers
                            
                            " SVG (Scalable Vector Graphics)
    1              0.000053 au BufNewFile,BufRead *.svg			setf svg
                            
                            " If the file has an extension of 't' and is in a directory 't' then it is
                            " almost certainly a Perl test file.
                            " If the first line starts with '#' and contains 'perl' it's probably a Perl
                            " file.
                            " (Slow test) If a file contains a 'use' statement then it is almost certainly
                            " a Perl file.
    1              0.000003 func! s:FTperl()
                              if expand("%:e") == 't' && expand("%:p:h:t") == 't'
                                setf perl
                                return 1
                              endif
                              if getline(1)[0] == '#' && getline(1) =~ 'perl'
                                setf perl
                                return 1
                              endif
                              if search('^use\s\s*\k', 'nc', 30)
                                setf perl
                                return 1
                              endif
                              return 0
                            endfunc
                            
                            " Tads (or Nroff or Perl test file)
    1              0.000056 au BufNewFile,BufRead *.t
                            	\ if !s:FTnroff() && !s:FTperl() | setf tads | endif
                            
                            " Tags
    1              0.000052 au BufNewFile,BufRead tags			setf tags
                            
                            " TAK
    1              0.000057 au BufNewFile,BufRead *.tak			setf tak
                            
                            " Task
    1              0.000065 au BufRead,BufNewFile {pending,completed,undo}.data  setf taskdata
    1              0.000057 au BufRead,BufNewFile *.task			setf taskedit
                            
                            " Tcl (JACL too)
    1              0.000236 au BufNewFile,BufRead *.tcl,*.tk,*.itcl,*.itk,*.jacl	setf tcl
                            
                            " TealInfo
    1              0.000053 au BufNewFile,BufRead *.tli			setf tli
                            
                            " Telix Salt
    1              0.000053 au BufNewFile,BufRead *.slt			setf tsalt
                            
                            " Terminfo
    1              0.000052 au BufNewFile,BufRead *.ti			setf terminfo
                            
                            " TeX
    1              0.000232 au BufNewFile,BufRead *.latex,*.sty,*.dtx,*.ltx,*.bbl	setf tex
    1              0.000054 au BufNewFile,BufRead *.tex			call s:FTtex()
                            
                            " Choose context, plaintex, or tex (LaTeX) based on these rules:
                            " 1. Check the first line of the file for "%&<format>".
                            " 2. Check the first 1000 non-comment lines for LaTeX or ConTeXt keywords.
                            " 3. Default to "latex" or to g:tex_flavor, can be set in user's vimrc.
    1              0.000003 func! s:FTtex()
                              let firstline = getline(1)
                              if firstline =~ '^%&\s*\a\+'
                                let format = tolower(matchstr(firstline, '\a\+'))
                                let format = substitute(format, 'pdf', '', '')
                                if format == 'tex'
                                  let format = 'plain'
                                endif
                              else
                                " Default value, may be changed later:
                                let format = exists("g:tex_flavor") ? g:tex_flavor : 'plain'
                                " Save position, go to the top of the file, find first non-comment line.
                                let save_cursor = getpos('.')
                                call cursor(1,1)
                                let firstNC = search('^\s*[^[:space:]%]', 'c', 1000)
                                if firstNC " Check the next thousand lines for a LaTeX or ConTeXt keyword.
                                  let lpat = 'documentclass\>\|usepackage\>\|begin{\|newcommand\>\|renewcommand\>'
                                  let cpat = 'start\a\+\|setup\a\+\|usemodule\|enablemode\|enableregime\|setvariables\|useencoding\|usesymbols\|stelle\a\+\|verwende\a\+\|stel\a\+\|gebruik\a\+\|usa\a\+\|imposta\a\+\|regle\a\+\|utilisemodule\>'
                                  let kwline = search('^\s*\\\%(' . lpat . '\)\|^\s*\\\(' . cpat . '\)',
                            			      \ 'cnp', firstNC + 1000)
                                  if kwline == 1	" lpat matched
                            	let format = 'latex'
                                  elseif kwline == 2	" cpat matched
                            	let format = 'context'
                                  endif		" If neither matched, keep default set above.
                                  " let lline = search('^\s*\\\%(' . lpat . '\)', 'cn', firstNC + 1000)
                                  " let cline = search('^\s*\\\%(' . cpat . '\)', 'cn', firstNC + 1000)
                                  " if cline > 0
                                  "   let format = 'context'
                                  " endif
                                  " if lline > 0 && (cline == 0 || cline > lline)
                                  "   let format = 'tex'
                                  " endif
                                endif " firstNC
                                call setpos('.', save_cursor)
                              endif " firstline =~ '^%&\s*\a\+'
                            
                              " Translation from formats to file types.  TODO:  add AMSTeX, RevTex, others?
                              if format == 'plain'
                                setf plaintex
                              elseif format == 'context'
                                setf context
                              else " probably LaTeX
                                setf tex
                              endif
                              return
                            endfunc
                            
                            " ConTeXt
    1              0.000136 au BufNewFile,BufRead tex/context/*/*.tex,*.mkii,*.mkiv   setf context
                            
                            " Texinfo
    1              0.000141 au BufNewFile,BufRead *.texinfo,*.texi,*.txi	setf texinfo
                            
                            " TeX configuration
    1              0.000065 au BufNewFile,BufRead texmf.cnf			setf texmf
                            
                            " Tidy config
    1              0.000110 au BufNewFile,BufRead .tidyrc,tidyrc		setf tidy
                            
                            " TF mud client
    1              0.000143 au BufNewFile,BufRead *.tf,.tfrc,tfrc		setf tf
                            
                            " TPP - Text Presentation Program
    1              0.000055 au BufNewFile,BufReadPost *.tpp			setf tpp
                            
                            " Treetop
    1              0.000050 au BufRead,BufNewFile *.treetop			setf treetop
                            
                            " Trustees
    1              0.000053 au BufNewFile,BufRead trustees.conf		setf trustees
                            
                            " TSS - Geometry
    1              0.000053 au BufNewFile,BufReadPost *.tssgm		setf tssgm
                            
                            " TSS - Optics
    1              0.000051 au BufNewFile,BufReadPost *.tssop		setf tssop
                            
                            " TSS - Command Line (temporary)
    1              0.000054 au BufNewFile,BufReadPost *.tsscl		setf tsscl
                            
                            " TWIG files
    1              0.000054 au BufNewFile,BufReadPost *.twig		setf twig
                            
                            " Motif UIT/UIL files
    1              0.000100 au BufNewFile,BufRead *.uit,*.uil		setf uil
                            
                            " Udev conf
    1              0.000058 au BufNewFile,BufRead */etc/udev/udev.conf	setf udevconf
                            
                            " Udev permissions
    1              0.000056 au BufNewFile,BufRead */etc/udev/permissions.d/*.permissions setf udevperm
                            "
                            " Udev symlinks config
    1              0.000058 au BufNewFile,BufRead */etc/udev/cdsymlinks.conf	setf sh
                            
                            " UnrealScript
    1              0.000057 au BufNewFile,BufRead *.uc			setf uc
                            
                            " Updatedb
    1              0.000057 au BufNewFile,BufRead */etc/updatedb.conf	setf updatedb
                            
                            " Upstart (init(8)) config files
    1              0.000067 au BufNewFile,BufRead */usr/share/upstart/*.conf	       setf upstart
    1              0.000060 au BufNewFile,BufRead */usr/share/upstart/*.override	       setf upstart
    1              0.000107 au BufNewFile,BufRead */etc/init/*.conf,*/etc/init/*.override  setf upstart
    1              0.000101 au BufNewFile,BufRead */.init/*.conf,*/.init/*.override        setf upstart
    1              0.000059 au BufNewFile,BufRead */.config/upstart/*.conf		       setf upstart
    1              0.000060 au BufNewFile,BufRead */.config/upstart/*.override	       setf upstart
                            
                            " Vera
    1              0.000149 au BufNewFile,BufRead *.vr,*.vri,*.vrh		setf vera
                            
                            " Verilog HDL
    1              0.000053 au BufNewFile,BufRead *.v			setf verilog
                            
                            " Verilog-AMS HDL
    1              0.000100 au BufNewFile,BufRead *.va,*.vams		setf verilogams
                            
                            " VHDL
    1              0.000237 au BufNewFile,BufRead *.hdl,*.vhd,*.vhdl,*.vbe,*.vst  setf vhdl
    1              0.000055 au BufNewFile,BufRead *.vhdl_[0-9]*		call s:StarSetf('vhdl')
                            
                            " Vim script
    1              0.000224 au BufNewFile,BufRead *.vim,*.vba,.exrc,_exrc	setf vim
                            
                            " Viminfo file
    1              0.000101 au BufNewFile,BufRead .viminfo,_viminfo		setf viminfo
                            
                            " Virata Config Script File or Drupal module
    1              0.000146 au BufRead,BufNewFile *.hw,*.module,*.pkg
                            	\ if getline(1) =~ '<?php' |
                            	\   setf php |
                            	\ else |
                            	\   setf virata |
                            	\ endif
                            
                            " Visual Basic (also uses *.bas) or FORM
    1              0.000054 au BufNewFile,BufRead *.frm			call s:FTVB("form")
                            
                            " SaxBasic is close to Visual Basic
    1              0.000055 au BufNewFile,BufRead *.sba			setf vb
                            
                            " Vgrindefs file
    1              0.000058 au BufNewFile,BufRead vgrindefs			setf vgrindefs
                            
                            " VRML V1.0c
    1              0.000055 au BufNewFile,BufRead *.wrl			setf vrml
                            
                            " Webmacro
    1              0.000055 au BufNewFile,BufRead *.wm			setf webmacro
                            
                            " Wget config
    1              0.000101 au BufNewFile,BufRead .wgetrc,wgetrc		setf wget
                            
                            " Website MetaLanguage
    1              0.000055 au BufNewFile,BufRead *.wml			setf wml
                            
                            " Winbatch
    1              0.000054 au BufNewFile,BufRead *.wbt			setf winbatch
                            
                            " WSML
    1              0.000057 au BufNewFile,BufRead *.wsml			setf wsml
                            
                            " WvDial
    1              0.000096 au BufNewFile,BufRead wvdial.conf,.wvdialrc	setf wvdial
                            
                            " CVS RC file
    1              0.000059 au BufNewFile,BufRead .cvsrc			setf cvsrc
                            
                            " CVS commit file
    1              0.000067 au BufNewFile,BufRead cvs\d\+			setf cvs
                            
                            " WEB (*.web is also used for Winbatch: Guess, based on expecting "%" comment
                            " lines in a WEB file).
    1              0.000071 au BufNewFile,BufRead *.web
                            	\ if getline(1)[0].getline(2)[0].getline(3)[0].getline(4)[0].getline(5)[0] =~ "%" |
                            	\   setf web |
                            	\ else |
                            	\   setf winbatch |
                            	\ endif
                            
                            " Windows Scripting Host and Windows Script Component
    1              0.000058 au BufNewFile,BufRead *.ws[fc]			setf wsh
                            
                            " XHTML
    1              0.000100 au BufNewFile,BufRead *.xhtml,*.xht		setf xhtml
                            
                            " X Pixmap (dynamically sets colors, use BufEnter to make it work better)
    1              0.000007 au BufEnter *.xpm
                            	\ if getline(1) =~ "XPM2" |
                            	\   setf xpm2 |
                            	\ else |
                            	\   setf xpm |
                            	\ endif
    1              0.000003 au BufEnter *.xpm2				setf xpm2
                            
                            " XFree86 config
    1              0.000061 au BufNewFile,BufRead XF86Config
                            	\ if getline(1) =~ '\<XConfigurator\>' |
                            	\   let b:xf86conf_xfree86_version = 3 |
                            	\ endif |
                            	\ setf xf86conf
    1              0.000061 au BufNewFile,BufRead */xorg.conf.d/*.conf
                            	\ let b:xf86conf_xfree86_version = 4 |
                            	\ setf xf86conf
                            
                            " Xorg config
    1              0.000103 au BufNewFile,BufRead xorg.conf,xorg.conf-4	let b:xf86conf_xfree86_version = 4 | setf xf86conf
                            
                            " Xinetd conf
    1              0.000059 au BufNewFile,BufRead */etc/xinetd.conf		setf xinetd
                            
                            " XS Perl extension interface language
    1              0.000058 au BufNewFile,BufRead *.xs			setf xs
                            
                            " X resources file
    1              0.000246 au BufNewFile,BufRead .Xdefaults,.Xpdefaults,.Xresources,xdm-config,*.ad setf xdefaults
                            
                            " Xmath
    1              0.000112 au BufNewFile,BufRead *.msc,*.msf		setf xmath
    1              0.000057 au BufNewFile,BufRead *.ms
                            	\ if !s:FTnroff() | setf xmath | endif
                            
                            " XML  specific variants: docbk and xbl
    1              0.000067 au BufNewFile,BufRead *.xml			call s:FTxml()
                            
    1              0.000003 func! s:FTxml()
                              let n = 1
                              while n < 100 && n < line("$")
                                let line = getline(n)
                                " DocBook 4 or DocBook 5.
                                let is_docbook4 = line =~ '<!DOCTYPE.*DocBook'
                                let is_docbook5 = line =~ ' xmlns="http://docbook.org/ns/docbook"'
                                if is_docbook4 || is_docbook5
                                  let b:docbk_type = "xml"
                                  if is_docbook5
                            	let b:docbk_ver = 5
                                  else
                            	let b:docbk_ver = 4
                                  endif
                                  setf docbk
                                  return
                                endif
                                if line =~ 'xmlns:xbl="http://www.mozilla.org/xbl"'
                                  setf xbl
                                  return
                                endif
                                let n += 1
                              endwhile
                              setf xml
                            endfunc
                            
                            " XMI (holding UML models) is also XML
    1              0.000065 au BufNewFile,BufRead *.xmi			setf xml
                            
                            " CSPROJ files are Visual Studio.NET's XML-based project config files
    1              0.000110 au BufNewFile,BufRead *.csproj,*.csproj.user	setf xml
                            
                            " Qt Linguist translation source and Qt User Interface Files are XML
    1              0.000104 au BufNewFile,BufRead *.ts,*.ui			setf xml
                            
                            " TPM's are RDF-based descriptions of TeX packages (Nikolai Weibull)
    1              0.000058 au BufNewFile,BufRead *.tpm			setf xml
                            
                            " Xdg menus
    1              0.000057 au BufNewFile,BufRead */etc/xdg/menus/*.menu	setf xml
                            
                            " ATI graphics driver configuration
    1              0.000056 au BufNewFile,BufRead fglrxrc			setf xml
                            
                            " XLIFF (XML Localisation Interchange File Format) is also XML
    1              0.000060 au BufNewFile,BufRead *.xlf			setf xml
    1              0.000056 au BufNewFile,BufRead *.xliff			setf xml
                            
                            " XML User Interface Language
    1              0.000059 au BufNewFile,BufRead *.xul			setf xml
                            
                            " X11 xmodmap (also see below)
    1              0.000058 au BufNewFile,BufRead *Xmodmap			setf xmodmap
                            
                            " Xquery
    1              0.000246 au BufNewFile,BufRead *.xq,*.xql,*.xqm,*.xquery,*.xqy	setf xquery
                            
                            " XSD
    1              0.000056 au BufNewFile,BufRead *.xsd			setf xsd
                            
                            " Xslt
    1              0.000122 au BufNewFile,BufRead *.xsl,*.xslt		setf xslt
                            
                            " Yacc
    1              0.000061 au BufNewFile,BufRead *.yy			setf yacc
                            
                            " Yacc or racc
    1              0.000058 au BufNewFile,BufRead *.y			call s:FTy()
                            
    1              0.000003 func! s:FTy()
                              let n = 1
                              while n < 100 && n < line("$")
                                let line = getline(n)
                                if line =~ '^\s*%'
                                  setf yacc
                                  return
                                endif
                                if getline(n) =~ '^\s*\(#\|class\>\)' && getline(n) !~ '^\s*#\s*include'
                                  setf racc
                                  return
                                endif
                                let n = n + 1
                              endwhile
                              setf yacc
                            endfunc
                            
                            
                            " Yaml
    1              0.000118 au BufNewFile,BufRead *.yaml,*.yml		setf yaml
                            
                            " yum conf (close enough to dosini)
    1              0.000057 au BufNewFile,BufRead */etc/yum.conf		setf dosini
                            
                            " Zimbu
    1              0.000056 au BufNewFile,BufRead *.zu			setf zimbu
                            
                            " Zope
                            "   dtml (zope dynamic template markup language), pt (zope page template),
                            "   cpt (zope form controller page template)
    1              0.000154 au BufNewFile,BufRead *.dtml,*.pt,*.cpt		call s:FThtml()
                            "   zsql (zope sql method)
    1              0.000056 au BufNewFile,BufRead *.zsql			call s:SQL()
                            
                            " Z80 assembler asz80
    1              0.000058 au BufNewFile,BufRead *.z8a			setf z8a
                            
    1              0.000002 augroup END
                            
                            
                            " Source the user-specified filetype file, for backwards compatibility with
                            " Vim 5.x.
    1              0.000007 if exists("myfiletypefile") && filereadable(expand(myfiletypefile))
                              execute "source " . myfiletypefile
                            endif
                            
                            
                            " Check for "*" after loading myfiletypefile, so that scripts.vim is only used
                            " when there are no matching file name extensions.
                            " Don't do this for compressed files.
    1              0.000002 augroup filetypedetect
    1              0.000060 au BufNewFile,BufRead *
                            	\ if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat
                            	\ | runtime! scripts.vim | endif
    1              0.000006 au StdinReadPost * if !did_filetype() | runtime! scripts.vim | endif
                            
                            
                            " Extra checks for when no filetype has been detected now.  Mostly used for
                            " patterns that end in "*".  E.g., "zsh*" matches "zsh.vim", but that's a Vim
                            " script file.
                            " Most of these should call s:StarSetf() to avoid names ending in .gz and the
                            " like are used.
                            
                            " More Apache config files
    1              0.000323 au BufNewFile,BufRead access.conf*,apache.conf*,apache2.conf*,httpd.conf*,srm.conf*	call s:StarSetf('apache')
    1              0.000263 au BufNewFile,BufRead */etc/apache2/*.conf*,*/etc/apache2/conf.*/*,*/etc/apache2/mods-*/*,*/etc/apache2/sites-*/*,*/etc/httpd/conf.d/*.conf*		call s:StarSetf('apache')
                            
                            " Asterisk config file
    1              0.000063 au BufNewFile,BufRead *asterisk/*.conf*		call s:StarSetf('asterisk')
    1              0.000062 au BufNewFile,BufRead *asterisk*/*voicemail.conf* call s:StarSetf('asteriskvm')
                            
                            " Bazaar version control
    1              0.000060 au BufNewFile,BufRead bzr_log.*			setf bzr
                            
                            " BIND zone
    1              0.000113 au BufNewFile,BufRead */named/db.*,*/bind/db.*	call s:StarSetf('bindzone')
                            
                            " Calendar
    1              0.000166 au BufNewFile,BufRead */.calendar/*,
                            	\*/share/calendar/*/calendar.*,*/share/calendar/calendar.*
                            	\					call s:StarSetf('calendar')
                            
                            " Changelog
    1              0.000066 au BufNewFile,BufRead [cC]hange[lL]og*
                            	\ if getline(1) =~ '; urgency='
                            	\|  call s:StarSetf('debchangelog')
                            	\|else
                            	\|  call s:StarSetf('changelog')
                            	\|endif
                            
                            " Crontab
    1              0.000171 au BufNewFile,BufRead crontab,crontab.*,*/etc/cron.d/*		call s:StarSetf('crontab')
                            
                            " dnsmasq(8) configuration
    1              0.000061 au BufNewFile,BufRead */etc/dnsmasq.d/*		call s:StarSetf('dnsmasq')
                            
                            " Dracula
    1              0.000070 au BufNewFile,BufRead drac.*			call s:StarSetf('dracula')
                            
                            " Fvwm
    1              0.000067 au BufNewFile,BufRead */.fvwm/*			call s:StarSetf('fvwm')
    1              0.000108 au BufNewFile,BufRead *fvwmrc*,*fvwm95*.hook
                            	\ let b:fvwm_version = 1 | call s:StarSetf('fvwm')
    1              0.000059 au BufNewFile,BufRead *fvwm2rc*
                            	\ if expand("<afile>:e") == "m4"
                            	\|  call s:StarSetf('fvwm2m4')
                            	\|else
                            	\|  let b:fvwm_version = 2 | call s:StarSetf('fvwm')
                            	\|endif
                            
                            " Gedcom
    1              0.000060 au BufNewFile,BufRead */tmp/lltmp*		call s:StarSetf('gedcom')
                            
                            " GTK RC
    1              0.000101 au BufNewFile,BufRead .gtkrc*,gtkrc*		call s:StarSetf('gtkrc')
                            
                            " Jam
    1              0.000106 au BufNewFile,BufRead Prl*.*,JAM*.*		call s:StarSetf('jam')
                            
                            " Jargon
    1              0.000060 au! BufNewFile,BufRead *jarg*
                            	\ if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'THIS IS THE JARGON FILE'
                            	\|  call s:StarSetf('jargon')
                            	\|endif
                            
                            " Kconfig
    1              0.000056 au BufNewFile,BufRead Kconfig.*			call s:StarSetf('kconfig')
                            
                            " Lilo: Linux loader
    1              0.000084 au BufNewFile,BufRead lilo.conf*		call s:StarSetf('lilo')
                            
                            " Logcheck
    1              0.000059 au BufNewFile,BufRead */etc/logcheck/*.d*/*	call s:StarSetf('logcheck')
                            
                            " Makefile
    1              0.000057 au BufNewFile,BufRead [mM]akefile*		call s:StarSetf('make')
                            
                            " Ruby Makefile
    1              0.000059 au BufNewFile,BufRead [rR]akefile*		call s:StarSetf('ruby')
                            
                            " Mail (also matches muttrc.vim, so this is below the other checks)
    1              0.000066 au BufNewFile,BufRead mutt[[:alnum:]._-]\\\{6\}	setf mail
                            
                            " Modconf
    1              0.000060 au BufNewFile,BufRead */etc/modutils/*
                            	\ if executable(expand("<afile>")) != 1
                            	\|  call s:StarSetf('modconf')
                            	\|endif
    1              0.000071 au BufNewFile,BufRead */etc/modprobe.*		call s:StarSetf('modconf')
                            
                            " Mutt setup file
    1              0.000120 au BufNewFile,BufRead .mutt{ng,}rc*,*/.mutt{ng,}/mutt{ng,}rc*	call s:StarSetf('muttrc')
    1              0.000107 au BufNewFile,BufRead mutt{ng,}rc*,Mutt{ng,}rc*		call s:StarSetf('muttrc')
                            
                            " Nroff macros
    1              0.000057 au BufNewFile,BufRead tmac.*			call s:StarSetf('nroff')
                            
                            " Pam conf
    1              0.000060 au BufNewFile,BufRead */etc/pam.d/*		call s:StarSetf('pamconf')
                            
                            " Printcap and Termcap
    1              0.000059 au BufNewFile,BufRead *printcap*
                            	\ if !did_filetype()
                            	\|  let b:ptcap_type = "print" | call s:StarSetf('ptcap')
                            	\|endif
    1              0.000058 au BufNewFile,BufRead *termcap*
                            	\ if !did_filetype()
                            	\|  let b:ptcap_type = "term" | call s:StarSetf('ptcap')
                            	\|endif
                            
                            " ReDIF
                            " Only used when the .rdf file was not detected to be XML.
    1              0.000062 au BufRead,BufNewFile *.rdf			call s:Redif()
    1              0.000006 func! s:Redif()
                              let lnum = 1
                              while lnum <= 5 && lnum < line('$')
                                if getline(lnum) =~ "^\ctemplate-type:"
                                  setf redif
                                  return
                                endif
                                let lnum = lnum + 1
                              endwhile
                            endfunc
                            
                            " Remind
    1              0.000059 au BufNewFile,BufRead .reminders*		call s:StarSetf('remind')
                            
                            " Vim script
    1              0.000057 au BufNewFile,BufRead *vimrc*			call s:StarSetf('vim')
                            
                            " Subversion commit file
    1              0.000061 au BufNewFile,BufRead svn-commit*.tmp		setf svn
                            
                            " X resources file
    1              0.000154 au BufNewFile,BufRead Xresources*,*/app-defaults/*,*/Xresources/* call s:StarSetf('xdefaults')
                            
                            " XFree86 config
    1              0.000058 au BufNewFile,BufRead XF86Config-4*
                            	\ let b:xf86conf_xfree86_version = 4 | call s:StarSetf('xf86conf')
    1              0.000063 au BufNewFile,BufRead XF86Config*
                            	\ if getline(1) =~ '\<XConfigurator\>'
                            	\|  let b:xf86conf_xfree86_version = 3
                            	\|endif
                            	\|call s:StarSetf('xf86conf')
                            
                            " X11 xmodmap
    1              0.000067 au BufNewFile,BufRead *xmodmap*			call s:StarSetf('xmodmap')
                            
                            " Xinetd conf
    1              0.000075 au BufNewFile,BufRead */etc/xinetd.d/*		call s:StarSetf('xinetd')
                            
                            " yum conf (close enough to dosini)
    1              0.000078 au BufNewFile,BufRead */etc/yum.repos.d/*	call s:StarSetf('dosini')
                            
                            " Z-Shell script
    1              0.000144 au BufNewFile,BufRead zsh*,zlog*		call s:StarSetf('zsh')
                            
                            
                            " Plain text files, needs to be far down to not override others.  This avoids
                            " the "conf" type being used if there is a line starting with '#'.
    1              0.000119 au BufNewFile,BufRead *.txt,*.text		setf text
                            
                            
                            " Use the filetype detect plugins.  They may overrule any of the previously
                            " detected filetypes.
    1              0.000185 runtime! ftdetect/*.vim
                            
                            " NOTE: The above command could have ended the filetypedetect autocmd group
                            " and started another one. Let's make sure it has ended to get to a consistent
                            " state.
    1              0.000002 augroup END
                            
                            " Generic configuration file (check this last, it's just guessing!)
    1              0.000074 au filetypedetect BufNewFile,BufRead,StdinReadPost *
                            	\ if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat
                            	\    && (getline(1) =~ '^#' || getline(2) =~ '^#' || getline(3) =~ '^#'
                            	\	|| getline(4) =~ '^#' || getline(5) =~ '^#') |
                            	\   setf conf |
                            	\ endif
                            
                            
                            " If the GUI is already running, may still need to install the Syntax menu.
                            " Don't do it when the 'M' flag is included in 'guioptions'.
    1              0.000016 if has("menu") && has("gui_running")
                                  \ && !exists("did_install_syntax_menu") && &guioptions !~# "M"
                              source <sfile>:p:h/menu.vim
                            endif
                            
                            " Function called for testing all functions defined here.  These are
                            " script-local, thus need to be executed here.
                            " Returns a string with error messages (hopefully empty).
    1              0.000002 func! TestFiletypeFuncs(testlist)
                              let output = ''
                              for f in a:testlist
                                try
                                  exe f
                                catch
                                  let output = output . "\n" . f . ": " . v:exception
                                endtry
                              endfor
                              return output
                            endfunc
                            
                            " Restore 'cpoptions'
    1              0.000014 let &cpo = s:cpo_save
    1              0.000005 unlet s:cpo_save

SCRIPT  /Users/admin/.vim/bundle/neosnippet.vim/ftdetect/snippet.vim
Sourced 1 time
Total time:   0.000120
 Self time:   0.000120

count  total (s)   self (s)
                            " Detect syntax file.
    1              0.000118 autocmd BufNewFile,BufRead *.snip,*.snippets set filetype=snippet

SCRIPT  /Users/admin/.vim/bundle/neobundle.vim/ftdetect/vimrecipe.vim
Sourced 1 time
Total time:   0.000074
 Self time:   0.000074

count  total (s)   self (s)
                            " Detect syntax file.
    1              0.000071 autocmd BufNewFile,BufRead *.vimrecipe set filetype=vimrecipe

SCRIPT  /Applications/MacVim.app/Contents/Resources/vim/runtime/ftplugin.vim
Sourced 1 time
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
                            " Vim support file to switch on loading plugins for file types
                            "
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last change:	2006 Apr 30
                            
    1              0.000004 if exists("did_load_ftplugin")
    1              0.000002   finish

SCRIPT  /Applications/MacVim.app/Contents/Resources/vim/runtime/indent.vim
Sourced 1 time
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
                            " Vim support file to switch on loading indent files for file types
                            "
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2008 Feb 22
                            
    1              0.000005 if exists("did_indent_on")
    1              0.000002   finish

SCRIPT  /Applications/MacVim.app/Contents/Resources/vim/runtime/autoload/netrw.vim
Sourced 1 time
Total time:   0.013320
 Self time:   0.011623

count  total (s)   self (s)
                            " netrw.vim: Handles file transfer and remote directory listing across
                            "            AUTOLOAD SECTION
                            " Date:		May 18, 2013
                            " Version:	149
                            " Maintainer:	Charles E Campbell <NdrOchip@ScampbellPfamily.AbizM-NOSPAM>
                            " GetLatestVimScripts: 1075 1 :AutoInstall: netrw.vim
                            " Copyright:    Copyright (C) 1999-2012 Charles E. Campbell {{{1
                            "               Permission is hereby granted to use and distribute this code,
                            "               with or without modifications, provided that this copyright
                            "               notice is copied with it. Like anything else that's free,
                            "               netrw.vim, netrwPlugin.vim, and netrwSettings.vim are provided
                            "               *as is* and come with no warranty of any kind, either
                            "               expressed or implied. By using this plugin, you agree that
                            "               in no event will the copyright holder be liable for any damages
                            "               resulting from the use of this software.
                            "redraw!|call DechoSep()|call inputsave()|call input("Press <cr> to continue")|call inputrestore()
                            "
                            "  But be doers of the Word, and not only hearers, deluding your own selves {{{1
                            "  (James 1:22 RSV)
                            " =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
                            " Load Once: {{{1
    1              0.000010 if &cp || exists("g:loaded_netrw")
                              finish
                            endif
    1              0.000023 let g:loaded_netrw = "v149"
    1              0.000006 if v:version < 703 || (v:version == 703 && !has("patch465"))
                             echohl WarningMsg
                             echo "***warning*** this version of netrw needs vim 7.3.465 or later"
                             echohl Normal
                             finish
                            endif
    1              0.000003 if !exists("s:NOTE")
    1              0.000002  let s:NOTE    = 0
    1              0.000002  let s:WARNING = 1
    1              0.000002  let s:ERROR   = 2
    1              0.000001 endif
                            
    1              0.000006 let s:keepcpo= &cpo
    1              0.000008 set cpo&vim
                            "DechoTabOn
                            "call Decho("doing autoload/netrw.vim version ".g:loaded_netrw)
                            
                            " ======================
                            "  Netrw Variables: {{{1
                            " ======================
                            
                            " ---------------------------------------------------------------------
                            " netrw#ErrorMsg: {{{2
                            "   0=note     = s:NOTE
                            "   1=warning  = s:WARNING
                            "   2=error    = s:ERROR
                            "  May 01, 2013 : max errnum currently is 93
    1              0.000005 fun! netrw#ErrorMsg(level,msg,errnum)
                            "  call Dfunc("netrw#ErrorMsg(level=".a:level." msg<".a:msg."> errnum=".a:errnum.") g:netrw_use_errorwindow=".g:netrw_use_errorwindow)
                            
                              if a:level < g:netrw_errorlvl
                            "   call Dret("netrw#ErrorMsg : suppressing level=".a:level." since g:netrw_errorlvl=".g:netrw_errorlvl)
                               return
                              endif
                            
                              if a:level == 1
                               let level= "**warning** (netrw) "
                              elseif a:level == 2
                               let level= "**error** (netrw) "
                              else
                               let level= "**note** (netrw) "
                              endif
                            "  call Decho("level=".level)
                            
                              if g:netrw_use_errorwindow
                               " (default) netrw creates a one-line window to show error/warning
                               " messages (reliably displayed)
                            
                               " record current window number for NetrwRestorePosn()'s benefit
                               let s:winBeforeErr= winnr()
                            "   call Decho("s:winBeforeErr=".s:winBeforeErr)
                            
                               " getting messages out reliably is just plain difficult!
                               " This attempt splits the current window, creating a one line window.
                               if bufexists("NetrwMessage") && bufwinnr("NetrwMessage") > 0
                            "    call Decho("write to NetrwMessage buffer")
                                exe bufwinnr("NetrwMessage")."wincmd w"
                            "    call Decho("setl ma noro")
                                setl ma noro
                                keepj call setline(line("$")+1,level.a:msg)
                                keepj $
                               else
                            "    call Decho("create a NetrwMessage buffer window")
                                bo 1split
                                sil! call s:NetrwEnew()
                                sil! keepj call s:NetrwSafeOptions()
                                setl bt=nofile
                                keepj file NetrwMessage
                            "    call Decho("setl ma noro")
                                setl ma noro
                                call setline(line("$"),level.a:msg)
                               endif
                            "   call Decho("wrote msg<".level.a:msg."> to NetrwMessage win#".winnr())
                               if &fo !~ '[ta]'
                                syn clear
                                syn match netrwMesgNote	"^\*\*note\*\*"
                                syn match netrwMesgWarning	"^\*\*warning\*\*"
                                syn match netrwMesgError	"^\*\*error\*\*"
                                hi link netrwMesgWarning WarningMsg
                                hi link netrwMesgError   Error
                               endif
                            "   call Decho("(ErrorMsg) setl noma ro bh=wipe")
                               setl noma ro bh=wipe
                            
                              else
                               " (optional) netrw will show messages using echomsg.  Even if the
                               " message doesn't appear, at least it'll be recallable via :messages
                            "   redraw!
                               if a:level == s:WARNING
                                echohl WarningMsg
                               elseif a:level == s:ERROR
                                echohl Error
                               endif
                               echomsg level.a:msg
                            "   call Decho("echomsg ***netrw*** ".a:msg)
                               echohl None
                              endif
                            
                            "  call Dret("netrw#ErrorMsg")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " NetrwInit: initializes variables if they haven't been defined {{{2
                            "            Loosely,  varname = value.
    1              0.000004 fun s:NetrwInit(varname,value)
                            " call Decho("varname<".a:varname."> value=".a:value)
                              if !exists(a:varname)
                               if type(a:value) == 0
                                exe "let ".a:varname."=".a:value
                               elseif type(a:value) == 1 && a:value =~ '^[{[]'
                                exe "let ".a:varname."=".a:value
                               elseif type(a:value) == 1
                                exe "let ".a:varname."="."'".a:value."'"
                               else
                                exe "let ".a:varname."=".a:value
                               endif
                              endif
                            endfun
                            
                            " ---------------------------------------------------------------------
                            "  Netrw Constants: {{{2
    1   0.000046   0.000011 call s:NetrwInit("g:netrw_dirhist_cnt",0)
    1              0.000004 if !exists("s:LONGLIST")
    1   0.000028   0.000006  call s:NetrwInit("s:THINLIST",0)
    1   0.000026   0.000005  call s:NetrwInit("s:LONGLIST",1)
    1   0.000024   0.000004  call s:NetrwInit("s:WIDELIST",2)
    1   0.000025   0.000005  call s:NetrwInit("s:TREELIST",3)
    1   0.000025   0.000005  call s:NetrwInit("s:MAXLIST" ,4)
    1              0.000001 endif
                            
                            " ---------------------------------------------------------------------
                            " Default values for netrw's global protocol variables {{{2
    1   0.000033   0.000005 call s:NetrwInit("g:netrw_use_errorwindow",1)
                            
    1              0.000003 if !exists("g:netrw_dav_cmd")
    1              0.000020  if executable("cadaver")
                              let g:netrw_dav_cmd	= "cadaver"
                             elseif executable("curl")
    1              0.000003   let g:netrw_dav_cmd	= "curl"
    1              0.000002  else
                              let g:netrw_dav_cmd   = ""
                             endif
    1              0.000001 endif
    1              0.000003 if !exists("g:netrw_fetch_cmd")
    1              0.000011  if executable("fetch")
                              let g:netrw_fetch_cmd	= "fetch -o"
                             else
    1              0.000002   let g:netrw_fetch_cmd	= ""
    1              0.000001  endif
    1              0.000001 endif
    1              0.000003 if !exists("g:netrw_ftp_cmd")
    1              0.000002   let g:netrw_ftp_cmd	= "ftp"
    1              0.000000 endif
    1              0.000002 let s:netrw_ftp_cmd= g:netrw_ftp_cmd
    1              0.000003 if !exists("g:netrw_ftp_options")
    1              0.000002  let g:netrw_ftp_options= "-i -n"
    1              0.000000 endif
    1              0.000003 if !exists("g:netrw_http_cmd")
    1              0.000011  if executable("elinks")
                              let g:netrw_http_cmd = "elinks"
                              call s:NetrwInit("g:netrw_http_xcmd","-source >")
                             elseif executable("links")
                              let g:netrw_http_cmd = "links"
                              call s:NetrwInit("g:netrw_http_xcmd","-source >")
                             elseif executable("curl")
    1              0.000003   let g:netrw_http_cmd	= "curl"
    1   0.000038   0.000006   call s:NetrwInit("g:netrw_http_xcmd","-o")
    1              0.000002  elseif executable("wget")
                              let g:netrw_http_cmd	= "wget"
                              call s:NetrwInit("g:netrw_http_xcmd","-q -O")
                             elseif executable("fetch")
                              let g:netrw_http_cmd	= "fetch"
                              call s:NetrwInit("g:netrw_http_xcmd","-o")
                             else
                              let g:netrw_http_cmd	= ""
                             endif
    1              0.000001 endif
    1   0.000033   0.000005 call s:NetrwInit("g:netrw_rcp_cmd"  , "rcp")
    1   0.000032   0.000005 call s:NetrwInit("g:netrw_rsync_cmd", "rsync")
    1              0.000003 if !exists("g:netrw_scp_cmd")
    1              0.000077  if executable("scp")
    1   0.000037   0.000008   call s:NetrwInit("g:netrw_scp_cmd" , "scp -q")
    1              0.000002  elseif executable("pscp")
                              if (has("win32") || has("win95") || has("win64") || has("win16")) && filereadable('c:\private.ppk')
                               call s:NetrwInit("g:netrw_scp_cmd", 'pscp -i c:\private.ppk')
                              else
                               call s:NetrwInit("g:netrw_scp_cmd", 'pscp -q')
                              endif
                             else
                              call s:NetrwInit("g:netrw_scp_cmd" , "scp -q")
                             endif
    1              0.000000 endif
                            
    1   0.000032   0.000005 call s:NetrwInit("g:netrw_sftp_cmd" , "sftp")
    1   0.000032   0.000005 call s:NetrwInit("g:netrw_ssh_cmd"  , "ssh")
                            
    1              0.000017 if (has("win32") || has("win95") || has("win64") || has("win16"))
                              \ && exists("g:netrw_use_nt_rcp")
                              \ && g:netrw_use_nt_rcp
                              \ && executable( $SystemRoot .'/system32/rcp.exe')
                             let s:netrw_has_nt_rcp = 1
                             let s:netrw_rcpmode    = '-b'
                            else
    1              0.000002  let s:netrw_has_nt_rcp = 0
    1              0.000003  let s:netrw_rcpmode    = ''
    1              0.000001 endif
                            
                            " ---------------------------------------------------------------------
                            " Default values for netrw's global variables {{{2
                            " Cygwin Detection ------- {{{3
    1              0.000003 if !exists("g:netrw_cygwin")
    1              0.000012  if has("win32") || has("win95") || has("win64") || has("win16")
                              if  has("win32unix") && &shell =~ '\%(\<bash\>\|\<zsh\>\)\%(\.exe\)\=$'
                               let g:netrw_cygwin= 1
                              else
                               let g:netrw_cygwin= 0
                              endif
                             else
    1              0.000002   let g:netrw_cygwin= 0
    1              0.000001  endif
    1              0.000001 endif
                            " Default values - a-c ---------- {{{3
    1   0.000029   0.000007 call s:NetrwInit("g:netrw_alto"        , &sb)
    1   0.000027   0.000007 call s:NetrwInit("g:netrw_altv"        , &spr)
    1   0.000024   0.000004 call s:NetrwInit("g:netrw_banner"      , 1)
    1   0.000025   0.000004 call s:NetrwInit("g:netrw_browse_split", 0)
    1   0.000033   0.000005 call s:NetrwInit("g:netrw_bufsettings" , "noma nomod nonu nobl nowrap ro")
    1   0.000032   0.000011 call s:NetrwInit("g:netrw_chgwin"      , -1)
    1   0.000032   0.000005 call s:NetrwInit("g:netrw_compress"    , "gzip")
    1   0.000031   0.000005 call s:NetrwInit("g:netrw_ctags"       , "ctags")
    1              0.000004 if exists("g:netrw_cursorline") && !exists("g:netrw_cursor")
                             call netrw#ErrorMsg(s:NOTE,'g:netrw_cursorline is deprecated; use g:netrw_cursor instead',77)
                             let g:netrw_cursor= g:netrw_cursorline
                            endif
    1   0.000025   0.000004 call s:NetrwInit("g:netrw_cursor"      , 2)
    1              0.000004 let s:netrw_usercul = &cursorline
    1              0.000003 let s:netrw_usercuc = &cursorcolumn
                            " Default values - d-g ---------- {{{3
    1   0.000025   0.000004 call s:NetrwInit("s:didstarstar",0)
    1   0.000020   0.000005 call s:NetrwInit("g:netrw_dirhist_cnt"      , 0)
    1   0.000037   0.000007 call s:NetrwInit("g:netrw_decompress"       , '{ ".gz" : "gunzip", ".bz2" : "bunzip2", ".zip" : "unzip", ".tar" : "tar -xf", ".xz" : "unxz" }')
    1   0.000037   0.000006 call s:NetrwInit("g:netrw_dirhistmax"       , 10)
    1   0.000026   0.000006 call s:NetrwInit("g:netrw_errorlvl"  , s:NOTE)
    1   0.000025   0.000004 call s:NetrwInit("g:netrw_fastbrowse"       , 1)
    1   0.000039   0.000008 call s:NetrwInit("g:netrw_ftp_browse_reject", '^total\s\+\d\+$\|^Trying\s\+\d\+.*$\|^KERBEROS_V\d rejected\|^Security extensions not\|No such file\|: connect to address [0-9a-fA-F:]*: No route to host$')
    1              0.000003 if !exists("g:netrw_ftp_list_cmd")
    1              0.000003  if has("unix") || (exists("g:netrw_cygwin") && g:netrw_cygwin)
    1              0.000003   let g:netrw_ftp_list_cmd     = "ls -lF"
    1              0.000003   let g:netrw_ftp_timelist_cmd = "ls -tlF"
    1              0.000002   let g:netrw_ftp_sizelist_cmd = "ls -slF"
    1              0.000001  else
                              let g:netrw_ftp_list_cmd     = "dir"
                              let g:netrw_ftp_timelist_cmd = "dir"
                              let g:netrw_ftp_sizelist_cmd = "dir"
                             endif
    1              0.000001 endif
    1   0.000032   0.000005 call s:NetrwInit("g:netrw_ftpmode",'binary')
                            " Default values - h-lh ---------- {{{3
    1   0.000025   0.000004 call s:NetrwInit("g:netrw_hide",1)
    1              0.000003 if !exists("g:netrw_ignorenetrc")
    1              0.000010  if &shell =~ '\c\<\%(cmd\|4nt\)\.exe$'
                              let g:netrw_ignorenetrc= 1
                             else
    1              0.000002   let g:netrw_ignorenetrc= 0
    1              0.000001  endif
    1              0.000001 endif
    1   0.000029   0.000004 call s:NetrwInit("g:netrw_keepdir",1)
    1              0.000004 if !exists("g:netrw_list_cmd")
                            
    1              0.000006  if g:netrw_scp_cmd =~ '^pscp' && executable("pscp")
                              if (has("win32") || has("win95") || has("win64") || has("win16")) && filereadable("c:\\private.ppk")
                               " provide a pscp-based listing command
                               let g:netrw_scp_cmd ="pscp -i C:\\private.ppk"
                              endif
                              let g:netrw_list_cmd= g:netrw_scp_cmd." -ls USEPORT HOSTNAME:"
                            
                             elseif executable(g:netrw_ssh_cmd)
                              " provide a scp-based default listing command
    1              0.000004   let g:netrw_list_cmd= g:netrw_ssh_cmd." USEPORT HOSTNAME ls -FLa"
                            
    1              0.000001  else
                            "  call Decho(g:netrw_ssh_cmd." is not executable")
                              let g:netrw_list_cmd= ""
                             endif
                            
    1              0.000001 endif
    1   0.000035   0.000006 call s:NetrwInit("g:netrw_list_hide","")
                            " Default values - lh-lz ---------- {{{3
    1              0.000003 if exists("g:netrw_local_copycmd")
                             let g:netrw_localcopycmd= g:netrw_local_copycmd
                             call netrw#ErrorMsg(s:NOTE,"g:netrw_local_copycmd is deprecated in favor of g:netrw_localcopycmd",84)
                            endif
    1              0.000003 if !exists("g:netrw_localcmdshell")
    1              0.000003  let g:netrw_localcmdshell= ""
    1              0.000001 endif
    1              0.000003 if !exists("g:netrw_localcopycmd")
    1              0.000012  if has("win32") || has("win95") || has("win64") || has("win16")
                              if g:netrw_cygwin
                               let g:netrw_localcopycmd= "cp"
                              else
                               let g:netrw_localcopycmd= "cmd /c copy"
                              endif
                             elseif has("unix") || has("macunix")
    1              0.000002   let g:netrw_localcopycmd= "cp"
    1              0.000001  else
                              let g:netrw_localcopycmd= ""
                             endif
    1              0.000001 endif
    1              0.000003 if exists("g:netrw_local_mkdir")
                             let g:netrw_localmkdir= g:netrw_local_mkdir
                             call netrw#ErrorMsg(s:NOTE,"g:netrw_local_mkdir is deprecated in favor of g:netrw_localmkdir",87)
                            endif
    1   0.000033   0.000005 call s:NetrwInit("g:netrw_localmkdir","mkdir")
    1   0.000031   0.000005 call s:NetrwInit("g:netrw_remote_mkdir","mkdir")
    1              0.000004 if exists("g:netrw_local_movecmd")
                             let g:netrw_localmovecmd= g:netrw_local_movecmd
                             call netrw#ErrorMsg(s:NOTE,"g:netrw_local_movecmd is deprecated in favor of g:netrw_localmovecmd",88)
                            endif
    1              0.000003 if !exists("g:netrw_localmovecmd")
    1              0.000011  if has("win32") || has("win95") || has("win64") || has("win16")
                              if g:netrw_cygwin
                               let g:netrw_localmovecmd= "mv"
                              else
                               let g:netrw_localmovecmd= "cmd /c move"
                              endif
                             elseif has("unix") || has("macunix")
    1              0.000002   let g:netrw_localmovecmd= "mv"
    1              0.000001  else
                              let g:netrw_localmovecmd= ""
                             endif
    1              0.000001 endif
    1   0.000031   0.000005 call s:NetrwInit("g:netrw_localrmdir", "rmdir")
    1              0.000003 if exists("g:netrw_local_rmdir")
                             let g:netrw_localrmdir= g:netrw_local_rmdir
                             call netrw#ErrorMsg(s:NOTE,"g:netrw_local_rmdir is deprecated in favor of g:netrw_localrmdir",86)
                            endif
    1   0.000026   0.000005 call s:NetrwInit("g:netrw_liststyle"  , s:THINLIST)
                            " sanity checks
    1              0.000003 if g:netrw_liststyle < 0 || g:netrw_liststyle >= s:MAXLIST
                             let g:netrw_liststyle= s:THINLIST
                            endif
    1              0.000002 if g:netrw_liststyle == s:LONGLIST && g:netrw_scp_cmd !~ '^pscp'
                             let g:netrw_list_cmd= g:netrw_list_cmd." -l"
                            endif
                            " Default values - m-r ---------- {{{3
    1   0.000032   0.000005 call s:NetrwInit("g:netrw_markfileesc"   , '*./[\~')
    1   0.000027   0.000005 call s:NetrwInit("g:netrw_maxfilenamelen", 32)
    1   0.000025   0.000004 call s:NetrwInit("g:netrw_menu"          , 1)
    1   0.000033   0.000006 call s:NetrwInit("g:netrw_mkdir_cmd"     , g:netrw_ssh_cmd." USEPORT HOSTNAME mkdir")
    1   0.000033   0.000012 call s:NetrwInit("g:netrw_mousemaps"     , (exists("+mouse") && &mouse =~ '[anh]'))
    1   0.000025   0.000005 call s:NetrwInit("g:netrw_retmap"        , 0)
    1              0.000004 if has("unix") || (exists("g:netrw_cygwin") && g:netrw_cygwin)
    1   0.000040   0.000013  call s:NetrwInit("g:netrw_chgperm"       , "chmod PERM FILENAME")
    1              0.000003 elseif has("win32") || has("win95") || has("win64") || has("win16")
                             call s:NetrwInit("g:netrw_chgperm"       , "cacls FILENAME /e /p PERM")
                            else
                             call s:NetrwInit("g:netrw_chgperm"       , "chmod PERM FILENAME")
                            endif
    1   0.000025   0.000004 call s:NetrwInit("g:netrw_preview"       , 0)
    1   0.000031   0.000004 call s:NetrwInit("g:netrw_scpport"       , "-P")
    1   0.000031   0.000004 call s:NetrwInit("g:netrw_sshport"       , "-p")
    1   0.000034   0.000006 call s:NetrwInit("g:netrw_rename_cmd"    , g:netrw_ssh_cmd." USEPORT HOSTNAME mv")
    1   0.000032   0.000006 call s:NetrwInit("g:netrw_rm_cmd"        , g:netrw_ssh_cmd." USEPORT HOSTNAME rm")
    1   0.000038   0.000006 call s:NetrwInit("g:netrw_rmdir_cmd"     , g:netrw_ssh_cmd." USEPORT HOSTNAME rmdir")
    1   0.000033   0.000007 call s:NetrwInit("g:netrw_rmf_cmd"       , g:netrw_ssh_cmd." USEPORT HOSTNAME rm -f")
                            " Default values - s ---------- {{{3
                            " g:netrw_sepchr: picking a character that doesn't appear in filenames that can be used to separate priority from filename
    1   0.000037   0.000009 call s:NetrwInit("g:netrw_sepchr"        , (&enc == "euc-jp")? "\<Char-0x01>" : "\<Char-0xff>")
    1   0.000034   0.000007 call s:NetrwInit("s:netrw_silentxfer"    , (exists("g:netrw_silent") && g:netrw_silent != 0)? "sil keepj " : "keepj ")
    1   0.000031   0.000004 call s:NetrwInit("g:netrw_sort_by"       , "name") " alternatives: date                                      , size
    1   0.000031   0.000005 call s:NetrwInit("g:netrw_sort_options"  , "")
    1   0.000032   0.000005 call s:NetrwInit("g:netrw_sort_direction", "normal") " alternative: reverse  (z y x ...)
    1              0.000003 if !exists("g:netrw_sort_sequence")
    1              0.000003  if has("unix")
    1              0.000004   let g:netrw_sort_sequence= '[\/]$,\<core\%(\.\d\+\)\=\>,\.h$,\.c$,\.cpp$,\~\=\*$,*,\.o$,\.obj$,\.info$,\.swp$,\.bak$,\~$'
    1              0.000002  else
                              let g:netrw_sort_sequence= '[\/]$,\.h$,\.c$,\.cpp$,*,\.o$,\.obj$,\.info$,\.swp$,\.bak$,\~$'
                             endif
    1              0.000001 endif
    1   0.000026   0.000005 call s:NetrwInit("g:netrw_special_syntax"   , 0)
    1   0.000033   0.000005 call s:NetrwInit("g:netrw_ssh_browse_reject", '^total\s\+\d\+$')
    1   0.000025   0.000005 call s:NetrwInit("g:netrw_use_noswf"        , 0)
                            " Default values - t-w ---------- {{{3
    1   0.000031   0.000005 call s:NetrwInit("g:netrw_timefmt","%c")
    1              0.000003 if !exists("g:netrw_xstrlen")
    1              0.000003  if exists("g:Align_xstrlen")
                              let g:netrw_xstrlen= g:Align_xstrlen
                             elseif exists("g:drawit_xstrlen")
                              let g:netrw_xstrlen= g:drawit_xstrlen
                             elseif &enc == "latin1" || !has("multi_byte")
                              let g:netrw_xstrlen= 0
                             else
    1              0.000002   let g:netrw_xstrlen= 1
    1              0.000001  endif
    1              0.000000 endif
    1   0.000031   0.000004 call s:NetrwInit("g:NetrwTopLvlMenu","Netrw.")
    1   0.000025   0.000005 call s:NetrwInit("g:netrw_win95ftp",1)
    1   0.000025   0.000004 call s:NetrwInit("g:netrw_winsize",50)
    1              0.000003 if g:netrw_winsize ==  0|let g:netrw_winsize=  -1|endif
    1              0.000003 if g:netrw_winsize > 100|let g:netrw_winsize= 100|endif
                            " ---------------------------------------------------------------------
                            " Default values for netrw's script variables: {{{2
    1   0.000031   0.000004 call s:NetrwInit("g:netrw_fname_escape",' ?&;%')
    1              0.000012 if has("win32") || has("win95") || has("win64") || has("win16")
                             call s:NetrwInit("g:netrw_glob_escape",'*?`{[]$')
                            else
    1   0.000031   0.000005  call s:NetrwInit("g:netrw_glob_escape",'*[]?`{~$\')
    1              0.000002 endif
    1   0.000030   0.000004 call s:NetrwInit("g:netrw_menu_escape",'.&? \')
    1   0.000032   0.000005 call s:NetrwInit("g:netrw_tmpfile_escape",' &;')
    1   0.000033   0.000006 call s:NetrwInit("s:netrw_map_escape","<|\n\r\\\<C-V>\"")
                            
                            " BufEnter event ignored by decho when following variable is true
                            "  Has a side effect that doau BufReadPost doesn't work, so
                            "  files read by network transfer aren't appropriately highlighted.
                            "let g:decho_bufenter = 1	"Decho
                            
                            " ======================
                            "  Netrw Initialization: {{{1
                            " ======================
    1              0.000015 if v:version >= 700 && has("balloon_eval") && !exists("s:initbeval") && !exists("g:netrw_nobeval") && has("syntax") && exists("g:syntax_on")
    1              0.000005  let s:initbeval = &beval
                            " let s:initbexpr = &l:bexpr
    1              0.000006  let &l:bexpr    = "netrw#NetrwBalloonHelp()"
    1              0.000063  set beval
    1              0.000019  au BufWinEnter,WinEnter *	if &ft == "netrw"|set beval|else|let &beval= s:initbeval|endif
    1              0.000001 endif
    1              0.000004 au WinEnter *	if &ft == "netrw"|call s:NetrwInsureWinVars()|endif
                            
                            " ==============================
                            "  Netrw Utility Functions: {{{1
                            " ==============================
                            
                            " ---------------------------------------------------------------------
                            " netrw#NetrwBalloonHelp: {{{2
    1              0.000011 if v:version >= 700 && has("balloon_eval") && &beval == 1 && has("syntax") && exists("g:syntax_on")
    1              0.000005   fun! netrw#NetrwBalloonHelp()
                                if !exists("w:netrw_bannercnt") || v:beval_lnum >= w:netrw_bannercnt || (exists("g:netrw_nobeval") && g:netrw_nobeval)
                                 let mesg= ""
                                elseif     v:beval_text == "Netrw" || v:beval_text == "Directory" || v:beval_text == "Listing"
                                 let mesg = "i: thin-long-wide-tree  gh: quick hide/unhide of dot-files   qf: quick file info  %:open new file"
                                elseif     getline(v:beval_lnum) =~ '^"\s*/'
                                 let mesg = "<cr>: edit/enter   o: edit/enter in horiz window   t: edit/enter in new tab   v:edit/enter in vert window"
                                elseif     v:beval_text == "Sorted" || v:beval_text == "by"
                                 let mesg = 's: sort by name, time, or file size   r: reverse sorting order   mt: mark target'
                                elseif v:beval_text == "Sort"   || v:beval_text == "sequence"
                                 let mesg = "S: edit sorting sequence"
                                elseif v:beval_text == "Hiding" || v:beval_text == "Showing"
                                 let mesg = "a: hiding-showing-all   ctrl-h: editing hiding list   mh: hide/show by suffix"
                                elseif v:beval_text == "Quick" || v:beval_text == "Help"
                                 let mesg = "Help: press <F1>"
                                elseif v:beval_text == "Copy/Move" || v:beval_text == "Tgt"
                                 let mesg = "mt: mark target   mc: copy marked file to target   mm: move marked file to target"
                                else
                                 let mesg= ""
                                endif
                                return mesg
                              endfun
    1              0.000001 endif
                            
                            " ------------------------------------------------------------------------
                            " s:NetrwOptionSave: save options prior to setting to "netrw-buffer-standard" form {{{2
                            "  06/08/07 : removed call to NetrwSafeOptions(), either placed
                            "             immediately after NetrwOptionSave() calls in NetRead
                            "             and NetWrite, or after the s:NetrwEnew() call in
                            "             NetrwBrowse.
                            "             vt: normally its "w:" or "s:" (a variable type)
    1              0.000003 fun! s:NetrwOptionSave(vt)
                            "  call Dfunc("s:NetrwOptionSave(vt<".a:vt.">) win#".winnr()." buf#".bufnr("%")."<".bufname(bufnr("%")).">"." winnr($)=".winnr("$")." mod=".&mod." ma=".&ma)
                            "  call Decho(a:vt."netrw_optionsave".(exists("{a:vt}netrw_optionsave")? ("=".{a:vt}netrw_optionsave) : " doesn't exist"))
                            
                              if !exists("{a:vt}netrw_optionsave")
                               let {a:vt}netrw_optionsave= 1
                              else
                            "   call Dret("s:NetrwOptionSave : options already saved")
                               return
                              endif
                            "  call Decho("fo=".&fo.(exists("+acd")? " acd=".&acd : " acd doesn't exist")." diff=".&l:diff)
                            
                              " Save current settings and current directory
                            "  call Decho("saving current settings and current directory")
                              let s:yykeep          = @@
                              if exists("&l:acd")|let {a:vt}netrw_acdkeep  = &l:acd|endif
                              let {a:vt}netrw_aikeep    = &l:ai
                              let {a:vt}netrw_awkeep    = &l:aw
                              let {a:vt}netrw_bhkeep    = &l:bh
                              let {a:vt}netrw_blkeep    = &l:bl
                              let {a:vt}netrw_btkeep    = &l:bt
                              let {a:vt}netrw_bombkeep  = &l:bomb
                              let {a:vt}netrw_cedit     = &cedit
                              let {a:vt}netrw_cikeep    = &l:ci
                              let {a:vt}netrw_cinkeep   = &l:cin
                              let {a:vt}netrw_cinokeep  = &l:cino
                              let {a:vt}netrw_comkeep   = &l:com
                              let {a:vt}netrw_cpokeep   = &l:cpo
                              let {a:vt}netrw_diffkeep  = &l:diff
                              let {a:vt}netrw_fenkeep   = &l:fen
                              let {a:vt}netrw_ffkeep    = &l:ff
                              let {a:vt}netrw_fokeep    = &l:fo           " formatoptions
                              let {a:vt}netrw_gdkeep    = &l:gd           " gdefault
                              let {a:vt}netrw_hidkeep   = &l:hidden
                              let {a:vt}netrw_imkeep    = &l:im
                              let {a:vt}netrw_iskkeep   = &l:isk
                              let {a:vt}netrw_lskeep    = &l:ls
                              let {a:vt}netrw_makeep    = &l:ma
                              let {a:vt}netrw_magickeep = &l:magic
                              let {a:vt}netrw_modkeep   = &l:mod
                              let {a:vt}netrw_nukeep    = &l:nu
                              let {a:vt}netrw_repkeep   = &l:report
                              let {a:vt}netrw_rokeep    = &l:ro
                              let {a:vt}netrw_selkeep   = &l:sel
                              let {a:vt}netrw_spellkeep = &l:spell
                              let {a:vt}netrw_tskeep    = &l:ts
                              let {a:vt}netrw_twkeep    = &l:tw           " textwidth
                              let {a:vt}netrw_wigkeep   = &l:wig          " wildignore
                              let {a:vt}netrw_wrapkeep  = &l:wrap
                              let {a:vt}netrw_writekeep = &l:write
                              if g:netrw_use_noswf && has("win32") && !has("win95")
                               let {a:vt}netrw_swfkeep   = &l:swf
                              endif
                            
                              " save a few selected netrw-related variables
                            "  call Decho("saving a few selected netrw-related variables")
                              if g:netrw_keepdir
                               let {a:vt}netrw_dirkeep  = getcwd()
                              endif
                              if has("win32") && !has("win95")
                               let {a:vt}netrw_swfkeep  = &l:swf          " swapfile
                              endif
                              if &go =~# 'a' | sil! let {a:vt}netrw_regstar = @* | endif
                              sil! let {a:vt}netrw_regslash= @/
                            
                            "  call Dret("s:NetrwOptionSave : tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")." modified=".&modified." modifiable=".&modifiable." readonly=".&readonly)
                            endfun
                            
                            " ------------------------------------------------------------------------
                            " s:NetrwOptionRestore: restore options {{{2
    1              0.000003 fun! s:NetrwOptionRestore(vt)
                            "  call Dfunc("s:NetrwOptionRestore(vt<".a:vt.">) win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> winnr($)=".winnr("$"))
                              if !exists("{a:vt}netrw_optionsave")
                               if exists("s:nbcd_curpos_{bufnr('%')}")
                            "    call Decho("(NetrwOptionRestore) restoring previous position  (s:nbcd_curpos_".bufnr('%')." exists)")
                                keepj call netrw#NetrwRestorePosn(s:nbcd_curpos_{bufnr('%')})
                            "    call Decho("(NetrwOptionRestore) win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> winnr($)=".winnr("$"))
                            "    call Decho("(NetrwOptionRestore) unlet s:nbcd_curpos_".bufnr('%'))
                                unlet s:nbcd_curpos_{bufnr('%')}
                               else
                            "    call Decho("(NetrwOptionRestore) no previous position")
                               endif
                            "   call Decho("(NetrwOptionRestore) ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
                            "   call Dret("s:NetrwOptionRestore : ".a:vt."netrw_optionsave doesn't exist")
                               return
                              endif
                              unlet {a:vt}netrw_optionsave
                            
                              if exists("+acd")
                               if exists("{a:vt}netrw_acdkeep")
                            "    call Decho("(NetrwOptionRestore) g:netrw_keepdir=".g:netrw_keepdir.": getcwd<".getcwd()."> acd=".&acd)
                                let curdir = getcwd()
                                let &l:acd = {a:vt}netrw_acdkeep
                                unlet {a:vt}netrw_acdkeep
                                if &l:acd
                            "     call Decho("exe keepj lcd ".fnameescape(curdir))  " NOTE: was g:netrw_fname_escape for some reason
                                 try
                                  if !exists("&l:acd") && !&l:acd
                                   exe 'keepj lcd '.fnameescape(curdir)
                                  endif
                                 catch /^Vim\%((\a\+)\)\=:E472/
                                  call netrw#ErrorMsg(s:ERROR,"unable to change directory to <".curdir."> (permissions?)",61)
                                 endtry
                                endif
                               endif
                              endif
                              if exists("{a:vt}netrw_aikeep")   |let &l:ai     = {a:vt}netrw_aikeep      |unlet {a:vt}netrw_aikeep   |endif
                              if exists("{a:vt}netrw_awkeep")   |let &l:aw     = {a:vt}netrw_awkeep      |unlet {a:vt}netrw_awkeep   |endif
                              if g:netrw_liststyle != s:TREELIST
                               if exists("{a:vt}netrw_bhkeep")  |let &l:bh     = {a:vt}netrw_bhkeep      |unlet {a:vt}netrw_bhkeep   |endif
                              endif
                              if exists("{a:vt}netrw_blkeep")   |let &l:bl     = {a:vt}netrw_blkeep      |unlet {a:vt}netrw_blkeep   |endif
                              if exists("{a:vt}netrw_btkeep")   |let &l:bt     = {a:vt}netrw_btkeep      |unlet {a:vt}netrw_btkeep   |endif
                              if exists("{a:vt}netrw_bombkeep") |let &l:bomb   = {a:vt}netrw_bombkeep    |unlet {a:vt}netrw_bombkeep |endif
                              if exists("{a:vt}netrw_cedit")    |let &cedit    = {a:vt}netrw_cedit       |unlet {a:vt}netrw_cedit    |endif
                              if exists("{a:vt}netrw_cikeep")   |let &l:ci     = {a:vt}netrw_cikeep      |unlet {a:vt}netrw_cikeep   |endif
                              if exists("{a:vt}netrw_cinkeep")  |let &l:cin    = {a:vt}netrw_cinkeep     |unlet {a:vt}netrw_cinkeep  |endif
                              if exists("{a:vt}netrw_cinokeep") |let &l:cino   = {a:vt}netrw_cinokeep    |unlet {a:vt}netrw_cinokeep |endif
                              if exists("{a:vt}netrw_comkeep")  |let &l:com    = {a:vt}netrw_comkeep     |unlet {a:vt}netrw_comkeep  |endif
                              if exists("{a:vt}netrw_cpokeep")  |let &l:cpo    = {a:vt}netrw_cpokeep     |unlet {a:vt}netrw_cpokeep  |endif
                              if exists("{a:vt}netrw_diffkeep") |let &l:diff   = {a:vt}netrw_diffkeep    |unlet {a:vt}netrw_diffkeep |endif
                              if exists("{a:vt}netrw_fenkeep")  |let &l:fen    = {a:vt}netrw_fenkeep     |unlet {a:vt}netrw_fenkeep  |endif
                              if exists("{a:vt}netrw_ffkeep")   |let &l:ff     = {a:vt}netrw_ffkeep      |unlet {a:vt}netrw_ffkeep   |endif
                              if exists("{a:vt}netrw_fokeep")   |let &l:fo     = {a:vt}netrw_fokeep      |unlet {a:vt}netrw_fokeep   |endif
                              if exists("{a:vt}netrw_gdkeep")   |let &l:gd     = {a:vt}netrw_gdkeep      |unlet {a:vt}netrw_gdkeep   |endif
                              if exists("{a:vt}netrw_hidkeep")  |let &l:hidden = {a:vt}netrw_hidkeep     |unlet {a:vt}netrw_hidkeep  |endif
                              if exists("{a:vt}netrw_imkeep")   |let &l:im     = {a:vt}netrw_imkeep      |unlet {a:vt}netrw_imkeep   |endif
                              if exists("{a:vt}netrw_iskkeep")  |let &l:isk    = {a:vt}netrw_iskkeep     |unlet {a:vt}netrw_iskkeep  |endif
                              if exists("{a:vt}netrw_lskeep")   |let &l:ls     = {a:vt}netrw_lskeep      |unlet {a:vt}netrw_lskeep   |endif
                              if exists("{a:vt}netrw_makeep")   |let &l:ma     = {a:vt}netrw_makeep      |unlet {a:vt}netrw_makeep   |endif
                              if exists("{a:vt}netrw_magickeep")|let &l:magic  = {a:vt}netrw_magickeep   |unlet {a:vt}netrw_magickeep|endif
                              if exists("{a:vt}netrw_modkeep")  |let &l:mod    = {a:vt}netrw_modkeep     |unlet {a:vt}netrw_modkeep  |endif
                              if exists("{a:vt}netrw_nukeep")   |let &l:nu     = {a:vt}netrw_nukeep      |unlet {a:vt}netrw_nukeep   |endif
                              if exists("{a:vt}netrw_repkeep")  |let &l:report = {a:vt}netrw_repkeep     |unlet {a:vt}netrw_repkeep  |endif
                              if exists("{a:vt}netrw_rokeep")   |let &l:ro     = {a:vt}netrw_rokeep      |unlet {a:vt}netrw_rokeep   |endif
                              if exists("{a:vt}netrw_selkeep")  |let &l:sel    = {a:vt}netrw_selkeep     |unlet {a:vt}netrw_selkeep  |endif
                              if exists("{a:vt}netrw_spellkeep")|let &l:spell  = {a:vt}netrw_spellkeep   |unlet {a:vt}netrw_spellkeep|endif
                              " Problem: start with liststyle=0; press <i> : result, following line resets l:ts.
                            "  if exists("{a:vt}netrw_tskeep")   |let &l:ts     = {a:vt}netrw_tskeep      |unlet {a:vt}netrw_tskeep   |endif
                              if exists("{a:vt}netrw_twkeep")   |let &l:tw     = {a:vt}netrw_twkeep      |unlet {a:vt}netrw_twkeep   |endif
                              if exists("{a:vt}netrw_wigkeep")  |let &l:wig    = {a:vt}netrw_wigkeep     |unlet {a:vt}netrw_wigkeep  |endif
                              if exists("{a:vt}netrw_wrapkeep") |let &l:wrap   = {a:vt}netrw_wrapkeep    |unlet {a:vt}netrw_wrapkeep |endif
                              if exists("{a:vt}netrw_writekeep")|let &l:write  = {a:vt}netrw_writekeep   |unlet {a:vt}netrw_writekeep|endif
                              if exists("s:yykeep")             |let  @@       = s:yykeep                |unlet s:yykeep             |endif
                              if exists("{a:vt}netrw_swfkeep")
                               if &directory == ""
                                " user hasn't specified a swapfile directory;
                                " netrw will temporarily set the swapfile directory
                                " to the current directory as returned by getcwd().
                                let &l:directory   = getcwd()
                                sil! let &l:swf = {a:vt}netrw_swfkeep
                                setl directory=
                                unlet {a:vt}netrw_swfkeep
                               elseif &l:swf != {a:vt}netrw_swfkeep
                                " following line causes a Press ENTER in windows -- can't seem to work around it!!!
                                sil! let &l:swf= {a:vt}netrw_swfkeep
                                unlet {a:vt}netrw_swfkeep
                               endif
                              endif
                              if exists("{a:vt}netrw_dirkeep") && isdirectory({a:vt}netrw_dirkeep) && g:netrw_keepdir
                               let dirkeep = substitute({a:vt}netrw_dirkeep,'\\','/','g')
                               if exists("{a:vt}netrw_dirkeep")  |exe "keepj lcd ".fnameescape(dirkeep)|unlet {a:vt}netrw_dirkeep  |endif
                              endif
                              if exists("{a:vt}netrw_regstar") |sil! let @*= {a:vt}netrw_regstar |unlet {a:vt}netrw_regstar |endif
                              if exists("{a:vt}netrw_regslash")|sil! let @/= {a:vt}netrw_regslash|unlet {a:vt}netrw_regslash|endif
                              if exists("s:nbcd_curpos_{bufnr('%')}")
                            "   call Decho("(NetrwOptionRestore) restoring previous position  (s:nbcd_curpos_".bufnr('%')." exists)")
                               keepj call netrw#NetrwRestorePosn(s:nbcd_curpos_{bufnr('%')})
                            "   call Decho("(NetrwOptionRestore) unlet s:nbcd_curpos_".bufnr('%'))
                               unlet s:nbcd_curpos_{bufnr('%')}
                              else
                            "   call Decho("no previous position")
                              endif
                            
                            "  call Decho("(NetrwOptionRestore) g:netrw_keepdir=".g:netrw_keepdir.": getcwd<".getcwd()."> acd=".&acd)
                            "  call Decho("(NetrwOptionRestore) fo=".&fo.(exists("+acd")? " acd=".&acd : " acd doesn't exist"))
                            "  call Decho("(NetrwOptionRestore) ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
                            "  call Decho("(NetrwOptionRestore) diff=".&l:diff." win#".winnr()." w:netrw_diffkeep=".(exists("w:netrw_diffkeep")? w:netrw_diffkeep : "doesn't exist"))
                            "  call Decho("(NetrwOptionRestore) ts=".&l:ts)
                              " Moved the filetype detect here from NetrwGetFile() because remote files
                              " were having their filetype detect-generated settings overwritten by
                              " NetrwOptionRestore.
                              if &ft != "netrw"
                            "   call Decho("(NetrwOptionRestore) filetype detect  (ft=".&ft.")")
                               filetype detect
                              endif
                            "  call Dret("s:NetrwOptionRestore : tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> modified=".&modified." modifiable=".&modifiable." readonly=".&readonly)
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwSafeOptions: sets options to help netrw do its job {{{2
                            "                     Use  s:NetrwSaveOptions() to save user settings
                            "                     Use  s:NetrwOptionRestore() to restore user settings
    1              0.000002 fun! s:NetrwSafeOptions()
                            "  call Dfunc("s:NetrwSafeOptions() win#".winnr()." buf#".bufnr("%")."<".bufname(bufnr("%"))."> winnr($)=".winnr("$"))
                            "  call Decho("win#".winnr()."'s ft=".&ft)
                              if exists("+acd") | setl noacd | endif
                              setl noai
                              setl noaw
                              setl nobomb
                              setl noci
                              setl nocin
                              if g:netrw_liststyle == s:TREELIST
                               setl bh=hide
                              endif
                              setl cino=
                              setl com=
                              setl cpo-=a
                              setl cpo-=A
                              setl fo=nroql2
                               setl nohid
                              setl noim
                              setl isk+=@ isk+=* isk+=/
                              setl magic
                              setl report=10000
                              setl sel=inclusive
                              setl nospell
                              setl tw=0
                              setl wig=
                              set  cedit&
                              if g:netrw_use_noswf && has("win32") && !has("win95")
                               setl noswf
                              endif
                              call s:NetrwCursor()
                            
                              " allow the user to override safe options
                            "  call Decho("ft<".&ft."> ei=".&ei)
                              if &ft == "netrw"
                            "   call Decho("do any netrw FileType autocmds (doau FileType netrw)")
                               sil! keepalt keepj doau FileType netrw
                              endif
                            
                            "  call Decho("fo=".&fo.(exists("+acd")? " acd=".&acd : " acd doesn't exist")." bh=".&l:bh)
                            "  call Dret("s:NetrwSafeOptions")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " netrw#Explore: launch the local browser in the directory of the current file {{{2
                            "          indx:  == -1: Nexplore
                            "                 == -2: Pexplore
                            "                 ==  +: this is overloaded:
                            "                      * If Nexplore/Pexplore is in use, then this refers to the
                            "                        indx'th item in the w:netrw_explore_list[] of items which
                            "                        matched the */pattern **/pattern *//pattern **//pattern
                            "                      * If Hexplore or Vexplore, then this will override
                            "                        g:netrw_winsize to specify the qty of rows or columns the
                            "                        newly split window should have.
                            "          dosplit==0: the window will be split iff the current file has been modified
                            "          dosplit==1: the window will be split before running the local browser
                            "          style == 0: Explore     style == 1: Explore!
                            "                == 2: Hexplore    style == 3: Hexplore!
                            "                == 4: Vexplore    style == 5: Vexplore!
                            "                == 6: Texplore
    1              0.000004 fun! netrw#Explore(indx,dosplit,style,...)
                            "  call Dfunc("netrw#Explore(indx=".a:indx." dosplit=".a:dosplit." style=".a:style.",a:1<".a:1.">) &modified=".&modified." modifiable=".&modifiable." a:0=".a:0." win#".winnr()." buf#".bufnr("%"))
                              if !exists("b:netrw_curdir")
                               let b:netrw_curdir= getcwd()
                               if !g:netrw_cygwin && (has("win32") || has("win95") || has("win64") || has("win16"))
                                let b:netrw_curdir= substitute(b:netrw_curdir,'\','/','g')
                               endif
                            "   call Decho("(Explore) set b:netrw_curdir<".b:netrw_curdir."> (used getcwd)")
                              endif
                              let curdir     = simplify(b:netrw_curdir)
                              let curfiledir = substitute(expand("%:p"),'^\(.*[/\\]\)[^/\\]*$','\1','e')
                              if !exists("g:netrw_cygwin") && (has("win32") || has("win95") || has("win64") || has("win16"))
                               let curdir= substitute(curdir,'\','/','g')
                              endif
                            "  call Decho("(Explore) curdir<".curdir.">  curfiledir<".curfiledir.">")
                            
                              " save registers
                              sil! let keepregstar = @*
                              sil! let keepregplus = @+
                              sil! let keepregslash= @/
                            
                              " if dosplit or file has been modified
                              if a:dosplit || &modified || a:style == 6
                            "   call Decho("(Explore) case dosplit=".a:dosplit." modified=".&modified." a:style=".a:style.": dosplit or file has been modified")
                               call s:SaveWinVars()
                               let winsz= g:netrw_winsize
                               if a:indx > 0
                                let winsz= a:indx
                               endif
                            
                               if a:style == 0      " Explore, Sexplore
                            "    call Decho("(Explore) style=0: Explore or Sexplore")
                                let winsz= (winsz > 0)? (winsz*winheight(0))/100 : -winsz
                                exe winsz."wincmd s"
                            
                               elseif a:style == 1  "Explore!, Sexplore!
                            "    call Decho("(Explore) style=1: Explore! or Sexplore!")
                                let winsz= (winsz > 0)? (winsz*winwidth(0))/100 : -winsz
                                exe "keepalt ".winsz."wincmd v"
                            
                               elseif a:style == 2  " Hexplore
                            "    call Decho("(Explore) style=2: Hexplore")
                                let winsz= (winsz > 0)? (winsz*winheight(0))/100 : -winsz
                                exe "keepalt bel ".winsz."wincmd s"
                            
                               elseif a:style == 3  " Hexplore!
                            "    call Decho("(Explore) style=3: Hexplore!")
                                let winsz= (winsz > 0)? (winsz*winheight(0))/100 : -winsz
                                exe "keepalt abo ".winsz."wincmd s"
                            
                               elseif a:style == 4  " Vexplore
                            "    call Decho("(Explore) style=4: Vexplore")
                                let winsz= (winsz > 0)? (winsz*winwidth(0))/100 : -winsz
                                exe "keepalt lefta ".winsz."wincmd v"
                            
                               elseif a:style == 5  " Vexplore!
                            "    call Decho("(Explore) style=5: Vexplore!")
                                let winsz= (winsz > 0)? (winsz*winwidth(0))/100 : -winsz
                                exe "keepalt rightb ".winsz."wincmd v"
                            
                               elseif a:style == 6  " Texplore
                                call s:SaveBufVars()
                            "    call Decho("(Explore) style  = 6: Texplore")
                                exe "keepalt tabnew ".fnameescape(curdir)
                                call s:RestoreBufVars()
                               endif
                               call s:RestoreWinVars()
                            "  else " Decho
                            "   call Decho("(Explore) case a:dosplit=".a:dosplit." AND modified=".&modified." AND a:style=".a:style." is not 6")
                              endif
                              keepj norm! 0
                            
                              if a:0 > 0
                            "   call Decho("(Explore) case [a:0=".a:0."] > 0: a:1<".a:1.">")
                               if a:1 =~ '^\~' && (has("unix") || (exists("g:netrw_cygwin") && g:netrw_cygwin))
                            "    call Decho("(Explore) ..case a:1<".a:1.">: starts with ~ and unix or cygwin")
                                let dirname= simplify(substitute(a:1,'\~',expand("$HOME"),''))
                            "    call Decho("(Explore) ..using dirname<".dirname.">  (case: ~ && unix||cygwin)")
                               elseif a:1 == '.'
                            "    call Decho("(Explore) ..case a:1<".a:1.">: matches .")
                                let dirname= simplify(exists("b:netrw_curdir")? b:netrw_curdir : getcwd())
                                if dirname !~ '/$'
                                 let dirname= dirname."/"
                                endif
                            "    call Decho("(Explore) ..using dirname<".dirname.">  (case: ".(exists("b:netrw_curdir")? "b:netrw_curdir" : "getcwd()").")")
                               elseif a:1 =~ '\$'
                            "    call Decho("(Explore) ..case a:1<".a:1.">: matches ending $")
                                let dirname= simplify(expand(a:1))
                            "    call Decho("(Explore) ..using user-specified dirname<".dirname."> with $env-var")
                               elseif a:1 !~ '^\*\{1,2}/' && a:1 !~ '^\a\{3,}://'
                            "    call Decho("(Explore) ..case a:1<".a:1.">: other, not pattern or filepattern")
                                let dirname= simplify(a:1)
                            "    call Decho("(Explore) ..using user-specified dirname<".dirname.">")
                               else
                            "    call Decho("(Explore) ..case a:1: pattern or filepattern")
                                let dirname= a:1
                               endif
                              else
                               " clear explore
                            "   call Decho("(Explore) case a:0=".a:0.": clearing Explore list")
                               call s:NetrwClearExplore()
                            "   call Dret("netrw#Explore : cleared list")
                               return
                              endif
                            
                            "  call Decho("(Explore) dirname<".dirname.">")
                              if dirname =~ '\.\./\=$'
                               let dirname= simplify(fnamemodify(dirname,':p:h'))
                              elseif dirname =~ '\.\.' || dirname == '.'
                               let dirname= simplify(fnamemodify(dirname,':p'))
                              endif
                            "  call Decho("(Explore) dirname<".dirname.">  (after simplify)")
                            
                              if dirname =~ '^\*//'
                               " starpat=1: Explore *//pattern   (current directory only search for files containing pattern)
                            "   call Decho("(Explore) case starpat=1: Explore *//pattern")
                               let pattern= substitute(dirname,'^\*//\(.*\)$','\1','')
                               let starpat= 1
                            "   call Decho("(Explore) ..Explore *//pat: (starpat=".starpat.") dirname<".dirname."> -> pattern<".pattern.">")
                               if &hls | let keepregslash= s:ExplorePatHls(pattern) | endif
                            
                              elseif dirname =~ '^\*\*//'
                               " starpat=2: Explore **//pattern  (recursive descent search for files containing pattern)
                            "   call Decho("(Explore) case starpat=2: Explore **//pattern")
                               let pattern= substitute(dirname,'^\*\*//','','')
                               let starpat= 2
                            "   call Decho("(Explore) ..Explore **//pat: (starpat=".starpat.") dirname<".dirname."> -> pattern<".pattern.">")
                            
                              elseif dirname =~ '/\*\*/'
                               " handle .../**/.../filepat
                            "   call Decho("(Explore) case starpat=4: Explore .../**/.../filepat")
                               let prefixdir= substitute(dirname,'^\(.\{-}\)\*\*.*$','\1','')
                               if prefixdir =~ '^/' || (prefixdir =~ '^\a:/' && (has("win32") || has("win95") || has("win64") || has("win16")))
                                let b:netrw_curdir = prefixdir
                               else
                                let b:netrw_curdir= getcwd().'/'.prefixdir
                               endif
                               let dirname= substitute(dirname,'^.\{-}\(\*\*/.*\)$','\1','')
                               let starpat= 4
                            "   call Decho("(Explore) ..pwd<".getcwd()."> dirname<".dirname.">")
                            "   call Decho("(Explore) ..case Explore ../**/../filepat (starpat=".starpat.")")
                            
                              elseif dirname =~ '^\*/'
                               " case starpat=3: Explore */filepat   (search in current directory for filenames matching filepat)
                               let starpat= 3
                            "   call Decho("(Explore) case starpat=3: Explore */filepat (starpat=".starpat.")")
                            
                              elseif dirname=~ '^\*\*/'
                               " starpat=4: Explore **/filepat  (recursive descent search for filenames matching filepat)
                               let starpat= 4
                            "   call Decho("(Explore) case starpat=4: Explore **/filepat (starpat=".starpat.")")
                            
                              else
                               let starpat= 0
                            "   call Decho("(Explore) case starpat=0: default")
                              endif
                            
                              if starpat == 0 && a:indx >= 0
                               " [Explore Hexplore Vexplore Sexplore] [dirname]
                            "   call Decho("(Explore) case starpat==0 && a:indx=".a:indx.": dirname<".dirname.">, handles Explore Hexplore Vexplore Sexplore")
                               if dirname == ""
                                let dirname= curfiledir
                            "    call Decho("(Explore) ..empty dirname, using current file's directory<".dirname.">")
                               endif
                               if dirname =~ '^scp://' || dirname =~ '^ftp://'
                                call netrw#Nread(2,dirname)
                                "call s:NetrwBrowse(0,dirname)
                               else
                                if dirname == ""
                                 let dirname= getcwd()
                                elseif (has("win32") || has("win95") || has("win64") || has("win16")) && !g:netrw_cygwin
                                 if dirname !~ '^[a-zA-Z]:'
                                  let dirname= b:netrw_curdir."/".dirname
                                 endif
                                elseif dirname !~ '^/'
                                 let dirname= b:netrw_curdir."/".dirname
                                endif
                            "    call Decho("(Explore) ..calling LocalBrowseCheck(dirname<".dirname.">)")
                                call netrw#LocalBrowseCheck(dirname)
                            "    call Decho("(Explore) win#".winnr()." buf#".bufnr("%")." modified=".&modified." modifiable=".&modifiable." readonly=".&readonly)
                               endif
                               if exists("w:netrw_bannercnt")
                                " done to handle P08-Ingelrest. :Explore will _Always_ go to the line just after the banner.
                                " If one wants to return the same place in the netrw window, use :Rex instead.
                                exe w:netrw_bannercnt
                               endif
                            
                            "   call Decho("(Explore) curdir<".curdir.">")
                               " ---------------------------------------------------------------------
                               " Jan 24, 2013: not sure why the following was present.  See P08-Ingelrest
                            "   if has("win32") || has("win95") || has("win64") || has("win16")
                            "    keepj call search('\<'.substitute(curdir,'^.*[/\\]','','e').'\>','cW')
                            "   else
                            "    keepj call search('\<'.substitute(curdir,'^.*/','','e').'\>','cW')
                            "   endif
                               " ---------------------------------------------------------------------
                            
                              " starpat=1: Explore *//pattern  (current directory only search for files containing pattern)
                              " starpat=2: Explore **//pattern (recursive descent search for files containing pattern)
                              " starpat=3: Explore */filepat   (search in current directory for filenames matching filepat)
                              " starpat=4: Explore **/filepat  (recursive descent search for filenames matching filepat)
                              elseif a:indx <= 0
                               " Nexplore, Pexplore, Explore: handle starpat
                            "   call Decho("(Explore) case a:indx<=0: Nexplore, Pexplore, <s-down>, <s-up> starpat=".starpat." a:indx=".a:indx)
                               if !mapcheck("<s-up>","n") && !mapcheck("<s-down>","n") && exists("b:netrw_curdir")
                            "    call Decho("(Explore) ..set up <s-up> and <s-down> maps")
                                let s:didstarstar= 1
                                nnoremap <buffer> <silent> <s-up>	:Pexplore<cr>
                                nnoremap <buffer> <silent> <s-down>	:Nexplore<cr>
                               endif
                            
                               if has("path_extra")
                            "    call Decho("(Explore) ..starpat=".starpat.": has +path_extra")
                                if !exists("w:netrw_explore_indx")
                                 let w:netrw_explore_indx= 0
                                endif
                            
                                let indx = a:indx
                            "    call Decho("(Explore) ..starpat=".starpat.": set indx= [a:indx=".indx."]")
                            
                                if indx == -1
                                 " Nexplore
                            "     call Decho("(Explore) ..case Nexplore with starpat=".starpat.": (indx=".indx.")")
                                 if !exists("w:netrw_explore_list") " sanity check
                                  keepj call netrw#ErrorMsg(s:WARNING,"using Nexplore or <s-down> improperly; see help for netrw-starstar",40)
                                  sil! let @* = keepregstar
                                  sil! let @+ = keepregstar
                                  sil! let @/ = keepregslash
                            "      call Dret("netrw#Explore")
                                  return
                                 endif
                                 let indx= w:netrw_explore_indx
                                 if indx < 0                        | let indx= 0                           | endif
                                 if indx >= w:netrw_explore_listlen | let indx= w:netrw_explore_listlen - 1 | endif
                                 let curfile= w:netrw_explore_list[indx]
                            "     call Decho("(Explore) ....indx=".indx." curfile<".curfile.">")
                                 while indx < w:netrw_explore_listlen && curfile == w:netrw_explore_list[indx]
                                  let indx= indx + 1
                            "      call Decho("(Explore) ....indx=".indx." (Nexplore while loop)")
                                 endwhile
                                 if indx >= w:netrw_explore_listlen | let indx= w:netrw_explore_listlen - 1 | endif
                            "     call Decho("(Explore) ....Nexplore: indx= [w:netrw_explore_indx=".w:netrw_explore_indx."]=".indx)
                            
                                elseif indx == -2
                                 " Pexplore
                            "     call Decho("(Explore) case Pexplore with starpat=".starpat.": (indx=".indx.")")
                                 if !exists("w:netrw_explore_list") " sanity check
                                  keepj call netrw#ErrorMsg(s:WARNING,"using Pexplore or <s-up> improperly; see help for netrw-starstar",41)
                                  sil! let @* = keepregstar
                                  sil! let @+ = keepregstar
                                  sil! let @/ = keepregslash
                            "      call Dret("netrw#Explore")
                                  return
                                 endif
                                 let indx= w:netrw_explore_indx
                                 if indx < 0                        | let indx= 0                           | endif
                                 if indx >= w:netrw_explore_listlen | let indx= w:netrw_explore_listlen - 1 | endif
                                 let curfile= w:netrw_explore_list[indx]
                            "     call Decho("(Explore) ....indx=".indx." curfile<".curfile.">")
                                 while indx >= 0 && curfile == w:netrw_explore_list[indx]
                                  let indx= indx - 1
                            "      call Decho("(Explore) ....indx=".indx." (Pexplore while loop)")
                                 endwhile
                                 if indx < 0                        | let indx= 0                           | endif
                            "     call Decho("(Explore) ....Pexplore: indx= [w:netrw_explore_indx=".w:netrw_explore_indx."]=".indx)
                            
                                else
                                 " Explore -- initialize
                                 " build list of files to Explore with Nexplore/Pexplore
                            "     call Decho("(Explore) ..starpat=".starpat.": case Explore: initialize (indx=".indx.")")
                                 keepj keepalt call s:NetrwClearExplore()
                                 let w:netrw_explore_indx= 0
                                 if !exists("b:netrw_curdir")
                                  let b:netrw_curdir= getcwd()
                                 endif
                            "     call Decho("(Explore) ....starpat=".starpat.": b:netrw_curdir<".b:netrw_curdir.">")
                            
                                 " switch on starpat to build the w:netrw_explore_list of files
                                 if starpat == 1
                                  " starpat=1: Explore *//pattern  (current directory only search for files containing pattern)
                            "      call Decho("(Explore) ..case starpat=".starpat.": build *//pattern list  (curdir-only srch for files containing pattern)  &hls=".&hls)
                            "      call Decho("(Explore) ....pattern<".pattern.">")
                                  try
                                   exe "keepj noautocmd vimgrep /".pattern."/gj ".fnameescape(b:netrw_curdir)."/*"
                                  catch /^Vim\%((\a\+)\)\=:E480/
                                   keepalt call netrw#ErrorMsg(s:WARNING,"no match with pattern<".pattern.">",76)
                            "       call Dret("netrw#Explore : unable to find pattern<".pattern.">")
                                   return
                                  endtry
                                  let w:netrw_explore_list = s:NetrwExploreListUniq(map(getqflist(),'bufname(v:val.bufnr)'))
                                  if &hls | let keepregslash= s:ExplorePatHls(pattern) | endif
                            
                                 elseif starpat == 2
                                  " starpat=2: Explore **//pattern (recursive descent search for files containing pattern)
                            "      call Decho("(Explore) ..case starpat=".starpat.": build **//pattern list  (recursive descent files containing pattern)")
                            "      call Decho("(Explore) ....pattern<".pattern.">")
                                  try
                                   exe "sil keepj noautocmd keepalt vimgrep /".pattern."/gj "."**/*"
                                  catch /^Vim\%((\a\+)\)\=:E480/
                                   keepalt call netrw#ErrorMsg(s:WARNING,'no files matched pattern<'.pattern.'>',45)
                                   if &hls | let keepregslash= s:ExplorePatHls(pattern) | endif
                                   sil! let @* = keepregstar
                                   sil! let @+ = keepregstar
                                   sil! let @/ = keepregslash
                            "       call Dret("netrw#Explore : no files matched pattern")
                                   return
                                  endtry
                                  let s:netrw_curdir       = b:netrw_curdir
                                  let w:netrw_explore_list = getqflist()
                                  let w:netrw_explore_list = s:NetrwExploreListUniq(map(w:netrw_explore_list,'s:netrw_curdir."/".bufname(v:val.bufnr)'))
                                  if &hls | let keepregslash= s:ExplorePatHls(pattern) | endif
                            
                                 elseif starpat == 3
                                  " starpat=3: Explore */filepat   (search in current directory for filenames matching filepat)
                            "      call Decho("(Explore) ..case starpat=".starpat.": build */filepat list  (curdir-only srch filenames matching filepat)  &hls=".&hls)
                                  let filepat= substitute(dirname,'^\*/','','')
                                  let filepat= substitute(filepat,'^[%#<]','\\&','')
                            "      call Decho("(Explore) ....b:netrw_curdir<".b:netrw_curdir.">")
                            "      call Decho("(Explore) ....filepat<".filepat.">")
                                  let w:netrw_explore_list= s:NetrwExploreListUniq(split(expand(b:netrw_curdir."/".filepat),'\n'))
                                  if &hls | let keepregslash= s:ExplorePatHls(filepat) | endif
                            
                                 elseif starpat == 4
                                  " starpat=4: Explore **/filepat  (recursive descent search for filenames matching filepat)
                            "      call Decho("(Explore) ..case starpat=".starpat.": build **/filepat list  (recursive descent srch filenames matching filepat)  &hls=".&hls)
                                  let w:netrw_explore_list= s:NetrwExploreListUniq(split(expand(b:netrw_curdir."/".dirname),'\n'))
                                  if &hls | let keepregslash= s:ExplorePatHls(dirname) | endif
                                 endif " switch on starpat to build w:netrw_explore_list
                            
                                 let w:netrw_explore_listlen = len(w:netrw_explore_list)
                            "     call Decho("(Explore) ....w:netrw_explore_list<".string(w:netrw_explore_list).">")
                            "     call Decho("(Explore) ....w:netrw_explore_listlen=".w:netrw_explore_listlen)
                            
                                 if w:netrw_explore_listlen == 0 || (w:netrw_explore_listlen == 1 && w:netrw_explore_list[0] =~ '\*\*\/')
                                  keepalt keepj call netrw#ErrorMsg(s:WARNING,"no files matched",42)
                                  sil! let @* = keepregstar
                                  sil! let @+ = keepregstar
                                  sil! let @/ = keepregslash
                            "      call Dret("netrw#Explore : no files matched")
                                  return
                                 endif
                                endif  " if indx ... endif
                            
                                " NetrwStatusLine support - for exploring support
                                let w:netrw_explore_indx= indx
                            "    call Decho("(Explore) ....w:netrw_explore_list<".join(w:netrw_explore_list,',')."> len=".w:netrw_explore_listlen)
                            
                                " wrap the indx around, but issue a note
                                if indx >= w:netrw_explore_listlen || indx < 0
                            "     call Decho("(Explore) ....wrap indx (indx=".indx." listlen=".w:netrw_explore_listlen.")")
                                 let indx                = (indx < 0)? ( w:netrw_explore_listlen - 1 ) : 0
                                 let w:netrw_explore_indx= indx
                                 keepalt keepj call netrw#ErrorMsg(s:NOTE,"no more files match Explore pattern",43)
                                endif
                            
                                exe "let dirfile= w:netrw_explore_list[".indx."]"
                            "    call Decho("(Explore) ....dirfile=w:netrw_explore_list[indx=".indx."]= <".dirfile.">")
                                let newdir= substitute(dirfile,'/[^/]*$','','e')
                            "    call Decho("(Explore) ....newdir<".newdir.">")
                            
                            "    call Decho("(Explore) ....calling LocalBrowseCheck(newdir<".newdir.">)")
                                call netrw#LocalBrowseCheck(newdir)
                                if !exists("w:netrw_liststyle")
                                 let w:netrw_liststyle= g:netrw_liststyle
                                endif
                                if w:netrw_liststyle == s:THINLIST || w:netrw_liststyle == s:LONGLIST
                                 keepalt keepj call search('^'.substitute(dirfile,"^.*/","","").'\>',"W")
                                else
                                 keepalt keepj call search('\<'.substitute(dirfile,"^.*/","","").'\>',"w")
                                endif
                                let w:netrw_explore_mtchcnt = indx + 1
                                let w:netrw_explore_bufnr   = bufnr("%")
                                let w:netrw_explore_line    = line(".")
                                keepalt keepj call s:SetupNetrwStatusLine('%f %h%m%r%=%9*%{NetrwStatusLine()}')
                            "    call Decho("(Explore) ....explore: mtchcnt=".w:netrw_explore_mtchcnt." bufnr=".w:netrw_explore_bufnr." line#".w:netrw_explore_line)
                            
                               else
                            "    call Decho("(Explore) ..your vim does not have +path_extra")
                                if !exists("g:netrw_quiet")
                                 keepalt keepj call netrw#ErrorMsg(s:WARNING,"your vim needs the +path_extra feature for Exploring with **!",44)
                                endif
                                sil! let @* = keepregstar
                                sil! let @+ = keepregstar
                                sil! let @/ = keepregslash
                            "    call Dret("netrw#Explore : missing +path_extra")
                                return
                               endif
                            
                              else
                            "   call Decho("(Explore) ..default case: Explore newdir<".dirname.">")
                               if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST && dirname =~ '/'
                                sil! unlet w:netrw_treedict
                                sil! unlet w:netrw_treetop
                               endif
                               let newdir= dirname
                               if !exists("b:netrw_curdir")
                                keepj call netrw#LocalBrowseCheck(getcwd())
                               else
                                keepj call netrw#LocalBrowseCheck(s:NetrwBrowseChgDir(1,newdir))
                               endif
                              endif
                            
                              " visual display of **/ **// */ Exploration files
                            "  call Decho("(Explore) w:netrw_explore_indx=".(exists("w:netrw_explore_indx")? w:netrw_explore_indx : "doesn't exist"))
                            "  call Decho("(Explore) b:netrw_curdir<".(exists("b:netrw_curdir")? b:netrw_curdir : "n/a").">")
                              if exists("w:netrw_explore_indx") && exists("b:netrw_curdir")
                            "   call Decho("(Explore) s:explore_prvdir<".(exists("s:explore_prvdir")? s:explore_prvdir : "-doesn't exist-"))
                               if !exists("s:explore_prvdir") || s:explore_prvdir != b:netrw_curdir
                                " only update match list if current directory isn't the same as before
                            "    call Decho("(Explore) only update match list if current directory not the same as before")
                                let s:explore_prvdir = b:netrw_curdir
                                let s:explore_match  = ""
                                let dirlen           = s:Strlen(b:netrw_curdir)
                                if b:netrw_curdir !~ '/$'
                                 let dirlen= dirlen + 1
                                endif
                                let prvfname= ""
                                for fname in w:netrw_explore_list
                            "     call Decho("(Explore) fname<".fname.">")
                                 if fname =~ '^'.b:netrw_curdir
                                  if s:explore_match == ""
                                   let s:explore_match= '\<'.escape(strpart(fname,dirlen),g:netrw_markfileesc).'\>'
                                  else
                                   let s:explore_match= s:explore_match.'\|\<'.escape(strpart(fname,dirlen),g:netrw_markfileesc).'\>'
                                  endif
                                 elseif fname !~ '^/' && fname != prvfname
                                  if s:explore_match == ""
                                   let s:explore_match= '\<'.escape(fname,g:netrw_markfileesc).'\>'
                                  else
                                   let s:explore_match= s:explore_match.'\|\<'.escape(fname,g:netrw_markfileesc).'\>'
                                  endif
                                 endif
                                 let prvfname= fname
                                endfor
                            "    call Decho("(Explore) explore_match<".s:explore_match.">")
                                exe "2match netrwMarkFile /".s:explore_match."/"
                               endif
                               echo "<s-up>==Pexplore  <s-down>==Nexplore"
                              else
                               2match none
                               if exists("s:explore_match")  | unlet s:explore_match  | endif
                               if exists("s:explore_prvdir") | unlet s:explore_prvdir | endif
                               echo " "
                            "   call Decho("(Explore) cleared explore match list")
                              endif
                            
                              sil! let @* = keepregstar
                              sil! let @+ = keepregstar
                              sil! let @/ = keepregslash
                            "  call Dret("netrw#Explore : @/<".@/.">")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " netrw#NetrwMakeTgt: make a target out of the directory name provided {{{2
    1              0.000004 fun! netrw#NetrwMakeTgt(dname)
                            "  call Dfunc("netrw#NetrwMakeTgt(dname<".a:dname.">)")
                               " simplify the target (eg. /abc/def/../ghi -> /abc/ghi)
                              let svpos               = netrw#NetrwSavePosn()
                              let s:netrwmftgt_islocal= (a:dname !~ '^\a\+://')
                            "  call Decho("s:netrwmftgt_islocal=".s:netrwmftgt_islocal)
                              if s:netrwmftgt_islocal
                               let netrwmftgt= simplify(a:dname)
                              else
                               let netrwmftgt= a:dname
                              endif
                              if exists("s:netrwmftgt") && netrwmftgt == s:netrwmftgt
                               " re-selected target, so just clear it
                               unlet s:netrwmftgt s:netrwmftgt_islocal
                              else
                               let s:netrwmftgt= netrwmftgt
                              endif
                              if g:netrw_fastbrowse <= 1
                               call s:NetrwRefresh((b:netrw_curdir !~ '\a\+://'),b:netrw_curdir)
                              endif
                              call netrw#NetrwRestorePosn(svpos)
                            "  call Dret("netrw#NetrwMakeTgt")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " netrw#NetrwClean: remove netrw {{{2
                            " supports :NetrwClean  -- remove netrw from first directory on runtimepath
                            "          :NetrwClean! -- remove netrw from all directories on runtimepath
    1              0.000003 fun! netrw#NetrwClean(sys)
                            "  call Dfunc("netrw#NetrwClean(sys=".a:sys.")")
                            
                              if a:sys
                               let choice= confirm("Remove personal and system copies of netrw?","&Yes\n&No")
                              else
                               let choice= confirm("Remove personal copy of netrw?","&Yes\n&No")
                              endif
                            "  call Decho("choice=".choice)
                              let diddel= 0
                              let diddir= ""
                            
                              if choice == 1
                               for dir in split(&rtp,',')
                                if filereadable(dir."/plugin/netrwPlugin.vim")
                            "     call Decho("removing netrw-related files from ".dir)
                                 if s:NetrwDelete(dir."/plugin/netrwPlugin.vim")        |call netrw#ErrorMsg(1,"unable to remove ".dir."/plugin/netrwPlugin.vim",55)        |endif
                                 if s:NetrwDelete(dir."/autoload/netrwFileHandlers.vim")|call netrw#ErrorMsg(1,"unable to remove ".dir."/autoload/netrwFileHandlers.vim",55)|endif
                                 if s:NetrwDelete(dir."/autoload/netrwSettings.vim")    |call netrw#ErrorMsg(1,"unable to remove ".dir."/autoload/netrwSettings.vim",55)    |endif
                                 if s:NetrwDelete(dir."/autoload/netrw.vim")            |call netrw#ErrorMsg(1,"unable to remove ".dir."/autoload/netrw.vim",55)            |endif
                                 if s:NetrwDelete(dir."/syntax/netrw.vim")              |call netrw#ErrorMsg(1,"unable to remove ".dir."/syntax/netrw.vim",55)              |endif
                                 if s:NetrwDelete(dir."/syntax/netrwlist.vim")          |call netrw#ErrorMsg(1,"unable to remove ".dir."/syntax/netrwlist.vim",55)          |endif
                                 let diddir= dir
                                 let diddel= diddel + 1
                                 if !a:sys|break|endif
                                endif
                               endfor
                              endif
                            
                               echohl WarningMsg
                              if diddel == 0
                               echomsg "netrw is either not installed or not removable"
                              elseif diddel == 1
                               echomsg "removed one copy of netrw from <".diddir.">"
                              else
                               echomsg "removed ".diddel." copies of netrw"
                              endif
                               echohl None
                            
                            "  call Dret("netrw#NetrwClean")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " netrw#Nread: {{{2
    1              0.000003 fun! netrw#Nread(mode,fname)
                            "  call Dfunc("netrw#Nread(mode=".a:mode." fname<".a:fname.">)")
                              call netrw#NetrwSavePosn()
                              call netrw#NetRead(a:mode,a:fname)
                              call netrw#NetrwRestorePosn()
                            "  call Dret("netrw#Nread")
                            endfun
                            
                            " ------------------------------------------------------------------------
                            " netrw#NetrwObtain: {{{2
                            "   netrw#NetrwObtain(islocal,fname[,tgtdirectory])
                            "     islocal=0  obtain from remote source
                            "            =1  obtain from local source
                            "     fname  :   a filename or a list of filenames
                            "     tgtdir :   optional place where files are to go  (not present, uses getcwd())
    1              0.000004 fun! netrw#NetrwObtain(islocal,fname,...)
                            "  call Dfunc("netrw#NetrwObtain(islocal=".a:islocal." fname<".((type(a:fname) == 1)? a:fname : string(a:fname)).">) a:0=".a:0)
                              " NetrwStatusLine support - for obtaining support
                            
                              if type(a:fname) == 1
                               let fnamelist= [ a:fname ]
                              elseif type(a:fname) == 3
                               let fnamelist= a:fname
                              else
                               call netrw#ErrorMsg(s:ERROR,"attempting to use NetrwObtain on something not a filename or a list",62)
                            "   call Dret("netrw#NetrwObtain")
                               return
                              endif
                            "  call Decho("fnamelist<".string(fnamelist).">")
                              if a:0 > 0
                               let tgtdir= a:1
                              else
                               let tgtdir= getcwd()
                              endif
                            "  call Decho("tgtdir<".tgtdir.">")
                            
                              if exists("b:netrw_islocal") && b:netrw_islocal
                               " obtain a file from local b:netrw_curdir to (local) tgtdir
                            "   call Decho("obtain a file from local ".b:netrw_curdir." to ".tgtdir)
                               if exists("b:netrw_curdir") && getcwd() != b:netrw_curdir
                                let topath= s:ComposePath(tgtdir,"")
                                if (has("win32") || has("win95") || has("win64") || has("win16"))
                                 " transfer files one at time
                            "     call Decho("transfer files one at a time")
                                 for fname in fnamelist
                            "      call Decho("system(".g:netrw_localcopycmd." ".shellescape(fname)." ".shellescape(topath).")")
                                  call system(g:netrw_localcopycmd." ".shellescape(fname)." ".shellescape(topath))
                                  if v:shell_error != 0
                                   call netrw#ErrorMsg(s:WARNING,"consider setting g:netrw_localcopycmd<".g:netrw_localcopycmd."> to something that works",80)
                            "       call Dret("s:NetrwObtain 0 : failed: ".g:netrw_localcopycmd." ".shellescape(fname)." ".shellescape(topath))
                                   return
                                  endif
                                 endfor
                                else
                                 " transfer files with one command
                            "     call Decho("transfer files with one command")
                                 let filelist= join(map(deepcopy(fnamelist),"shellescape(v:val)"))
                            "     call Decho("system(".g:netrw_localcopycmd." ".filelist." ".shellescape(topath).")")
                                 call system(g:netrw_localcopycmd." ".filelist." ".shellescape(topath))
                                 if v:shell_error != 0
                                  call netrw#ErrorMsg(s:WARNING,"consider setting g:netrw_localcopycmd<".g:netrw_localcopycmd."> to something that works",80)
                            "      call Dret("s:NetrwObtain 0 : failed: ".g:netrw_localcopycmd." ".filelist." ".shellescape(topath))
                                  return
                                 endif
                                endif
                               elseif !exists("b:netrw_curdir")
                                call netrw#ErrorMsg(s:ERROR,"local browsing directory doesn't exist!",36)
                               else
                                call netrw#ErrorMsg(s:WARNING,"local browsing directory and current directory are identical",37)
                               endif
                            
                              else
                               " obtain files from remote b:netrw_curdir to local tgtdir
                            "   call Decho("obtain a file from remote ".b:netrw_curdir." to ".tgtdir)
                               if type(a:fname) == 1
                                call s:SetupNetrwStatusLine('%f %h%m%r%=%9*Obtaining '.a:fname)
                               endif
                               call s:NetrwMethod(b:netrw_curdir)
                            
                               if b:netrw_method == 4
                                " obtain file using scp
                            "    call Decho("obtain via scp (method#4)")
                                if exists("g:netrw_port") && g:netrw_port != ""
                                 let useport= " ".g:netrw_scpport." ".g:netrw_port
                                else
                                 let useport= ""
                                endif
                                if b:netrw_fname =~ '/'
                                 let path= substitute(b:netrw_fname,'^\(.*/\).\{-}$','\1','')
                                else
                                 let path= ""
                                endif
                                let filelist= join(map(deepcopy(fnamelist),'shellescape(g:netrw_machine.":".path.v:val,1)'))
                            "    call Decho("exe ".s:netrw_silentxfer."!".g:netrw_scp_cmd.shellescape(useport,1)." ".filelist." ".shellescape(tgtdir,1))
                                exe s:netrw_silentxfer."!".g:netrw_scp_cmd.shellescape(useport,1)." ".filelist." ".shellescape(tgtdir,1)
                            
                               elseif b:netrw_method == 2
                                " obtain file using ftp + .netrc
                            "     call Decho("obtain via ftp+.netrc (method #2)")
                                 call s:SaveBufVars()|sil keepjumps new|call s:RestoreBufVars()
                                 let tmpbufnr= bufnr("%")
                                 setl ff=unix
                                 if exists("g:netrw_ftpmode") && g:netrw_ftpmode != ""
                                  keepj put =g:netrw_ftpmode
                            "      call Decho("filter input: ".getline('$'))
                                 endif
                            
                                 if exists("b:netrw_fname") && b:netrw_fname != ""
                                  call setline(line("$")+1,'cd "'.b:netrw_fname.'"')
                            "      call Decho("filter input: ".getline('$'))
                                 endif
                            
                                 if exists("g:netrw_ftpextracmd")
                                  keepj put =g:netrw_ftpextracmd
                            "      call Decho("filter input: ".getline('$'))
                                 endif
                                 for fname in fnamelist
                                  call setline(line("$")+1,'get "'.fname.'"')
                            "      call Decho("filter input: ".getline('$'))
                                 endfor
                                 if exists("g:netrw_port") && g:netrw_port != ""
                            "      call Decho("executing: %!".s:netrw_ftp_cmd." -i ".shellescape(g:netrw_machine,1)." ".shellescape(g:netrw_port,1))
                                  exe s:netrw_silentxfer."%!".s:netrw_ftp_cmd." -i ".shellescape(g:netrw_machine,1)." ".shellescape(g:netrw_port,1)
                                 else
                            "      call Decho("executing: %!".s:netrw_ftp_cmd." -i ".shellescape(g:netrw_machine,1))
                                  exe s:netrw_silentxfer."%!".s:netrw_ftp_cmd." -i ".shellescape(g:netrw_machine,1)
                                 endif
                                 " If the result of the ftp operation isn't blank, show an error message (tnx to Doug Claar)
                                 if getline(1) !~ "^$" && !exists("g:netrw_quiet") && getline(1) !~ '^Trying '
                                  let debugkeep= &debug
                                  setl debug=msg
                                  call netrw#ErrorMsg(s:ERROR,getline(1),4)
                                  let &debug= debugkeep
                                 endif
                            
                               elseif b:netrw_method == 3
                                " obtain with ftp + machine, id, passwd, and fname (ie. no .netrc)
                            "    call Decho("obtain via ftp+mipf (method #3)")
                                call s:SaveBufVars()|sil keepjumps new|call s:RestoreBufVars()
                                let tmpbufnr= bufnr("%")
                                setl ff=unix
                            
                                if exists("g:netrw_port") && g:netrw_port != ""
                                 keepj put ='open '.g:netrw_machine.' '.g:netrw_port
                            "     call Decho("filter input: ".getline('$'))
                                else
                                 keepj put ='open '.g:netrw_machine
                            "     call Decho("filter input: ".getline('$'))
                                endif
                            
                                if exists("g:netrw_uid") && g:netrw_uid != ""
                                 if exists("g:netrw_ftp") && g:netrw_ftp == 1
                                  keepj put =g:netrw_uid
                            "      call Decho("filter input: ".getline('$'))
                                  if exists("s:netrw_passwd") && s:netrw_passwd != ""
                                   keepj put ='\"'.s:netrw_passwd.'\"'
                                  endif
                            "      call Decho("filter input: ".getline('$'))
                                 elseif exists("s:netrw_passwd")
                                  keepj put ='user \"'.g:netrw_uid.'\" \"'.s:netrw_passwd.'\"'
                            "      call Decho("filter input: ".getline('$'))
                                 endif
                                endif
                            
                                if exists("g:netrw_ftpmode") && g:netrw_ftpmode != ""
                                 keepj put =g:netrw_ftpmode
                            "     call Decho("filter input: ".getline('$'))
                                endif
                            
                                if exists("b:netrw_fname") && b:netrw_fname != ""
                                 keepj call setline(line("$")+1,'cd "'.b:netrw_fname.'"')
                            "     call Decho("filter input: ".getline('$'))
                                endif
                            
                                if exists("g:netrw_ftpextracmd")
                                 keepj put =g:netrw_ftpextracmd
                            "     call Decho("filter input: ".getline('$'))
                                endif
                            
                                if exists("g:netrw_ftpextracmd")
                                 keepj put =g:netrw_ftpextracmd
                            "     call Decho("filter input: ".getline('$'))
                                endif
                                for fname in fnamelist
                                 keepj call setline(line("$")+1,'get "'.fname.'"')
                                endfor
                            "    call Decho("filter input: ".getline('$'))
                            
                                " perform ftp:
                                " -i       : turns off interactive prompting from ftp
                                " -n  unix : DON'T use <.netrc>, even though it exists
                                " -n  win32: quit being obnoxious about password
                                keepj norm! 1Gdd
                            "    call Decho("executing: %!".s:netrw_ftp_cmd." ".g:netrw_ftp_options)
                                exe s:netrw_silentxfer."%!".s:netrw_ftp_cmd." ".g:netrw_ftp_options
                                " If the result of the ftp operation isn't blank, show an error message (tnx to Doug Claar)
                                if getline(1) !~ "^$"
                            "     call Decho("error<".getline(1).">")
                                 if !exists("g:netrw_quiet")
                                  keepj call netrw#ErrorMsg(s:ERROR,getline(1),5)
                                 endif
                                endif
                               elseif !exists("b:netrw_method") || b:netrw_method < 0
                            "    call Dfunc("netrw#NetrwObtain : unsupported method")
                                return
                               endif
                            
                               " restore status line
                               if type(a:fname) == 1 && exists("s:netrw_users_stl")
                                keepj call s:SetupNetrwStatusLine(s:netrw_users_stl)
                               endif
                            
                              endif
                            
                              " cleanup
                              if exists("tmpbufnr")
                               if bufnr("%") != tmpbufnr
                                exe tmpbufnr."bw!"
                               else
                                q!
                               endif
                              endif
                            
                            "  call Dret("netrw#NetrwObtain")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " NetrwStatusLine: {{{2
    1              0.000002 fun! NetrwStatusLine()
                            
                            " vvv NetrwStatusLine() debugging vvv
                            "  let g:stlmsg=""
                            "  if !exists("w:netrw_explore_bufnr")
                            "   let g:stlmsg="!X<explore_bufnr>"
                            "  elseif w:netrw_explore_bufnr != bufnr("%")
                            "   let g:stlmsg="explore_bufnr!=".bufnr("%")
                            "  endif
                            "  if !exists("w:netrw_explore_line")
                            "   let g:stlmsg=" !X<explore_line>"
                            "  elseif w:netrw_explore_line != line(".")
                            "   let g:stlmsg=" explore_line!={line(.)<".line(".").">"
                            "  endif
                            "  if !exists("w:netrw_explore_list")
                            "   let g:stlmsg=" !X<explore_list>"
                            "  endif
                            " ^^^ NetrwStatusLine() debugging ^^^
                            
                              if !exists("w:netrw_explore_bufnr") || w:netrw_explore_bufnr != bufnr("%") || !exists("w:netrw_explore_line") || w:netrw_explore_line != line(".") || !exists("w:netrw_explore_list")
                               " restore user's status line
                               let &stl        = s:netrw_users_stl
                               let &laststatus = s:netrw_users_ls
                               if exists("w:netrw_explore_bufnr")|unlet w:netrw_explore_bufnr|endif
                               if exists("w:netrw_explore_line") |unlet w:netrw_explore_line |endif
                               return ""
                              else
                               return "Match ".w:netrw_explore_mtchcnt." of ".w:netrw_explore_listlen
                              endif
                            endfun
                            
                            " ---------------------------------------------------------------------
                            "  Netrw Transfer Functions: {{{1
                            " ===============================
                            
                            " ------------------------------------------------------------------------
                            " netrw#NetRead: responsible for reading a file over the net {{{2
                            "   mode: =0 read remote file and insert before current line
                            "         =1 read remote file and insert after current line
                            "         =2 replace with remote file
                            "         =3 obtain file, but leave in temporary format
    1              0.000003 fun! netrw#NetRead(mode,...)
                            "  call Dfunc("netrw#NetRead(mode=".a:mode.",...) a:0=".a:0." ".g:loaded_netrw.((a:0 > 0)? " a:1<".a:1.">" : ""))
                            
                              " NetRead: save options {{{3
                              call s:NetrwOptionSave("w:")
                              call s:NetrwSafeOptions()
                              call s:RestoreCursorline()
                            
                              " NetRead: interpret mode into a readcmd {{{3
                              if     a:mode == 0 " read remote file before current line
                               let readcmd = "0r"
                              elseif a:mode == 1 " read file after current line
                               let readcmd = "r"
                              elseif a:mode == 2 " replace with remote file
                               let readcmd = "%r"
                              elseif a:mode == 3 " skip read of file (leave as temporary)
                               let readcmd = "t"
                              else
                               exe a:mode
                               let readcmd = "r"
                              endif
                              let ichoice = (a:0 == 0)? 0 : 1
                            "  call Decho("readcmd<".readcmd."> ichoice=".ichoice)
                            
                              " NetRead: get temporary filename {{{3
                              let tmpfile= s:GetTempfile("")
                              if tmpfile == ""
                            "   call Dret("netrw#NetRead : unable to get a tempfile!")
                               return
                              endif
                            
                              while ichoice <= a:0
                            
                               " attempt to repeat with previous host-file-etc
                               if exists("b:netrw_lastfile") && a:0 == 0
                            "    call Decho("using b:netrw_lastfile<" . b:netrw_lastfile . ">")
                                let choice = b:netrw_lastfile
                                let ichoice= ichoice + 1
                            
                               else
                                exe "let choice= a:" . ichoice
                            "    call Decho("no lastfile: choice<" . choice . ">")
                            
                                if match(choice,"?") == 0
                                 " give help
                                 echomsg 'NetRead Usage:'
                                 echomsg ':Nread machine:path                         uses rcp'
                                 echomsg ':Nread "machine path"                       uses ftp   with <.netrc>'
                                 echomsg ':Nread "machine id password path"           uses ftp'
                                 echomsg ':Nread dav://machine[:port]/path            uses cadaver'
                                 echomsg ':Nread fetch://machine/path                 uses fetch'
                                 echomsg ':Nread ftp://[user@]machine[:port]/path     uses ftp   autodetects <.netrc>'
                                 echomsg ':Nread http://[user@]machine/path           uses http  wget'
                                 echomsg ':Nread rcp://[user@]machine/path            uses rcp'
                                 echomsg ':Nread rsync://machine[:port]/path          uses rsync'
                                 echomsg ':Nread scp://[user@]machine[[:#]port]/path  uses scp'
                                 echomsg ':Nread sftp://[user@]machine[[:#]port]/path uses sftp'
                                 sleep 4
                                 break
                            
                                elseif match(choice,'^"') != -1
                                 " Reconstruct Choice if choice starts with '"'
                            "     call Decho("reconstructing choice")
                                 if match(choice,'"$') != -1
                                  " case "..."
                                  let choice= strpart(choice,1,strlen(choice)-2)
                                 else
                                   "  case "... ... ..."
                                  let choice      = strpart(choice,1,strlen(choice)-1)
                                  let wholechoice = ""
                            
                                  while match(choice,'"$') == -1
                                   let wholechoice = wholechoice . " " . choice
                                   let ichoice     = ichoice + 1
                                   if ichoice > a:0
                                   	if !exists("g:netrw_quiet")
                            	 call netrw#ErrorMsg(s:ERROR,"Unbalanced string in filename '". wholechoice ."'",3)
                            	endif
                            "        call Dret("netrw#NetRead :2 getcwd<".getcwd().">")
                                    return
                                   endif
                                   let choice= a:{ichoice}
                                  endwhile
                                  let choice= strpart(wholechoice,1,strlen(wholechoice)-1) . " " . strpart(choice,0,strlen(choice)-1)
                                 endif
                                endif
                               endif
                            
                            "   call Decho("choice<" . choice . ">")
                               let ichoice= ichoice + 1
                            
                               " NetRead: Determine method of read (ftp, rcp, etc) {{{3
                               call s:NetrwMethod(choice)
                               if !exists("b:netrw_method") || b:netrw_method < 0
                            "    call Dfunc("netrw#NetRead : unsupported method")
                                return
                               endif
                               let tmpfile= s:GetTempfile(b:netrw_fname) " apply correct suffix
                            
                               " Check if NetrwBrowse() should be handling this request
                            "   call Decho("checking if NetrwBrowse() should handle choice<".choice."> with netrw_list_cmd<".g:netrw_list_cmd.">")
                               if choice =~ "^.*[\/]$" && b:netrw_method != 5 && choice !~ '^https\=://'
                            "    call Decho("yes, choice matches '^.*[\/]$'")
                                keepj call s:NetrwBrowse(0,choice)
                            "    call Dret("netrw#NetRead :3 getcwd<".getcwd().">")
                                return
                               endif
                            
                               " ============
                               " NetRead: Perform Protocol-Based Read {{{3
                               " ===========================
                               if exists("g:netrw_silent") && g:netrw_silent == 0 && &ch >= 1
                                echo "(netrw) Processing your read request..."
                               endif
                            
                               ".........................................
                               " NetRead: (rcp)  NetRead Method #1 {{{3
                               if  b:netrw_method == 1 " read with rcp
                            "    call Decho("read via rcp (method #1)")
                               " ER: nothing done with g:netrw_uid yet?
                               " ER: on Win2K" rcp machine[.user]:file tmpfile
                               " ER: if machine contains '.' adding .user is required (use $USERNAME)
                               " ER: the tmpfile is full path: rcp sees C:\... as host C
                               if s:netrw_has_nt_rcp == 1
                                if exists("g:netrw_uid") &&	( g:netrw_uid != "" )
                                 let uid_machine = g:netrw_machine .'.'. g:netrw_uid
                                else
                                 " Any way needed it machine contains a '.'
                                 let uid_machine = g:netrw_machine .'.'. $USERNAME
                                endif
                               else
                                if exists("g:netrw_uid") &&	( g:netrw_uid != "" )
                                 let uid_machine = g:netrw_uid .'@'. g:netrw_machine
                                else
                                 let uid_machine = g:netrw_machine
                                endif
                               endif
                            "   call Decho("executing: !".g:netrw_rcp_cmd." ".s:netrw_rcpmode." ".shellescape(uid_machine.":".b:netrw_fname,1)." ".shellescape(tmpfile,1))
                               exe s:netrw_silentxfer."!".g:netrw_rcp_cmd." ".s:netrw_rcpmode." ".shellescape(uid_machine.":".b:netrw_fname,1)." ".shellescape(tmpfile,1)
                               let result           = s:NetrwGetFile(readcmd, tmpfile, b:netrw_method)
                               let b:netrw_lastfile = choice
                            
                               ".........................................
                               " NetRead: (ftp + <.netrc>)  NetRead Method #2 {{{3
                               elseif b:netrw_method  == 2		" read with ftp + <.netrc>
                            "     call Decho("read via ftp+.netrc (method #2)")
                                 let netrw_fname= b:netrw_fname
                                 keepj call s:SaveBufVars()|new|keepj call s:RestoreBufVars()
                                 let filtbuf= bufnr("%")
                                 setl ff=unix
                                 keepj put =g:netrw_ftpmode
                            "     call Decho("filter input: ".getline(line("$")))
                                 if exists("g:netrw_ftpextracmd")
                                  keepj put =g:netrw_ftpextracmd
                            "      call Decho("filter input: ".getline(line("$")))
                                 endif
                                 call setline(line("$")+1,'get "'.netrw_fname.'" '.tmpfile)
                            "     call Decho("filter input: ".getline(line("$")))
                                 if exists("g:netrw_port") && g:netrw_port != ""
                            "      call Decho("executing: %!".s:netrw_ftp_cmd." -i ".shellescape(g:netrw_machine,1)." ".shellescape(g:netrw_port,1))
                                  exe s:netrw_silentxfer."%!".s:netrw_ftp_cmd." -i ".shellescape(g:netrw_machine,1)." ".shellescape(g:netrw_port,1)
                                 else
                            "      call Decho("executing: %!".s:netrw_ftp_cmd." -i ".shellescape(g:netrw_machine,1))
                                  exe s:netrw_silentxfer."%!".s:netrw_ftp_cmd." -i ".shellescape(g:netrw_machine,1)
                                 endif
                                 " If the result of the ftp operation isn't blank, show an error message (tnx to Doug Claar)
                                 if getline(1) !~ "^$" && !exists("g:netrw_quiet") && getline(1) !~ '^Trying '
                                  let debugkeep = &debug
                                  setl debug=msg
                                  keepj call netrw#ErrorMsg(s:ERROR,getline(1),4)
                                  let &debug    = debugkeep
                                 endif
                                 call s:SaveBufVars()
                                 bd!
                                 if bufname("%") == "" && getline("$") == "" && line('$') == 1
                                  " needed when one sources a file in a nolbl setting window via ftp
                                  q!
                                 endif
                                 call s:RestoreBufVars()
                                 let result           = s:NetrwGetFile(readcmd, tmpfile, b:netrw_method)
                                 let b:netrw_lastfile = choice
                            
                               ".........................................
                               " NetRead: (ftp + machine,id,passwd,filename)  NetRead Method #3 {{{3
                               elseif b:netrw_method == 3		" read with ftp + machine, id, passwd, and fname
                                " Construct execution string (four lines) which will be passed through filter
                            "    call Decho("read via ftp+mipf (method #3)")
                                let netrw_fname= escape(b:netrw_fname,g:netrw_fname_escape)
                                keepj call s:SaveBufVars()|new|keepj call s:RestoreBufVars()
                                let filtbuf= bufnr("%")
                                setl ff=unix
                                if exists("g:netrw_port") && g:netrw_port != ""
                                 keepj put ='open '.g:netrw_machine.' '.g:netrw_port
                            "     call Decho("filter input: ".getline('.'))
                                else
                                 keepj put ='open '.g:netrw_machine
                            "     call Decho("filter input: ".getline('.'))
                                endif
                            
                                if exists("g:netrw_uid") && g:netrw_uid != ""
                                 if exists("g:netrw_ftp") && g:netrw_ftp == 1
                                  keepj put =g:netrw_uid
                            "       call Decho("filter input: ".getline('.'))
                                  if exists("s:netrw_passwd")
                                   keepj put ='\"'.s:netrw_passwd.'\"'
                                  endif
                            "      call Decho("filter input: ".getline('.'))
                                 elseif exists("s:netrw_passwd")
                                  keepj put ='user \"'.g:netrw_uid.'\" \"'.s:netrw_passwd.'\"'
                            "      call Decho("filter input: ".getline('.'))
                                 endif
                                endif
                            
                                if exists("g:netrw_ftpmode") && g:netrw_ftpmode != ""
                                 keepj put =g:netrw_ftpmode
                            "     call Decho("filter input: ".getline('.'))
                                endif
                                if exists("g:netrw_ftpextracmd")
                                 keepj put =g:netrw_ftpextracmd
                            "     call Decho("filter input: ".getline('.'))
                                endif
                                keepj put ='get \"'.netrw_fname.'\" '.tmpfile
                            "    call Decho("filter input: ".getline('.'))
                            
                                " perform ftp:
                                " -i       : turns off interactive prompting from ftp
                                " -n  unix : DON'T use <.netrc>, even though it exists
                                " -n  win32: quit being obnoxious about password
                                keepj norm! 1Gdd
                            "    call Decho("executing: %!".s:netrw_ftp_cmd." ".g:netrw_ftp_options)
                                exe s:netrw_silentxfer."%!".s:netrw_ftp_cmd." ".g:netrw_ftp_options
                                " If the result of the ftp operation isn't blank, show an error message (tnx to Doug Claar)
                                if getline(1) !~ "^$"
                            "     call Decho("error<".getline(1).">")
                                 if !exists("g:netrw_quiet")
                                  call netrw#ErrorMsg(s:ERROR,getline(1),5)
                                 endif
                                endif
                                call s:SaveBufVars()|bd!|call s:RestoreBufVars()
                                let result           = s:NetrwGetFile(readcmd, tmpfile, b:netrw_method)
                                let b:netrw_lastfile = choice
                            
                               ".........................................
                               " NetRead: (scp) NetRead Method #4 {{{3
                               elseif     b:netrw_method  == 4	" read with scp
                            "    call Decho("read via scp (method #4)")
                                if exists("g:netrw_port") && g:netrw_port != ""
                                 let useport= " ".g:netrw_scpport." ".g:netrw_port
                                else
                                 let useport= ""
                                endif
                            "    call Decho("exe ".s:netrw_silentxfer."!".g:netrw_scp_cmd.useport." ".shellescape(g:netrw_machine.":".b:netrw_fname,1)." ".shellescape(tmpfile,1))
                                exe s:netrw_silentxfer."!".g:netrw_scp_cmd.useport." ".shellescape(g:netrw_machine.":".b:netrw_fname,1)." ".shellescape(tmpfile,1)
                                let result           = s:NetrwGetFile(readcmd, tmpfile, b:netrw_method)
                                let b:netrw_lastfile = choice
                            
                               ".........................................
                               " NetRead: (http) NetRead Method #5 (wget) {{{3
                               elseif     b:netrw_method  == 5
                            "    call Decho("read via http (method #5)")
                                if g:netrw_http_cmd == ""
                                 if !exists("g:netrw_quiet")
                                  call netrw#ErrorMsg(s:ERROR,"neither the wget nor the fetch command is available",6)
                                 endif
                            "     call Dret("netrw#NetRead :4 getcwd<".getcwd().">")
                                 return
                                endif
                            
                                if match(b:netrw_fname,"#") == -1 || exists("g:netrw_http_xcmd")
                                 " using g:netrw_http_cmd (usually elinks, links, curl, wget, or fetch)
                            "     call Decho('using '.g:netrw_http_cmd.' (# not in b:netrw_fname<'.b:netrw_fname.">)")
                                 if exists("g:netrw_http_xcmd")
                            "      call Decho("exe ".s:netrw_silentxfer."!".g:netrw_http_cmd." ".shellescape("http://".g:netrw_machine.b:netrw_fname,1)." ".g:netrw_http_xcmd." ".shellescape(tmpfile,1))
                                  exe s:netrw_silentxfer."!".g:netrw_http_cmd." ".shellescape("http://".g:netrw_machine.b:netrw_fname,1)." ".g:netrw_http_xcmd." ".shellescape(tmpfile,1)
                                 else
                            "      call Decho("exe ".s:netrw_silentxfer."!".g:netrw_http_cmd." ".shellescape(tmpfile,1)." ".shellescape("http://".g:netrw_machine.b:netrw_fname,1))
                                  exe s:netrw_silentxfer."!".g:netrw_http_cmd." ".shellescape(tmpfile,1)." ".shellescape("http://".g:netrw_machine.b:netrw_fname,1)
                                 endif
                                 let result = s:NetrwGetFile(readcmd, tmpfile, b:netrw_method)
                            
                                else
                                 " wget/curl/fetch plus a jump to an in-page marker (ie. http://abc/def.html#aMarker)
                            "     call Decho("wget/curl plus jump (# in b:netrw_fname<".b:netrw_fname.">)")
                                 let netrw_html= substitute(b:netrw_fname,"#.*$","","")
                                 let netrw_tag = substitute(b:netrw_fname,"^.*#","","")
                            "     call Decho("netrw_html<".netrw_html.">")
                            "     call Decho("netrw_tag <".netrw_tag.">")
                            "     call Decho("exe ".s:netrw_silentxfer."!".g:netrw_http_cmd." ".shellescape(tmpfile,1)." ".shellescape("http://".g:netrw_machine.netrw_html,1))
                                 exe s:netrw_silentxfer."!".g:netrw_http_cmd." ".shellescape(tmpfile,1)." ".shellescape("http://".g:netrw_machine.netrw_html,1)
                                 let result = s:NetrwGetFile(readcmd, tmpfile, b:netrw_method)
                            "     call Decho('<\s*a\s*name=\s*"'.netrw_tag.'"/')
                                 exe 'keepj norm! 1G/<\s*a\s*name=\s*"'.netrw_tag.'"/'."\<CR>"
                                endif
                                let b:netrw_lastfile = choice
                            "    call Decho("(NetRead) setl ro")
                                setl ro
                            
                               ".........................................
                               " NetRead: (dav) NetRead Method #6 {{{3
                               elseif     b:netrw_method  == 6
                            "    call Decho("read via cadaver (method #6)")
                            
                                if !executable(g:netrw_dav_cmd)
                                 call netrw#ErrorMsg(s:ERROR,g:netrw_dav_cmd." is not executable",73)
                            "     call Dret("netrw#NetRead : ".g:netrw_dav_cmd." not executable")
                                 return
                                endif
                                if g:netrw_dav_cmd =~ "curl"
                            "     call Decho("exe ".s:netrw_silentxfer."!".g:netrw_dav_cmd." ".shellescape("dav://".g:netrw_machine.b:netrw_fname,1)." ".shellescape(tmpfile,1))
                                 exe s:netrw_silentxfer."!".g:netrw_dav_cmd." ".shellescape("dav://".g:netrw_machine.b:netrw_fname,1)." ".shellescape(tmpfile,1)
                                else
                                 " Construct execution string (four lines) which will be passed through filter
                                 let netrw_fname= escape(b:netrw_fname,g:netrw_fname_escape)
                                 new
                                 setl ff=unix
                                 if exists("g:netrw_port") && g:netrw_port != ""
                                  keepj put ='open '.g:netrw_machine.' '.g:netrw_port
                                 else
                                  keepj put ='open '.g:netrw_machine
                                 endif
                                 if exists("g:netrw_uid") && exists("s:netrw_passwd") && g:netrw_uid != ""
                                  keepj put ='user '.g:netrw_uid.' '.s:netrw_passwd
                                 endif
                                 keepj put ='get '.netrw_fname.' '.tmpfile
                                 keepj put ='quit'
                            
                                 " perform cadaver operation:
                                 keepj norm! 1Gdd
                            "    call Decho("executing: %!".g:netrw_dav_cmd)
                                 exe s:netrw_silentxfer."%!".g:netrw_dav_cmd
                                 bd!
                                endif
                                let result           = s:NetrwGetFile(readcmd, tmpfile, b:netrw_method)
                                let b:netrw_lastfile = choice
                            
                               ".........................................
                               " NetRead: (rsync) NetRead Method #7 {{{3
                               elseif     b:netrw_method  == 7
                            "    call Decho("read via rsync (method #7)")
                            "    call Decho("exe ".s:netrw_silentxfer."!".g:netrw_rsync_cmd." ".shellescape(g:netrw_machine.":".b:netrw_fname,1)." ".shellescape(tmpfile,1))
                                exe s:netrw_silentxfer."!".g:netrw_rsync_cmd." ".shellescape(g:netrw_machine.":".b:netrw_fname,1)." ".shellescape(tmpfile,1)
                                let result		 = s:NetrwGetFile(readcmd,tmpfile, b:netrw_method)
                                let b:netrw_lastfile = choice
                            
                               ".........................................
                               " NetRead: (fetch) NetRead Method #8 {{{3
                               "    fetch://[user@]host[:http]/path
                               elseif     b:netrw_method  == 8
                            "    call Decho("read via fetch (method #8)")
                                if g:netrw_fetch_cmd == ""
                                 if !exists("g:netrw_quiet")
                                  keepj call netrw#ErrorMsg(s:ERROR,"fetch command not available",7)
                                 endif
                            "     call Dret("NetRead")
                                 return
                                endif
                                if exists("g:netrw_option") && g:netrw_option == ":https\="
                                 let netrw_option= "http"
                                else
                                 let netrw_option= "ftp"
                                endif
                            "    call Decho("read via fetch for ".netrw_option)
                            
                                if exists("g:netrw_uid") && g:netrw_uid != "" && exists("s:netrw_passwd") && s:netrw_passwd != ""
                            "     call Decho("exe ".s:netrw_silentxfer."!".g:netrw_fetch_cmd." ".shellescape(tmpfile,1)." ".shellescape(netrw_option."://".g:netrw_uid.':'.s:netrw_passwd.'@'.g:netrw_machine."/".b:netrw_fname,1))
                                 exe s:netrw_silentxfer."!".g:netrw_fetch_cmd." ".shellescape(tmpfile,1)." ".shellescape(netrw_option."://".g:netrw_uid.':'.s:netrw_passwd.'@'.g:netrw_machine."/".b:netrw_fname,1)
                                else
                            "     call Decho("exe ".s:netrw_silentxfer."!".g:netrw_fetch_cmd." ".shellescape(tmpfile,1)." ".shellescape(netrw_option."://".g:netrw_machine."/".b:netrw_fname,1))
                                 exe s:netrw_silentxfer."!".g:netrw_fetch_cmd." ".shellescape(tmpfile,1)." ".shellescape(netrw_option."://".g:netrw_machine."/".b:netrw_fname,1)
                                endif
                            
                                let result		= s:NetrwGetFile(readcmd,tmpfile, b:netrw_method)
                                let b:netrw_lastfile = choice
                            "    call Decho("(NetRead) setl ro")
                                setl ro
                            
                               ".........................................
                               " NetRead: (sftp) NetRead Method #9 {{{3
                               elseif     b:netrw_method  == 9
                            "    call Decho("read via sftp (method #9)")
                            "    call Decho("exe ".s:netrw_silentxfer."!".g:netrw_sftp_cmd." ".shellescape(g:netrw_machine.":".b:netrw_fname,1)." ".tmpfile)
                                exe s:netrw_silentxfer."!".g:netrw_sftp_cmd." ".shellescape(g:netrw_machine.":".b:netrw_fname,1)." ".tmpfile
                                let result		= s:NetrwGetFile(readcmd, tmpfile, b:netrw_method)
                                let b:netrw_lastfile = choice
                            
                               ".........................................
                               " NetRead: Complain {{{3
                               else
                                call netrw#ErrorMsg(s:WARNING,"unable to comply with your request<" . choice . ">",8)
                               endif
                              endwhile
                            
                              " NetRead: cleanup {{{3
                              if exists("b:netrw_method")
                            "   call Decho("cleanup b:netrw_method and b:netrw_fname")
                               unlet b:netrw_method
                               unlet b:netrw_fname
                              endif
                              if s:FileReadable(tmpfile) && tmpfile !~ '.tar.bz2$' && tmpfile !~ '.tar.gz$' && tmpfile !~ '.zip' && tmpfile !~ '.tar' && readcmd != 't' && tmpfile !~ '.tar.xz$' && tmpfile !~ '.txz'
                            "   call Decho("cleanup by deleting tmpfile<".tmpfile.">")
                               keepj call s:NetrwDelete(tmpfile)
                              endif
                              keepj call s:NetrwOptionRestore("w:")
                            
                            "  call Dret("netrw#NetRead :5 getcwd<".getcwd().">")
                            endfun
                            
                            " ------------------------------------------------------------------------
                            " netrw#NetWrite: responsible for writing a file over the net {{{2
    1              0.000003 fun! netrw#NetWrite(...) range
                            "  call Dfunc("netrw#NetWrite(a:0=".a:0.") ".g:loaded_netrw)
                            
                              " NetWrite: option handling {{{3
                              let mod= 0
                              call s:NetrwOptionSave("w:")
                              call s:NetrwSafeOptions()
                            
                              " NetWrite: Get Temporary Filename {{{3
                              let tmpfile= s:GetTempfile("")
                              if tmpfile == ""
                            "   call Dret("netrw#NetWrite : unable to get a tempfile!")
                               return
                              endif
                            
                              if a:0 == 0
                               let ichoice = 0
                              else
                               let ichoice = 1
                              endif
                            
                              let curbufname= expand("%")
                            "  call Decho("curbufname<".curbufname.">")
                              if &binary
                               " For binary writes, always write entire file.
                               " (line numbers don't really make sense for that).
                               " Also supports the writing of tar and zip files.
                            "   call Decho("(write entire file) sil exe w! ".fnameescape(v:cmdarg)." ".fnameescape(tmpfile))
                               exe "sil keepj w! ".fnameescape(v:cmdarg)." ".fnameescape(tmpfile)
                              elseif g:netrw_cygwin
                               " write (selected portion of) file to temporary
                               let cygtmpfile= substitute(tmpfile,'/cygdrive/\(.\)','\1:','')
                            "   call Decho("(write selected portion) sil exe ".a:firstline."," . a:lastline . "w! ".fnameescape(v:cmdarg)." ".fnameescape(cygtmpfile))
                               exe "sil keepj ".a:firstline."," . a:lastline . "w! ".fnameescape(v:cmdarg)." ".fnameescape(cygtmpfile)
                              else
                               " write (selected portion of) file to temporary
                            "   call Decho("(write selected portion) sil exe ".a:firstline."," . a:lastline . "w! ".fnameescape(v:cmdarg)." ".fnameescape(tmpfile))
                               exe "sil keepj ".a:firstline."," . a:lastline . "w! ".fnameescape(v:cmdarg)." ".fnameescape(tmpfile)
                              endif
                            
                              if curbufname == ""
                               " if the file is [No Name], and one attempts to Nwrite it, the buffer takes
                               " on the temporary file's name.  Deletion of the temporary file during
                               " cleanup then causes an error message.
                               0file!
                              endif
                            
                              " NetWrite: while choice loop: {{{3
                              while ichoice <= a:0
                            
                               " Process arguments: {{{4
                               " attempt to repeat with previous host-file-etc
                               if exists("b:netrw_lastfile") && a:0 == 0
                            "    call Decho("using b:netrw_lastfile<" . b:netrw_lastfile . ">")
                                let choice = b:netrw_lastfile
                                let ichoice= ichoice + 1
                               else
                                exe "let choice= a:" . ichoice
                            
                                " Reconstruct Choice if choice starts with '"'
                                if match(choice,"?") == 0
                                 echomsg 'NetWrite Usage:"'
                                 echomsg ':Nwrite machine:path                        uses rcp'
                                 echomsg ':Nwrite "machine path"                      uses ftp with <.netrc>'
                                 echomsg ':Nwrite "machine id password path"          uses ftp'
                                 echomsg ':Nwrite dav://[user@]machine/path           uses cadaver'
                                 echomsg ':Nwrite fetch://[user@]machine/path         uses fetch'
                                 echomsg ':Nwrite ftp://machine[#port]/path           uses ftp  (autodetects <.netrc>)'
                                 echomsg ':Nwrite rcp://machine/path                  uses rcp'
                                 echomsg ':Nwrite rsync://[user@]machine/path         uses rsync'
                                 echomsg ':Nwrite scp://[user@]machine[[:#]port]/path uses scp'
                                 echomsg ':Nwrite sftp://[user@]machine/path          uses sftp'
                                 sleep 4
                                 break
                            
                                elseif match(choice,"^\"") != -1
                                 if match(choice,"\"$") != -1
                                   " case "..."
                                  let choice=strpart(choice,1,strlen(choice)-2)
                                 else
                                  "  case "... ... ..."
                                  let choice      = strpart(choice,1,strlen(choice)-1)
                                  let wholechoice = ""
                            
                                  while match(choice,"\"$") == -1
                                   let wholechoice= wholechoice . " " . choice
                                   let ichoice    = ichoice + 1
                                   if choice > a:0
                                   	if !exists("g:netrw_quiet")
                            	 call netrw#ErrorMsg(s:ERROR,"Unbalanced string in filename '". wholechoice ."'",13)
                            	endif
                            "        call Dret("netrw#NetWrite")
                                    return
                                   endif
                                   let choice= a:{ichoice}
                                  endwhile
                                  let choice= strpart(wholechoice,1,strlen(wholechoice)-1) . " " . strpart(choice,0,strlen(choice)-1)
                                 endif
                                endif
                               endif
                               let ichoice= ichoice + 1
                            "   call Decho("choice<" . choice . "> ichoice=".ichoice)
                            
                               " Determine method of write (ftp, rcp, etc) {{{4
                               keepj call s:NetrwMethod(choice)
                               if !exists("b:netrw_method") || b:netrw_method < 0
                            "    call Dfunc("netrw#NetWrite : unsupported method")
                                return
                               endif
                            
                               " =============
                               " NetWrite: Perform Protocol-Based Write {{{3
                               " ============================
                               if exists("g:netrw_silent") && g:netrw_silent == 0 && &ch >= 1
                                echo "(netrw) Processing your write request..."
                            "    call Decho("(netrw) Processing your write request...")
                               endif
                            
                               ".........................................
                               " NetWrite: (rcp) NetWrite Method #1 {{{3
                               if  b:netrw_method == 1
                            "    call Decho("write via rcp (method #1)")
                                if s:netrw_has_nt_rcp == 1
                                 if exists("g:netrw_uid") &&  ( g:netrw_uid != "" )
                                  let uid_machine = g:netrw_machine .'.'. g:netrw_uid
                                 else
                                  let uid_machine = g:netrw_machine .'.'. $USERNAME
                                 endif
                                else
                                 if exists("g:netrw_uid") &&  ( g:netrw_uid != "" )
                                  let uid_machine = g:netrw_uid .'@'. g:netrw_machine
                                 else
                                  let uid_machine = g:netrw_machine
                                 endif
                                endif
                            "    call Decho("executing: !".g:netrw_rcp_cmd." ".s:netrw_rcpmode." ".shellescape(tmpfile,1)." ".shellescape(uid_machine.":".b:netrw_fname,1))
                                exe s:netrw_silentxfer."!".g:netrw_rcp_cmd." ".s:netrw_rcpmode." ".shellescape(tmpfile,1)." ".shellescape(uid_machine.":".b:netrw_fname,1)
                                let b:netrw_lastfile = choice
                            
                               ".........................................
                               " NetWrite: (ftp + <.netrc>) NetWrite Method #2 {{{3
                               elseif b:netrw_method == 2
                            "    call Decho("write via ftp+.netrc (method #2)")
                                let netrw_fname = b:netrw_fname
                            
                                " formerly just a "new...bd!", that changed the window sizes when equalalways.  Using enew workaround instead
                                let bhkeep      = &l:bh
                                let curbuf      = bufnr("%")
                                setl bh=hide
                                keepalt enew
                            
                            "    call Decho("filter input window#".winnr())
                                setl ff=unix
                                keepj put =g:netrw_ftpmode
                            "    call Decho("filter input: ".getline('$'))
                                if exists("g:netrw_ftpextracmd")
                                 keepj put =g:netrw_ftpextracmd
                            "     call Decho("filter input: ".getline("$"))
                                endif
                                keepj call setline(line("$")+1,'put "'.tmpfile.'" "'.netrw_fname.'"')
                            "    call Decho("filter input: ".getline("$"))
                                if exists("g:netrw_port") && g:netrw_port != ""
                            "     call Decho("executing: %!".s:netrw_ftp_cmd." -i ".shellescape(g:netrw_machine,1)." ".shellescape(g:netrw_port,1))
                                 exe s:netrw_silentxfer."%!".s:netrw_ftp_cmd." -i ".shellescape(g:netrw_machine,1)." ".shellescape(g:netrw_port,1)
                                else
                            "     call Decho("filter input window#".winnr())
                            "     call Decho("executing: %!".s:netrw_ftp_cmd." -i ".shellescape(g:netrw_machine,1))
                                 exe s:netrw_silentxfer."%!".s:netrw_ftp_cmd." -i ".shellescape(g:netrw_machine,1)
                                endif
                                " If the result of the ftp operation isn't blank, show an error message (tnx to Doug Claar)
                                if getline(1) !~ "^$"
                                 if !exists("g:netrw_quiet")
                                  keepj call netrw#ErrorMsg(s:ERROR,getline(1),14)
                                 endif
                                 let mod=1
                                endif
                            
                                " remove enew buffer (quietly)
                                let filtbuf= bufnr("%")
                                exe curbuf."b!"
                                let &l:bh            = bhkeep
                                exe filtbuf."bw!"
                            
                                let b:netrw_lastfile = choice
                            
                               ".........................................
                               " NetWrite: (ftp + machine, id, passwd, filename) NetWrite Method #3 {{{3
                               elseif b:netrw_method == 3
                                " Construct execution string (three or more lines) which will be passed through filter
                            "    call Decho("read via ftp+mipf (method #3)")
                                let netrw_fname = b:netrw_fname
                                let bhkeep      = &l:bh
                            
                                " formerly just a "new...bd!", that changed the window sizes when equalalways.  Using enew workaround instead
                                let curbuf      = bufnr("%")
                                setl bh=hide
                                keepalt enew
                                setl ff=unix
                            
                                if exists("g:netrw_port") && g:netrw_port != ""
                                 keepj put ='open '.g:netrw_machine.' '.g:netrw_port
                            "     call Decho("filter input: ".getline('.'))
                                else
                                 keepj put ='open '.g:netrw_machine
                            "     call Decho("filter input: ".getline('.'))
                                endif
                                if exists("g:netrw_uid") && g:netrw_uid != ""
                                 if exists("g:netrw_ftp") && g:netrw_ftp == 1
                                  keepj put =g:netrw_uid
                            "      call Decho("filter input: ".getline('.'))
                                  if exists("s:netrw_passwd") && s:netrw_passwd != ""
                                   keepj put ='\"'.s:netrw_passwd.'\"'
                                  endif
                            "      call Decho("filter input: ".getline('.'))
                                 elseif exists("s:netrw_passwd") && s:netrw_passwd != ""
                                  keepj put ='user \"'.g:netrw_uid.'\" \"'.s:netrw_passwd.'\"'
                            "      call Decho("filter input: ".getline('.'))
                                 endif
                                endif
                                keepj put =g:netrw_ftpmode
                            "    call Decho("filter input: ".getline('$'))
                                if exists("g:netrw_ftpextracmd")
                                 keepj put =g:netrw_ftpextracmd
                            "     call Decho("filter input: ".getline("$"))
                                endif
                                keepj put ='put \"'.tmpfile.'\" \"'.netrw_fname.'\"'
                            "    call Decho("filter input: ".getline('.'))
                                " save choice/id/password for future use
                                let b:netrw_lastfile = choice
                            
                                " perform ftp:
                                " -i       : turns off interactive prompting from ftp
                                " -n  unix : DON'T use <.netrc>, even though it exists
                                " -n  win32: quit being obnoxious about password
                                keepj norm! 1Gdd
                            "    call Decho("executing: %!".s:netrw_ftp_cmd." ".g:netrw_ftp_options)
                                exe s:netrw_silentxfer."%!".s:netrw_ftp_cmd." ".g:netrw_ftp_options
                                " If the result of the ftp operation isn't blank, show an error message (tnx to Doug Claar)
                                if getline(1) !~ "^$"
                                 if  !exists("g:netrw_quiet")
                                  call netrw#ErrorMsg(s:ERROR,getline(1),15)
                                 endif
                                 let mod=1
                                endif
                            
                                " remove enew buffer (quietly)
                                let filtbuf= bufnr("%")
                                exe curbuf."b!"
                                let &l:bh= bhkeep
                                exe filtbuf."bw!"
                            
                               ".........................................
                               " NetWrite: (scp) NetWrite Method #4 {{{3
                               elseif     b:netrw_method == 4
                            "    call Decho("write via scp (method #4)")
                                if exists("g:netrw_port") && g:netrw_port != ""
                                 let useport= " ".g:netrw_scpport." ".fnameescape(g:netrw_port)
                                else
                                 let useport= ""
                                endif
                            "    call Decho("exe ".s:netrw_silentxfer."!".g:netrw_scp_cmd.useport." ".shellescape(tmpfile,1)." ".shellescape(g:netrw_machine.":".b:netrw_fname,1))
                                exe s:netrw_silentxfer."!".g:netrw_scp_cmd.useport." ".shellescape(tmpfile,1)." ".shellescape(g:netrw_machine.":".b:netrw_fname,1)
                                let b:netrw_lastfile = choice
                            
                               ".........................................
                               " NetWrite: (http) NetWrite Method #5 {{{3
                               elseif     b:netrw_method == 5
                            "    call Decho("write via http (method #5)")
                                if !exists("g:netrw_quiet")
                                 call netrw#ErrorMsg(s:ERROR,"currently <netrw.vim> does not support writing using http:",16)
                                endif
                            
                               ".........................................
                               " NetWrite: (dav) NetWrite Method #6 (cadaver) {{{3
                               elseif     b:netrw_method == 6
                            "    call Decho("write via cadaver (method #6)")
                            
                                " Construct execution string (four lines) which will be passed through filter
                                let netrw_fname = escape(b:netrw_fname,g:netrw_fname_escape)
                                let bhkeep      = &l:bh
                            
                                " formerly just a "new...bd!", that changed the window sizes when equalalways.  Using enew workaround instead
                                let curbuf      = bufnr("%")
                                setl bh=hide
                                keepalt enew
                            
                                setl ff=unix
                                if exists("g:netrw_port") && g:netrw_port != ""
                                 keepj put ='open '.g:netrw_machine.' '.g:netrw_port
                                else
                                 keepj put ='open '.g:netrw_machine
                                endif
                                if exists("g:netrw_uid") && exists("s:netrw_passwd") && g:netrw_uid != ""
                                 keepj put ='user '.g:netrw_uid.' '.s:netrw_passwd
                                endif
                                keepj put ='put '.tmpfile.' '.netrw_fname
                            
                                " perform cadaver operation:
                                keepj norm! 1Gdd
                            "    call Decho("executing: %!".g:netrw_dav_cmd)
                                exe s:netrw_silentxfer."%!".g:netrw_dav_cmd
                            
                                " remove enew buffer (quietly)
                                let filtbuf= bufnr("%")
                                exe curbuf."b!"
                                let &l:bh            = bhkeep
                                exe filtbuf."bw!"
                            
                                let b:netrw_lastfile = choice
                            
                               ".........................................
                               " NetWrite: (rsync) NetWrite Method #7 {{{3
                               elseif     b:netrw_method == 7
                            "    call Decho("write via rsync (method #7)")
                            "    call Decho("executing: !".g:netrw_rsync_cmd." ".shellescape(tmpfile,1)." ".shellescape(g:netrw_machine.":".b:netrw_fname,1))
                                exe s:netrw_silentxfer."!".g:netrw_rsync_cmd." ".shellescape(tmpfile,1)." ".shellescape(g:netrw_machine.":".b:netrw_fname,1)
                                let b:netrw_lastfile = choice
                            
                               ".........................................
                               " NetWrite: (sftp) NetWrite Method #9 {{{3
                               elseif     b:netrw_method == 9
                            "    call Decho("write via sftp (method #9)")
                                let netrw_fname= escape(b:netrw_fname,g:netrw_fname_escape)
                                if exists("g:netrw_uid") &&  ( g:netrw_uid != "" )
                                 let uid_machine = g:netrw_uid .'@'. g:netrw_machine
                                else
                                 let uid_machine = g:netrw_machine
                                endif
                            
                                " formerly just a "new...bd!", that changed the window sizes when equalalways.  Using enew workaround instead
                                let bhkeep = &l:bh
                                let curbuf = bufnr("%")
                                setl bh=hide
                                keepalt enew
                            
                                setl ff=unix
                                call setline(1,'put "'.escape(tmpfile,'\').'" '.netrw_fname)
                            "    call Decho("filter input: ".getline('.'))
                            "    call Decho("executing: %!".g:netrw_sftp_cmd.' '.shellescape(uid_machine,1))
                                let sftpcmd= substitute(g:netrw_sftp_cmd,"%TEMPFILE%",escape(tmpfile,'\'),"g")
                                exe s:netrw_silentxfer."%!".sftpcmd.' '.shellescape(uid_machine,1)
                                let filtbuf= bufnr("%")
                                exe curbuf."b!"
                                let &l:bh            = bhkeep
                                exe filtbuf."bw!"
                                let b:netrw_lastfile = choice
                            
                               ".........................................
                               " NetWrite: Complain {{{3
                               else
                                call netrw#ErrorMsg(s:WARNING,"unable to comply with your request<" . choice . ">",17)
                                let leavemod= 1
                               endif
                              endwhile
                            
                              " NetWrite: Cleanup: {{{3
                            "  call Decho("cleanup")
                              if s:FileReadable(tmpfile)
                            "   call Decho("tmpfile<".tmpfile."> readable, will now delete it")
                               call s:NetrwDelete(tmpfile)
                              endif
                              call s:NetrwOptionRestore("w:")
                            
                              if a:firstline == 1 && a:lastline == line("$")
                               " restore modifiability; usually equivalent to set nomod
                               let &mod= mod
                            "   call Decho("(NetWrite)  ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
                              elseif !exists("leavemod")
                               " indicate that the buffer has not been modified since last written
                            "   call Decho("(NetWrite) set nomod")
                               set nomod
                            "   call Decho("(NetWrite)  ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
                              endif
                            
                            "  call Dret("netrw#NetWrite")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " netrw#NetSource: source a remotely hosted vim script {{{2
                            " uses NetRead to get a copy of the file into a temporarily file,
                            "              then sources that file,
                            "              then removes that file.
    1              0.000004 fun! netrw#NetSource(...)
                            "  call Dfunc("netrw#NetSource() a:0=".a:0)
                              if a:0 > 0 && a:1 == '?'
                               " give help
                               echomsg 'NetSource Usage:'
                               echomsg ':Nsource dav://machine[:port]/path            uses cadaver'
                               echomsg ':Nsource fetch://machine/path                 uses fetch'
                               echomsg ':Nsource ftp://[user@]machine[:port]/path     uses ftp   autodetects <.netrc>'
                               echomsg ':Nsource http[s]://[user@]machine/path        uses http  wget'
                               echomsg ':Nsource rcp://[user@]machine/path            uses rcp'
                               echomsg ':Nsource rsync://machine[:port]/path          uses rsync'
                               echomsg ':Nsource scp://[user@]machine[[:#]port]/path  uses scp'
                               echomsg ':Nsource sftp://[user@]machine[[:#]port]/path uses sftp'
                               sleep 4
                              else
                               let i= 1
                               while i <= a:0
                                call netrw#NetRead(3,a:{i})
                            "    call Decho("(netrw#NetSource) s:netread_tmpfile<".s:netrw_tmpfile.">")
                                if s:FileReadable(s:netrw_tmpfile)
                            "     call Decho("(netrw#NetSource) exe so ".fnameescape(s:netrw_tmpfile))
                                 exe "so ".fnameescape(s:netrw_tmpfile)
                            "     call Decho("(netrw#NetSource) delete(".s:netrw_tmpfile.")")
                                 call delete(s:netrw_tmpfile)
                                 unlet s:netrw_tmpfile
                                else
                                 call netrw#ErrorMsg(s:ERROR,"unable to source <".a:{i}.">!",48)
                                endif
                                let i= i + 1
                               endwhile
                              endif
                            "  call Dret("netrw#NetSource")
                            endfun
                            
                            " ===========================================
                            " s:NetrwGetFile: Function to read temporary file "tfile" with command "readcmd". {{{2
                            "    readcmd == %r : replace buffer with newly read file
                            "            == 0r : read file at top of buffer
                            "            == r  : read file after current line
                            "            == t  : leave file in temporary form (ie. don't read into buffer)
    1              0.000003 fun! s:NetrwGetFile(readcmd, tfile, method)
                            "  call Dfunc("NetrwGetFile(readcmd<".a:readcmd.">,tfile<".a:tfile."> method<".a:method.">)")
                            
                              " readcmd=='t': simply do nothing
                              if a:readcmd == 't'
                            "   call Decho("(NetrwGetFile)  ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
                            "   call Dret("NetrwGetFile : skip read of <".a:tfile.">")
                               return
                              endif
                            
                              " get name of remote filename (ie. url and all)
                              let rfile= bufname("%")
                            "  call Decho("rfile<".rfile.">")
                            
                              if exists("*NetReadFixup")
                               " for the use of NetReadFixup (not otherwise used internally)
                               let line2= line("$")
                              endif
                            
                              if a:readcmd[0] == '%'
                              " get file into buffer
                            "   call Decho("get file into buffer")
                            
                               " rename the current buffer to the temp file (ie. tfile)
                               if g:netrw_cygwin
                                let tfile= substitute(a:tfile,'/cygdrive/\(.\)','\1:','')
                               else
                                let tfile= a:tfile
                               endif
                            "   call Decho("exe sil! keepalt file ".fnameescape(tfile))
                               exe "sil! keepalt file ".fnameescape(tfile)
                            
                               " edit temporary file (ie. read the temporary file in)
                               if     rfile =~ '\.zip$'
                            "    call Decho("handling remote zip file with zip#Browse(tfile<".tfile.">)")
                                call zip#Browse(tfile)
                               elseif rfile =~ '\.tar$'
                            "    call Decho("handling remote tar file with tar#Browse(tfile<".tfile.">)")
                                call tar#Browse(tfile)
                               elseif rfile =~ '\.tar\.gz$'
                            "    call Decho("handling remote gzip-compressed tar file")
                                call tar#Browse(tfile)
                               elseif rfile =~ '\.tar\.bz2$'
                            "    call Decho("handling remote bz2-compressed tar file")
                                call tar#Browse(tfile)
                               elseif rfile =~ '\.tar\.xz$'
                            "    call Decho("handling remote xz-compressed tar file")
                                call tar#Browse(tfile)
                               elseif rfile =~ '\.txz$'
                            "    call Decho("handling remote xz-compressed tar file (.txz)")
                                call tar#Browse(tfile)
                               else
                            "    call Decho("edit temporary file")
                                e!
                               endif
                            
                               " rename buffer back to remote filename
                            "   call Decho("exe sil! keepalt file ".fnameescape(rfile))
                               exe "sil! keepj keepalt file ".fnameescape(rfile)
                            
                               " Detect filetype of local version of remote file.
                               " Note that isk must not include a "/" for scripts.vim
                               " to process this detection correctly.
                            "   call Decho("detect filetype of local version of remote file")
                               let iskkeep= &l:isk
                               setl isk-=/
                               let &l:isk= iskkeep
                            "   call Dredir("renamed buffer back to remote filename<".rfile."> : expand(%)<".expand("%").">","ls!")
                               let line1 = 1
                               let line2 = line("$")
                            
                              elseif s:FileReadable(a:tfile)
                               " read file after current line
                            "   call Decho("read file<".a:tfile."> after current line")
                               let curline = line(".")
                               let lastline= line("$")
                            "   call Decho("exe<".a:readcmd." ".fnameescape(v:cmdarg)." ".fnameescape(a:tfile).">  line#".curline)
                               exe "keepj ".a:readcmd." ".fnameescape(v:cmdarg)." ".fnameescape(a:tfile)
                               let line1= curline + 1
                               let line2= line("$") - lastline + 1
                            
                              else
                               " not readable
                            "   call Decho("(NetrwGetFile)  ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
                            "   call Decho("tfile<".a:tfile."> not readable")
                               keepj call netrw#ErrorMsg(s:WARNING,"file <".a:tfile."> not readable",9)
                            "   call Dret("NetrwGetFile : tfile<".a:tfile."> not readable")
                               return
                              endif
                            
                              " User-provided (ie. optional) fix-it-up command
                              if exists("*NetReadFixup")
                            "   call Decho("calling NetReadFixup(method<".a:method."> line1=".line1." line2=".line2.")")
                               keepj call NetReadFixup(a:method, line1, line2)
                            "  else " Decho
                            "   call Decho("NetReadFixup() not called, doesn't exist  (line1=".line1." line2=".line2.")")
                              endif
                            
                              if has("gui") && has("menu") && has("gui_running") && &go =~# 'm' && g:netrw_menu
                               " update the Buffers menu
                               keepj call s:UpdateBuffersMenu()
                              endif
                            
                            "  call Decho("readcmd<".a:readcmd."> cmdarg<".v:cmdarg."> tfile<".a:tfile."> readable=".s:FileReadable(a:tfile))
                            
                             " make sure file is being displayed
                            "  redraw!
                            
                            "  call Decho("(NetrwGetFile)  ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
                            "  call Dret("NetrwGetFile")
                            endfun
                            
                            " ------------------------------------------------------------------------
                            " s:NetrwMethod:  determine method of transfer {{{2
                            " Input:
                            "   choice = url   [protocol:]//[userid@]hostname[:port]/[path-to-file]
                            " Output:
                            "  b:netrw_method= 1: rcp                                             
                            "                  2: ftp + <.netrc>                                  
                            "	           3: ftp + machine, id, password, and [path]filename 
                            "	           4: scp                                             
                            "	           5: http[s] (wget)                                     
                            "	           6: dav
                            "	           7: rsync                                           
                            "	           8: fetch                                           
                            "	           9: sftp                                            
                            "  g:netrw_machine= hostname
                            "  b:netrw_fname  = filename
                            "  g:netrw_port   = optional port number (for ftp)
                            "  g:netrw_choice = copy of input url (choice)
    1              0.000002 fun! s:NetrwMethod(choice)
                            "   call Dfunc("NetrwMethod(a:choice<".a:choice.">)")
                            
                               " sanity check: choice should have at least three slashes in it
                               if strlen(substitute(a:choice,'[^/]','','g')) < 3
                                call netrw#ErrorMsg(s:ERROR,"not a netrw-style url; netrw uses protocol://[user@]hostname[:port]/[path])",78)
                                let b:netrw_method = -1
                            "    call Dret("NetrwMethod : incorrect url format<".a:choice.">")
                                return
                               endif
                            
                               " record current g:netrw_machine, if any
                               " curmachine used if protocol == ftp and no .netrc
                               if exists("g:netrw_machine")
                                let curmachine= g:netrw_machine
                            "    call Decho("curmachine<".curmachine.">")
                               else
                                let curmachine= "N O T A HOST"
                               endif
                               if exists("g:netrw_port")
                                let netrw_port= g:netrw_port
                               endif
                            
                               " insure that netrw_ftp_cmd starts off every method determination
                               " with the current g:netrw_ftp_cmd
                               let s:netrw_ftp_cmd= g:netrw_ftp_cmd
                            
                              " initialization
                              let b:netrw_method  = 0
                              let g:netrw_machine = ""
                              let b:netrw_fname   = ""
                              let g:netrw_port    = ""
                              let g:netrw_choice  = a:choice
                            
                              " Patterns:
                              " mipf     : a:machine a:id password filename	     Use ftp
                              " mf	    : a:machine filename		     Use ftp + <.netrc> or g:netrw_uid s:netrw_passwd
                              " ftpurm   : ftp://[user@]host[[#:]port]/filename  Use ftp + <.netrc> or g:netrw_uid s:netrw_passwd
                              " rcpurm   : rcp://[user@]host/filename	     Use rcp
                              " rcphf    : [user@]host:filename		     Use rcp
                              " scpurm   : scp://[user@]host[[#:]port]/filename  Use scp
                              " httpurm  : http[s]://[user@]host/filename	     Use wget
                              " davurm   : dav[s]://host[:port]/path             Use cadaver/curl
                              " rsyncurm : rsync://host[:port]/path              Use rsync
                              " fetchurm : fetch://[user@]host[:http]/filename   Use fetch (defaults to ftp, override for http)
                              " sftpurm  : sftp://[user@]host/filename  Use scp
                              let mipf     = '^\(\S\+\)\s\+\(\S\+\)\s\+\(\S\+\)\s\+\(\S\+\)$'
                              let mf       = '^\(\S\+\)\s\+\(\S\+\)$'
                            "  let ftpurm   = '^ftp://\(\([^/@]\{-}\)@\)\=\([^/#:]\{-}\)\([#:]\d\+\)\=/\(.*\)$'
                            "  let rcpurm   = '^rcp://\%(\([^/@]\{-}\)@\)\=\([^/]\{-}\)/\(.*\)$'
                            "  let fetchurm = '^fetch://\(\([^/@]\{-}\)@\)\=\([^/#:]\{-}\)\(:http\)\=/\(.*\)$'
                              let ftpurm   = '^ftp://\(\([^/]*\)@\)\=\([^/#:]\{-}\)\([#:]\d\+\)\=/\(.*\)$'
                              let rcpurm   = '^rcp://\%(\([^/]*\)@\)\=\([^/]\{-}\)/\(.*\)$'
                              let rcphf    = '^\(\(\h\w*\)@\)\=\(\h\w*\):\([^@]\+\)$'
                              let scpurm   = '^scp://\([^/#:]\+\)\%([#:]\(\d\+\)\)\=/\(.*\)$'
                              let httpurm  = '^https\=://\([^/]\{-}\)\(/.*\)\=$'
                              let davurm   = '^davs\=://\([^/]\+\)/\(.*/\)\([-_.~[:alnum:]]\+\)$'
                              let rsyncurm = '^rsync://\([^/]\{-}\)/\(.*\)\=$'
                              let fetchurm = '^fetch://\(\([^/]*\)@\)\=\([^/#:]\{-}\)\(:http\)\=/\(.*\)$'
                              let sftpurm  = '^sftp://\([^/]\{-}\)/\(.*\)\=$'
                            
                            "  call Decho("determine method:")
                              " Determine Method
                              " Method#1: rcp://user@hostname/...path-to-file {{{3
                              if match(a:choice,rcpurm) == 0
                            "   call Decho("rcp://...")
                               let b:netrw_method  = 1
                               let userid          = substitute(a:choice,rcpurm,'\1',"")
                               let g:netrw_machine = substitute(a:choice,rcpurm,'\2',"")
                               let b:netrw_fname   = substitute(a:choice,rcpurm,'\3',"")
                               if userid != ""
                                let g:netrw_uid= userid
                               endif
                            
                              " Method#4: scp://user@hostname/...path-to-file {{{3
                              elseif match(a:choice,scpurm) == 0
                            "   call Decho("scp://...")
                               let b:netrw_method  = 4
                               let g:netrw_machine = substitute(a:choice,scpurm,'\1',"")
                               let g:netrw_port    = substitute(a:choice,scpurm,'\2',"")
                               let b:netrw_fname   = substitute(a:choice,scpurm,'\3',"")
                            
                              " Method#5: http[s]://user@hostname/...path-to-file {{{3
                              elseif match(a:choice,httpurm) == 0
                            "   call Decho("http://...")
                               let b:netrw_method = 5
                               let g:netrw_machine= substitute(a:choice,httpurm,'\1',"")
                               let b:netrw_fname  = substitute(a:choice,httpurm,'\2',"")
                            
                              " Method#6: dav://hostname[:port]/..path-to-file.. {{{3
                              elseif match(a:choice,davurm) == 0
                            "   call Decho("dav://...")
                               let b:netrw_method= 6
                               if a:choice =~ 'davs:'
                                let g:netrw_machine= 'https://'.substitute(a:choice,davurm,'\1/\2',"")
                               else
                                let g:netrw_machine= 'http://'.substitute(a:choice,davurm,'\1/\2',"")
                               endif
                               let b:netrw_fname  = substitute(a:choice,davurm,'\3',"")
                            
                               " Method#7: rsync://user@hostname/...path-to-file {{{3
                              elseif match(a:choice,rsyncurm) == 0
                            "   call Decho("rsync://...")
                               let b:netrw_method = 7
                               let g:netrw_machine= substitute(a:choice,rsyncurm,'\1',"")
                               let b:netrw_fname  = substitute(a:choice,rsyncurm,'\2',"")
                            
                               " Methods 2,3: ftp://[user@]hostname[[:#]port]/...path-to-file {{{3
                              elseif match(a:choice,ftpurm) == 0
                            "   call Decho("ftp://...")
                               let userid	      = substitute(a:choice,ftpurm,'\2',"")
                               let g:netrw_machine= substitute(a:choice,ftpurm,'\3',"")
                               let g:netrw_port   = substitute(a:choice,ftpurm,'\4',"")
                               let b:netrw_fname  = substitute(a:choice,ftpurm,'\5',"")
                            "   call Decho("g:netrw_machine<".g:netrw_machine.">")
                               if userid != ""
                                let g:netrw_uid= userid
                               endif
                            
                               if curmachine != g:netrw_machine
                                if exists("s:netwr_hup[".g:netrw_machine."]")
                                 call NetUserPass("ftp:".g:netrw_machine)
                                elseif exists("s:netrw_passwd")
                                 " if there's a change in hostname, require password re-entry
                                 unlet s:netrw_passwd
                                endif
                                if exists("netrw_port")
                                 unlet netrw_port
                                endif
                               endif
                            
                               if exists("g:netrw_uid") && exists("s:netrw_passwd")
                                let b:netrw_method = 3
                               else
                                let host= substitute(g:netrw_machine,'\..*$','','')
                                if exists("s:netrw_hup[host]")
                                 call NetUserPass("ftp:".host)
                            
                                elseif (has("win32") || has("win95") || has("win64") || has("win16")) && s:netrw_ftp_cmd =~ '-[sS]:'
                            "     call Decho("has -s: : s:netrw_ftp_cmd<".s:netrw_ftp_cmd.">")
                            "     call Decho("          g:netrw_ftp_cmd<".g:netrw_ftp_cmd.">")
                                 if g:netrw_ftp_cmd =~ '-[sS]:\S*MACHINE\>'
                                  let s:netrw_ftp_cmd= substitute(g:netrw_ftp_cmd,'\<MACHINE\>',g:netrw_machine,'')
                            "      call Decho("s:netrw_ftp_cmd<".s:netrw_ftp_cmd.">")
                                 endif
                                 let b:netrw_method= 2
                                elseif s:FileReadable(expand("$HOME/.netrc")) && !g:netrw_ignorenetrc
                            "     call Decho("using <".expand("$HOME/.netrc")."> (readable)")
                                 let b:netrw_method= 2
                                else
                                 if !exists("g:netrw_uid") || g:netrw_uid == ""
                                  call NetUserPass()
                                 elseif !exists("s:netrw_passwd") || s:netrw_passwd == ""
                                  call NetUserPass(g:netrw_uid)
                                " else just use current g:netrw_uid and s:netrw_passwd
                                 endif
                                 let b:netrw_method= 3
                                endif
                               endif
                            
                              " Method#8: fetch {{{3
                              elseif match(a:choice,fetchurm) == 0
                            "   call Decho("fetch://...")
                               let b:netrw_method = 8
                               let g:netrw_userid = substitute(a:choice,fetchurm,'\2',"")
                               let g:netrw_machine= substitute(a:choice,fetchurm,'\3',"")
                               let b:netrw_option = substitute(a:choice,fetchurm,'\4',"")
                               let b:netrw_fname  = substitute(a:choice,fetchurm,'\5',"")
                            
                               " Method#3: Issue an ftp : "machine id password [path/]filename" {{{3
                              elseif match(a:choice,mipf) == 0
                            "   call Decho("(ftp) host id pass file")
                               let b:netrw_method  = 3
                               let g:netrw_machine = substitute(a:choice,mipf,'\1',"")
                               let g:netrw_uid     = substitute(a:choice,mipf,'\2',"")
                               let s:netrw_passwd  = substitute(a:choice,mipf,'\3',"")
                               let b:netrw_fname   = substitute(a:choice,mipf,'\4',"")
                               call NetUserPass(g:netrw_machine,g:netrw_uid,s:netrw_passwd)
                            
                              " Method#3: Issue an ftp: "hostname [path/]filename" {{{3
                              elseif match(a:choice,mf) == 0
                            "   call Decho("(ftp) host file")
                               if exists("g:netrw_uid") && exists("s:netrw_passwd")
                                let b:netrw_method  = 3
                                let g:netrw_machine = substitute(a:choice,mf,'\1',"")
                                let b:netrw_fname   = substitute(a:choice,mf,'\2',"")
                            
                               elseif s:FileReadable(expand("$HOME/.netrc"))
                                let b:netrw_method  = 2
                                let g:netrw_machine = substitute(a:choice,mf,'\1',"")
                                let b:netrw_fname   = substitute(a:choice,mf,'\2',"")
                               endif
                            
                              " Method#9: sftp://user@hostname/...path-to-file {{{3
                              elseif match(a:choice,sftpurm) == 0
                            "   call Decho("sftp://...")
                               let b:netrw_method = 9
                               let g:netrw_machine= substitute(a:choice,sftpurm,'\1',"")
                               let b:netrw_fname  = substitute(a:choice,sftpurm,'\2',"")
                            
                              " Method#1: Issue an rcp: hostname:filename"  (this one should be last) {{{3
                              elseif match(a:choice,rcphf) == 0
                            "   call Decho("(rcp) [user@]host:file) rcphf<".rcphf.">")
                               let b:netrw_method  = 1
                               let userid          = substitute(a:choice,rcphf,'\2',"")
                               let g:netrw_machine = substitute(a:choice,rcphf,'\3',"")
                               let b:netrw_fname   = substitute(a:choice,rcphf,'\4',"")
                            "   call Decho('\1<'.substitute(a:choice,rcphf,'\1',"").">")
                            "   call Decho('\2<'.substitute(a:choice,rcphf,'\2',"").">")
                            "   call Decho('\3<'.substitute(a:choice,rcphf,'\3',"").">")
                            "   call Decho('\4<'.substitute(a:choice,rcphf,'\4',"").">")
                               if userid != ""
                                let g:netrw_uid= userid
                               endif
                            
                              " Cannot Determine Method {{{3
                              else
                               if !exists("g:netrw_quiet")
                                call netrw#ErrorMsg(s:WARNING,"cannot determine method (format: protocol://[user@]hostname[:port]/[path])",45)
                               endif
                               let b:netrw_method  = -1
                              endif
                              "}}}3
                            
                              if g:netrw_port != ""
                               " remove any leading [:#] from port number
                               let g:netrw_port = substitute(g:netrw_port,'[#:]\+','','')
                              elseif exists("netrw_port")
                               " retain port number as implicit for subsequent ftp operations
                               let g:netrw_port= netrw_port
                              endif
                            
                            "  call Decho("a:choice       <".a:choice.">")
                            "  call Decho("b:netrw_method <".b:netrw_method.">")
                            "  call Decho("g:netrw_machine<".g:netrw_machine.">")
                            "  call Decho("g:netrw_port   <".g:netrw_port.">")
                            "  if exists("g:netrw_uid")		"Decho
                            "   call Decho("g:netrw_uid    <".g:netrw_uid.">")
                            "  endif					"Decho
                            "  if exists("s:netrw_passwd")		"Decho
                            "   call Decho("s:netrw_passwd <".s:netrw_passwd.">")
                            "  endif					"Decho
                            "  call Decho("b:netrw_fname  <".b:netrw_fname.">")
                            "  call Dret("NetrwMethod : b:netrw_method=".b:netrw_method." g:netrw_port=".g:netrw_port)
                            endfun
                            
                            " ------------------------------------------------------------------------
                            " NetReadFixup: this sort of function is typically written by the user {{{2
                            "               to handle extra junk that their system's ftp dumps
                            "               into the transfer.  This function is provided as an
                            "               example and as a fix for a Windows 95 problem: in my
                            "               experience, win95's ftp always dumped four blank lines
                            "               at the end of the transfer.
    1              0.000007 if has("win95") && exists("g:netrw_win95ftp") && g:netrw_win95ftp
                             fun! NetReadFixup(method, line1, line2)
                            "   call Dfunc("NetReadFixup(method<".a:method."> line1=".a:line1." line2=".a:line2.")")
                            
                               " sanity checks -- attempt to convert inputs to integers
                               let method = a:method + 0
                               let line1  = a:line1 + 0
                               let line2  = a:line2 + 0
                               if type(method) != 0 || type(line1) != 0 || type(line2) != 0 || method < 0 || line1 <= 0 || line2 <= 0
                            "    call Dret("NetReadFixup")
                                return
                               endif
                            
                               if method == 3   " ftp (no <.netrc>)
                                let fourblanklines= line2 - 3
                                if fourblanklines >= line1
                                 exe "sil keepj ".fourblanklines.",".line2."g/^\s*$/d"
                                 call histdel("/",-1)
                                endif
                               endif
                            
                            "   call Dret("NetReadFixup")
                             endfun
                            endif
                            
                            " ---------------------------------------------------------------------
                            " NetUserPass: set username and password for subsequent ftp transfer {{{2
                            "   Usage:  :call NetUserPass()		               -- will prompt for userid and password
                            "	    :call NetUserPass("uid")	               -- will prompt for password
                            "	    :call NetUserPass("uid","password")        -- sets global userid and password
                            "	    :call NetUserPass("ftp:host")              -- looks up userid and password using hup dictionary
                            "	    :call NetUserPass("host","uid","password") -- sets hup dictionary with host, userid, password
    1              0.000001 fun! NetUserPass(...)
                            
                            " call Dfunc("NetUserPass() a:0=".a:0)
                            
                             if !exists('s:netrw_hup')
                              let s:netrw_hup= {}
                             endif
                            
                             if a:0 == 0
                              " case: no input arguments
                            
                              " change host and username if not previously entered; get new password
                              if !exists("g:netrw_machine")
                               let g:netrw_machine= input('Enter hostname: ')
                              endif
                              if !exists("g:netrw_uid") || g:netrw_uid == ""
                               " get username (user-id) via prompt
                               let g:netrw_uid= input('Enter username: ')
                              endif
                              " get password via prompting
                              let s:netrw_passwd= inputsecret("Enter Password: ")
                            
                              " set up hup database
                              let host = substitute(g:netrw_machine,'\..*$','','')
                              if !exists('s:netrw_hup[host]')
                               let s:netrw_hup[host]= {}
                              endif
                              let s:netrw_hup[host].uid    = g:netrw_uid
                              let s:netrw_hup[host].passwd = s:netrw_passwd
                            
                             elseif a:0 == 1
                              " case: one input argument
                            
                              if a:1 =~ '^ftp:'
                               " get host from ftp:... url
                               " access userid and password from hup (host-user-passwd) dictionary
                               let host = substitute(a:1,'^ftp:','','')
                               let host = substitute(host,'\..*','','')
                               if exists("s:netrw_hup[host]")
                                let g:netrw_uid    = s:netrw_hup[host].uid
                                let s:netrw_passwd = s:netrw_hup[host].passwd
                            "    call Decho("get s:netrw_hup[".host."].uid   <".s:netrw_hup[host].uid.">")
                            "    call Decho("get s:netrw_hup[".host."].passwd<".s:netrw_hup[host].passwd.">")
                               else
                                let g:netrw_uid    = input("Enter UserId: ")
                                let s:netrw_passwd = inputsecret("Enter Password: ")
                               endif
                            
                              else
                               " case: one input argument, not an url.  Using it as a new user-id.
                               if exists("g:netrw_machine")
                                let host= substitute(g:netrw_machine,'\..*$','','')
                               else
                                let g:netrw_machine= input('Enter hostname: ')
                               endif
                               let g:netrw_uid = a:1
                            "   call Decho("set g:netrw_uid= <".g:netrw_uid.">")
                               if exists("g:netrw_passwd")
                                " ask for password if one not previously entered
                                let s:netrw_passwd= g:netrw_passwd
                               else
                                let s:netrw_passwd = inputsecret("Enter Password: ")
                               endif
                              endif
                            
                            "  call Decho("host<".host.">")
                              if exists("host")
                               if !exists('s:netrw_hup[host]')
                                let s:netrw_hup[host]= {}
                               endif
                               let s:netrw_hup[host].uid    = g:netrw_uid
                               let s:netrw_hup[host].passwd = s:netrw_passwd
                              endif
                            
                             elseif a:0 == 2
                              let g:netrw_uid    = a:1
                              let s:netrw_passwd = a:2
                            
                             elseif a:0 == 3
                              " enter hostname, user-id, and password into the hup dictionary
                              let host = substitute(a:1,'^\a\+:','','')
                              let host = substitute(host,'\..*$','','')
                              if !exists('s:netrw_hup[host]')
                               let s:netrw_hup[host]= {}
                              endif
                              let s:netrw_hup[host].uid    = a:2
                              let s:netrw_hup[host].passwd = a:3
                              let g:netrw_uid              = s:netrw_hup[host].uid
                              let s:netrw_passwd           = s:netrw_hup[host].passwd
                            "  call Decho("set s:netrw_hup[".host."].uid   <".s:netrw_hup[host].uid.">")
                            "  call Decho("set s:netrw_hup[".host."].passwd<".s:netrw_hup[host].passwd.">")
                             endif
                            
                            " call Dret("NetUserPass : uid<".g:netrw_uid."> passwd<".s:netrw_passwd.">")
                            endfun
                            
                            " ===========================================
                            "  Shared Browsing Support:    {{{1
                            " ===========================================
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwMaps: {{{2
    1              0.000002 fun! s:NetrwMaps(islocal)
                            "  call Dfunc("s:NetrwMaps(islocal=".a:islocal.") b:netrw_curdir<".b:netrw_curdir.">")
                            
                              " set up Rexplore and [ 2-leftmouse-click -or- c-leftmouse ]
                            "  call Decho("(NetrwMaps) set up Rexplore command")
                              com! Rexplore if exists("w:netrw_rexlocal")|call s:NetrwRexplore(w:netrw_rexlocal,exists("w:netrw_rexdir")? w:netrw_rexdir : ".")|else|call netrw#ErrorMsg(s:WARNING,"not a former netrw window",79)|endif
                              if g:netrw_mousemaps && g:netrw_retmap
                            "   call Decho("(NetrwMaps) set up Rexplore 2-leftmouse")
                               if !hasmapto("<Plug>NetrwReturn")
                                if maparg("<2-leftmouse>","n") == "" || maparg("<2-leftmouse>","n") =~ '^-$'
                            "     call Decho("(NetrwMaps) making map for 2-leftmouse")
                                 nmap <unique> <silent> <2-leftmouse>	<Plug>NetrwReturn
                                elseif maparg("<c-leftmouse>","n") == ""
                            "     call Decho("(NetrwMaps) making map for c-leftmouse")
                                 nmap <unique> <silent> <c-leftmouse>	<Plug>NetrwReturn
                                endif
                               endif
                               nno <silent> <Plug>NetrwReturn	:Rexplore<cr>
                            "   call Decho("(NetrwMaps) made <Plug>NetrwReturn map")
                              endif
                            
                              if a:islocal
                            "   call Decho("(NetrwMaps) make local maps")
                               " local normal-mode maps
                               nnoremap <buffer> <silent> a		:call <SID>NetrwHide(1)<cr>
                               nnoremap <buffer> <silent> %		:call <SID>NetrwOpenFile(1)<cr>
                               nnoremap <buffer> <silent> c		:exe "keepjumps lcd ".fnameescape(b:netrw_curdir)<cr>
                               nnoremap <buffer> <silent> C		:let g:netrw_chgwin= winnr()<cr>
                               nnoremap <buffer> <silent> <cr>	:call netrw#LocalBrowseCheck(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord()))<cr>
                               nnoremap <buffer> <silent> d		:call <SID>NetrwMakeDir("")<cr>
                               nnoremap <buffer> <silent> -		:exe "norm! 0"<bar>call netrw#LocalBrowseCheck(<SID>NetrwBrowseChgDir(1,'../'))<cr>
                               nnoremap <buffer> <silent> gb	:<c-u>call <SID>NetrwBookHistHandler(1,b:netrw_curdir)<cr>
                               nnoremap <buffer> <silent> gd	:<c-u>call <SID>NetrwForceChgDir(1,<SID>NetrwGetWord())<cr>
                               nnoremap <buffer> <silent> gf	:<c-u>call <SID>NetrwForceFile(1,<SID>NetrwGetWord())<cr>
                               nnoremap <buffer> <silent> gh	:<c-u>call <SID>NetrwHidden(1)<cr>
                               nnoremap <buffer> <silent> gp	:<c-u>call <SID>NetrwChgPerm(1,b:netrw_curdir)<cr>
                               nnoremap <buffer> <silent> I		:call <SID>NetrwBannerCtrl(1)<cr>
                               nnoremap <buffer> <silent> i		:call <SID>NetrwListStyle(1)<cr>
                               nnoremap <buffer> <silent> mb	:<c-u>call <SID>NetrwBookHistHandler(0,b:netrw_curdir)<cr>
                               nnoremap <buffer> <silent> mB	:<c-u>call <SID>NetrwBookHistHandler(6,b:netrw_curdir)<cr>
                               nnoremap <buffer> <silent> mc	:<c-u>call <SID>NetrwMarkFileCopy(1)<cr>
                               nnoremap <buffer> <silent> md	:<c-u>call <SID>NetrwMarkFileDiff(1)<cr>
                               nnoremap <buffer> <silent> me	:<c-u>call <SID>NetrwMarkFileEdit(1)<cr>
                               nnoremap <buffer> <silent> mf	:<c-u>call <SID>NetrwMarkFile(1,<SID>NetrwGetWord())<cr>
                               nnoremap <buffer> <silent> mF	:<c-u>call <SID>NetrwUnmarkList(bufnr("%"),b:netrw_curdir)<cr>
                               nnoremap <buffer> <silent> mg	:<c-u>call <SID>NetrwMarkFileGrep(1)<cr>
                               nnoremap <buffer> <silent> mh	:<c-u>call <SID>NetrwMarkHideSfx(1)<cr>
                               nnoremap <buffer> <silent> mm	:<c-u>call <SID>NetrwMarkFileMove(1)<cr>
                               nnoremap <buffer> <silent> mp	:<c-u>call <SID>NetrwMarkFilePrint(1)<cr>
                               nnoremap <buffer> <silent> mr	:<c-u>call <SID>NetrwMarkFileRegexp(1)<cr>
                               nnoremap <buffer> <silent> ms	:<c-u>call <SID>NetrwMarkFileSource(1)<cr>
                               nnoremap <buffer> <silent> mt	:<c-u>call <SID>NetrwMarkFileTgt(1)<cr>
                               nnoremap <buffer> <silent> mT	:<c-u>call <SID>NetrwMarkFileTag(1)<cr>
                               nnoremap <buffer> <silent> mu	:<c-u>call <SID>NetrwUnMarkFile(1)<cr>
                               nnoremap <buffer> <silent> mx	:<c-u>call <SID>NetrwMarkFileExe(1)<cr>
                               nnoremap <buffer> <silent> mX	:<c-u>call <SID>NetrwMarkFileVimCmd(1)<cr>
                               nnoremap <buffer> <silent> mz	:<c-u>call <SID>NetrwMarkFileCompress(1)<cr>
                               nnoremap <buffer> <silent> O		:call <SID>NetrwObtain(1)<cr>
                               nnoremap <buffer> <silent> o		:call <SID>NetrwSplit(3)<cr>
                               nnoremap <buffer> <silent> p		:call <SID>NetrwPreview(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord(),1))<cr>
                               nnoremap <buffer> <silent> P		:call <SID>NetrwPrevWinOpen(1)<cr>
                               nnoremap <buffer> <silent> qb	:<c-u>call <SID>NetrwBookHistHandler(2,b:netrw_curdir)<cr>
                               nnoremap <buffer> <silent> qf	:<c-u>call <SID>NetrwFileInfo(1,<SID>NetrwGetWord())<cr>
                               nnoremap <buffer> <silent> qF	:<c-u>call <SID>NetrwMarkFileQFEL(1,getqflist())<cr>
                               nnoremap <buffer> <silent> r		:let g:netrw_sort_direction= (g:netrw_sort_direction =~ 'n')? 'r' : 'n'<bar>exe "norm! 0"<bar>call <SID>NetrwRefresh(1,<SID>NetrwBrowseChgDir(1,'./'))<cr>
                               nnoremap <buffer> <silent> s		:call <SID>NetrwSortStyle(1)<cr>
                               nnoremap <buffer> <silent> S		:call <SID>NetSortSequence(1)<cr>
                               nnoremap <buffer> <silent> t		:call <SID>NetrwSplit(4)<cr>
                               nnoremap <buffer> <silent> Tb	:<c-u>call <SID>NetrwSetTgt('b',v:count1)<cr>
                               nnoremap <buffer> <silent> Th	:<c-u>call <SID>NetrwSetTgt('h',v:count)<cr>
                               nnoremap <buffer> <silent> u		:<c-u>call <SID>NetrwBookHistHandler(4,expand("%"))<cr>
                               nnoremap <buffer> <silent> U		:<c-u>call <SID>NetrwBookHistHandler(5,expand("%"))<cr>
                               nnoremap <buffer> <silent> v		:call <SID>NetrwSplit(5)<cr>
                               nnoremap <buffer> <silent> x		:call netrw#NetrwBrowseX(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord(),0),0)"<cr>
                               nnoremap <buffer> <silent> X		:call <SID>NetrwLocalExecute(expand("<cword>"))"<cr>
                               " local insert-mode maps
                               inoremap <buffer> <silent> a		<c-o>:call <SID>NetrwHide(1)<cr>
                               inoremap <buffer> <silent> c		<c-o>:exe "keepjumps lcd ".fnameescape(b:netrw_curdir)<cr>
                               inoremap <buffer> <silent> C		<c-o>:let g:netrw_chgwin= winnr()<cr>
                               inoremap <buffer> <silent> %		<c-o>:call <SID>NetrwOpenFile(1)<cr>
                               inoremap <buffer> <silent> -		<c-o>:exe "norm! 0"<bar>call netrw#LocalBrowseCheck(<SID>NetrwBrowseChgDir(1,'../'))<cr>
                               inoremap <buffer> <silent> <cr>	<c-o>:call netrw#LocalBrowseCheck(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord()))<cr>
                               inoremap <buffer> <silent> d		<c-o>:call <SID>NetrwMakeDir("")<cr>
                               inoremap <buffer> <silent> gb	<c-o>:<c-u>call <SID>NetrwBookHistHandler(1,b:netrw_curdir)<cr>
                               inoremap <buffer> <silent> gh	<c-o>:<c-u>call <SID>NetrwHidden(1)<cr>
                               inoremap <buffer> <silent> gp	<c-o>:<c-u>call <SID>NetrwChgPerm(1,b:netrw_curdir)<cr>
                               inoremap <buffer> <silent> I		<c-o>:call <SID>NetrwBannerCtrl(1)<cr>
                               inoremap <buffer> <silent> i		<c-o>:call <SID>NetrwListStyle(1)<cr>
                               inoremap <buffer> <silent> mb	<c-o>:<c-u>call <SID>NetrwBookHistHandler(0,b:netrw_curdir)<cr>
                               inoremap <buffer> <silent> mB	<c-o>:<c-u>call <SID>NetrwBookHistHandler(6,b:netrw_curdir)<cr>
                               inoremap <buffer> <silent> mc	<c-o>:<c-u>call <SID>NetrwMarkFileCopy(1)<cr>
                               inoremap <buffer> <silent> md	<c-o>:<c-u>call <SID>NetrwMarkFileDiff(1)<cr>
                               inoremap <buffer> <silent> me	<c-o>:<c-u>call <SID>NetrwMarkFileEdit(1)<cr>
                               inoremap <buffer> <silent> mf	<c-o>:<c-u>call <SID>NetrwMarkFile(1,<SID>NetrwGetWord())<cr>
                               inoremap <buffer> <silent> mg	<c-o>:<c-u>call <SID>NetrwMarkFileGrep(1)<cr>
                               inoremap <buffer> <silent> mh	<c-o>:<c-u>call <SID>NetrwMarkHideSfx(1)<cr>
                               inoremap <buffer> <silent> mm	<c-o>:<c-u>call <SID>NetrwMarkFileMove(1)<cr>
                               inoremap <buffer> <silent> mp	<c-o>:<c-u>call <SID>NetrwMarkFilePrint(1)<cr>
                               inoremap <buffer> <silent> mr	<c-o>:<c-u>call <SID>NetrwMarkFileRegexp(1)<cr>
                               inoremap <buffer> <silent> ms	<c-o>:<c-u>call <SID>NetrwMarkFileSource(1)<cr>
                               inoremap <buffer> <silent> mT	<c-o>:<c-u>call <SID>NetrwMarkFileTag(1)<cr>
                               inoremap <buffer> <silent> mt	<c-o>:<c-u>call <SID>NetrwMarkFileTgt(1)<cr>
                               inoremap <buffer> <silent> mu	<c-o>:<c-u>call <SID>NetrwUnMarkFile(1)<cr>
                               inoremap <buffer> <silent> mx	<c-o>:<c-u>call <SID>NetrwMarkFileExe(1)<cr>
                               inoremap <buffer> <silent> mX	<c-o>:<c-u>call <SID>NetrwMarkFileVimCmd(1)<cr>
                               inoremap <buffer> <silent> mz	<c-o>:<c-u>call <SID>NetrwMarkFileCompress(1)<cr>
                               inoremap <buffer> <silent> O		<c-o>:call <SID>NetrwObtain(1)<cr>
                               inoremap <buffer> <silent> o		<c-o>:call <SID>NetrwSplit(3)<cr>
                               inoremap <buffer> <silent> p		<c-o>:call <SID>NetrwPreview(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord(),1))<cr>
                               inoremap <buffer> <silent> P		<c-o>:call <SID>NetrwPrevWinOpen(1)<cr>
                               inoremap <buffer> <silent> qb	<c-o>:<c-u>call <SID>NetrwBookHistHandler(2,b:netrw_curdir)<cr>
                               inoremap <buffer> <silent> qf	<c-o>:<c-u>call <SID>NetrwFileInfo(1,<SID>NetrwGetWord())<cr>
                               inoremap <buffer> <silent> qF	:<c-u>call <SID>NetrwMarkFileQFEL(1,getqflist())<cr>
                               inoremap <buffer> <silent> r		<c-o>:let g:netrw_sort_direction= (g:netrw_sort_direction =~ 'n')? 'r' : 'n'<bar>exe "norm! 0"<bar>call <SID>NetrwRefresh(1,<SID>NetrwBrowseChgDir(1,'./'))<cr>
                               inoremap <buffer> <silent> s		<c-o>:call <SID>NetrwSortStyle(1)<cr>
                               inoremap <buffer> <silent> S		<c-o>:call <SID>NetSortSequence(1)<cr>
                               inoremap <buffer> <silent> t		<c-o>:call <SID>NetrwSplit(4)<cr>
                               inoremap <buffer> <silent> Tb	<c-o>:<c-u>call <SID>NetrwSetTgt('b',v:count1)<cr>
                               inoremap <buffer> <silent> Th	<c-o>:<c-u>call <SID>NetrwSetTgt('h',v:count)<cr>
                               inoremap <buffer> <silent> u		<c-o>:<c-u>call <SID>NetrwBookHistHandler(4,expand("%"))<cr>
                               inoremap <buffer> <silent> U		<c-o>:<c-u>call <SID>NetrwBookHistHandler(5,expand("%"))<cr>
                               inoremap <buffer> <silent> v		<c-o>:call <SID>NetrwSplit(5)<cr>
                               inoremap <buffer> <silent> x		<c-o>:call netrw#NetrwBrowseX(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord(),0),0)"<cr>
                               if !hasmapto('<Plug>NetrwHideEdit')
                                nmap <buffer> <unique> <c-h> <Plug>NetrwHideEdit
                                imap <buffer> <unique> <c-h> <Plug>NetrwHideEdit
                               endif
                               nnoremap <buffer> <silent> <Plug>NetrwHideEdit	:call <SID>NetrwHideEdit(1)<cr>
                               if !hasmapto('<Plug>NetrwRefresh')
                                nmap <buffer> <unique> <c-l> <Plug>NetrwRefresh
                                imap <buffer> <unique> <c-l> <Plug>NetrwRefresh
                               endif
                               nnoremap <buffer> <silent> <Plug>NetrwRefresh		:call <SID>NetrwRefresh(1,<SID>NetrwBrowseChgDir(1,'./'))<cr>
                               if s:didstarstar || !mapcheck("<s-down>","n")
                                nnoremap <buffer> <silent> <s-down>	:Nexplore<cr>
                                inoremap <buffer> <silent> <s-down>	:Nexplore<cr>
                               endif
                               if s:didstarstar || !mapcheck("<s-up>","n")
                                nnoremap <buffer> <silent> <s-up>	:Pexplore<cr>
                                inoremap <buffer> <silent> <s-up>	:Pexplore<cr>
                               endif
                               let mapsafecurdir = escape(b:netrw_curdir, s:netrw_map_escape)
                               if g:netrw_mousemaps == 1
                                nmap <buffer> <leftmouse>   <Plug>NetrwLeftmouse
                                nno  <buffer> <silent>	<Plug>NetrwLeftmouse	<leftmouse>:call <SID>NetrwLeftmouse(1)<cr>
                                nmap <buffer> <s-rightdrag>	<Plug>NetrwRightdrag
                                nno  <buffer> <silent>	<Plug>NetrwRightdrag	<leftmouse>:call <SID>NetrwRightdrag(1)<cr>
                                nmap <buffer> <middlemouse>	<Plug>NetrwMiddlemouse
                                nno  <buffer> <silent>	<Plug>NetrwMiddlemouse	<leftmouse>:call <SID>NetrwPrevWinOpen(1)<cr>
                                nmap <buffer> <s-leftmouse>	<Plug>NetrwSLeftmouse
                                nno  <buffer> <silent>	<Plug>NetrwSLeftmouse   <leftmouse>:call <SID>NetrwMarkFile(1,<SID>NetrwGetWord())<cr>
                                nmap <buffer> <2-leftmouse>	<Plug>Netrw2Leftmouse
                                nmap <buffer> <silent>	<Plug>Netrw2Leftmouse	-
                                imap <buffer> <leftmouse>	<Plug>ILeftmouse
                                ino  <buffer> <silent>	<Plug>ILeftmouse	<c-o><leftmouse><c-o>:call <SID>NetrwLeftmouse(1)<cr>
                                imap <buffer> <middlemouse>	<Plug>IMiddlemouse
                                ino  <buffer> <silent>	<Plug>IMiddlemouse	<c-o><leftmouse><c-o>:call <SID>NetrwPrevWinOpen(1)<cr>
                                imap <buffer> <s-leftmouse>	<Plug>ISLeftmouse
                                ino  <buffer> <silent>	<Plug>ISLeftmouse	<c-o><leftmouse><c-o>:call <SID>NetrwMarkFile(1,<SID>NetrwGetWord())<cr>
                                exe 'nnoremap <buffer> <silent> <rightmouse>  <leftmouse>:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
                                exe 'vnoremap <buffer> <silent> <rightmouse>  <leftmouse>:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
                                exe 'inoremap <buffer> <silent> <rightmouse>  <c-o><leftmouse><c-o>:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
                               endif
                               exe 'nnoremap <buffer> <silent> <del>	:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
                               exe 'nnoremap <buffer> <silent> D		:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
                               exe 'nnoremap <buffer> <silent> R		:call <SID>NetrwLocalRename("'.mapsafecurdir.'")<cr>'
                               exe 'nnoremap <buffer> <silent> <Leader>m	:call <SID>NetrwMakeDir("")<cr>'
                               exe 'vnoremap <buffer> <silent> <del>	:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
                               exe 'vnoremap <buffer> <silent> D		:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
                               exe 'vnoremap <buffer> <silent> R		:call <SID>NetrwLocalRename("'.mapsafecurdir.'")<cr>'
                               exe 'inoremap <buffer> <silent> <del>	<c-o>:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
                               exe 'inoremap <buffer> <silent> D		<c-o>:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
                               exe 'inoremap <buffer> <silent> R		<c-o>:call <SID>NetrwLocalRename("'.mapsafecurdir.'")<cr>'
                               exe 'inoremap <buffer> <silent> <Leader>m	<c-o>:call <SID>NetrwMakeDir("")<cr>'
                               nnoremap <buffer> <F1>		:he netrw-quickhelp<cr>
                            
                              else " remote
                            "   call Decho("(NetrwMaps) make remote maps")
                               call s:RemotePathAnalysis(b:netrw_curdir)
                               " remote normal-mode maps
                               nnoremap <buffer> <silent> <cr>	:call <SID>NetrwBrowse(0,<SID>NetrwBrowseChgDir(0,<SID>NetrwGetWord()))<cr>
                               nnoremap <buffer> <silent> <c-l>	:call <SID>NetrwRefresh(0,<SID>NetrwBrowseChgDir(0,'./'))<cr>
                               nnoremap <buffer> <silent> -		:exe "norm! 0"<bar>call <SID>NetrwBrowse(0,<SID>NetrwBrowseChgDir(0,'../'))<cr>
                               nnoremap <buffer> <silent> a		:call <SID>NetrwHide(0)<cr>
                               nnoremap <buffer> <silent> mb	:<c-u>call <SID>NetrwBookHistHandler(0,b:netrw_curdir)<cr>
                               nnoremap <buffer> <silent> mc	:<c-u>call <SID>NetrwMarkFileCopy(0)<cr>
                               nnoremap <buffer> <silent> md	:<c-u>call <SID>NetrwMarkFileDiff(0)<cr>
                               nnoremap <buffer> <silent> me	:<c-u>call <SID>NetrwMarkFileEdit(0)<cr>
                               nnoremap <buffer> <silent> mf	:<c-u>call <SID>NetrwMarkFile(0,<SID>NetrwGetWord())<cr>
                               nnoremap <buffer> <silent> mF	:<c-u>call <SID>NetrwUnmarkList(bufnr("%"),b:netrw_curdir)<cr>
                               nnoremap <buffer> <silent> mg	:<c-u>call <SID>NetrwMarkFileGrep(0)<cr>
                               nnoremap <buffer> <silent> mh	:<c-u>call <SID>NetrwMarkHideSfx(0)<cr>
                               nnoremap <buffer> <silent> mm	:<c-u>call <SID>NetrwMarkFileMove(0)<cr>
                               nnoremap <buffer> <silent> mp	:<c-u>call <SID>NetrwMarkFilePrint(0)<cr>
                               nnoremap <buffer> <silent> mr	:<c-u>call <SID>NetrwMarkFileRegexp(0)<cr>
                               nnoremap <buffer> <silent> ms	:<c-u>call <SID>NetrwMarkFileSource(0)<cr>
                               nnoremap <buffer> <silent> mt	:<c-u>call <SID>NetrwMarkFileTgt(0)<cr>
                               nnoremap <buffer> <silent> mT	:<c-u>call <SID>NetrwMarkFileTag(0)<cr>
                               nnoremap <buffer> <silent> mu	:<c-u>call <SID>NetrwUnMarkFile(0)<cr>
                               nnoremap <buffer> <silent> mx	:<c-u>call <SID>NetrwMarkFileExe(0)<cr>
                               nnoremap <buffer> <silent> mX	:<c-u>call <SID>NetrwMarkFileVimCmd(0)<cr>
                               nnoremap <buffer> <silent> mz	:<c-u>call <SID>NetrwMarkFileCompress(0)<cr>
                               nnoremap <buffer> <silent> gb	:<c-u>call <SID>NetrwBookHistHandler(1,b:netrw_curdir)<cr>
                               nnoremap <buffer> <silent> gd	:<c-u>call <SID>NetrwForceChgDir(0,<SID>NetrwGetWord())<cr>
                               nnoremap <buffer> <silent> gf	:<c-u>call <SID>NetrwForceFile(0,<SID>NetrwGetWord())<cr>
                               nnoremap <buffer> <silent> gh	:<c-u>call <SID>NetrwHidden(0)<cr>
                               nnoremap <buffer> <silent> gp	:<c-u>call <SID>NetrwChgPerm(0,b:netrw_curdir)<cr>
                               nnoremap <buffer> <silent> C		:let g:netrw_chgwin= winnr()<cr>
                               nnoremap <buffer> <silent> i		:call <SID>NetrwListStyle(0)<cr>
                               nnoremap <buffer> <silent> I		:call <SID>NetrwBannerCtrl(1)<cr>
                               nnoremap <buffer> <silent> o		:call <SID>NetrwSplit(0)<cr>
                               nnoremap <buffer> <silent> O		:call <SID>NetrwObtain(0)<cr>
                               nnoremap <buffer> <silent> p		:call <SID>NetrwPreview(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord(),1))<cr>
                               nnoremap <buffer> <silent> P		:call <SID>NetrwPrevWinOpen(0)<cr>
                               nnoremap <buffer> <silent> qb	:<c-u>call <SID>NetrwBookHistHandler(2,b:netrw_curdir)<cr>
                               nnoremap <buffer> <silent> mB	:<c-u>call <SID>NetrwBookHistHandler(6,b:netrw_curdir)<cr>
                               nnoremap <buffer> <silent> qf	:<c-u>call <SID>NetrwFileInfo(0,<SID>NetrwGetWord())<cr>
                               nnoremap <buffer> <silent> qF	:<c-u>call <SID>NetrwMarkFileQFEL(0,getqflist())<cr>
                               nnoremap <buffer> <silent> r		:let g:netrw_sort_direction= (g:netrw_sort_direction =~ 'n')? 'r' : 'n'<bar>exe "norm! 0"<bar>call <SID>NetrwBrowse(0,<SID>NetrwBrowseChgDir(0,'./'))<cr>
                               nnoremap <buffer> <silent> s		:call <SID>NetrwSortStyle(0)<cr>
                               nnoremap <buffer> <silent> S		:call <SID>NetSortSequence(0)<cr>
                               nnoremap <buffer> <silent> t		:call <SID>NetrwSplit(1)<cr>
                               nnoremap <buffer> <silent> Tb	:<c-u>call <SID>NetrwSetTgt('b',v:count1)<cr>
                               nnoremap <buffer> <silent> Th	:<c-u>call <SID>NetrwSetTgt('h',v:count)<cr>
                               nnoremap <buffer> <silent> u		:<c-u>call <SID>NetrwBookHistHandler(4,b:netrw_curdir)<cr>
                               nnoremap <buffer> <silent> U		:<c-u>call <SID>NetrwBookHistHandler(5,b:netrw_curdir)<cr>
                               nnoremap <buffer> <silent> v		:call <SID>NetrwSplit(2)<cr>
                               nnoremap <buffer> <silent> x		:call netrw#NetrwBrowseX(<SID>NetrwBrowseChgDir(0,<SID>NetrwGetWord()),1)<cr>
                               nnoremap <buffer> <silent> %		:call <SID>NetrwOpenFile(0)<cr>
                               " remote insert-mode maps
                               inoremap <buffer> <silent> <cr>	<c-o>:call <SID>NetrwBrowse(0,<SID>NetrwBrowseChgDir(0,<SID>NetrwGetWord()))<cr>
                               inoremap <buffer> <silent> <c-l>	<c-o>:call <SID>NetrwRefresh(0,<SID>NetrwBrowseChgDir(0,'./'))<cr>
                               inoremap <buffer> <silent> -		<c-o>:exe "norm! 0"<bar>call <SID>NetrwBrowse(0,<SID>NetrwBrowseChgDir(0,'../'))<cr>
                               inoremap <buffer> <silent> a		<c-o>:call <SID>NetrwHide(0)<cr>
                               inoremap <buffer> <silent> mb	<c-o>:<c-u>call <SID>NetrwBookHistHandler(0,b:netrw_curdir)<cr>
                               inoremap <buffer> <silent> mc	<c-o>:<c-u>call <SID>NetrwMarkFileCopy(0)<cr>
                               inoremap <buffer> <silent> md	<c-o>:<c-u>call <SID>NetrwMarkFileDiff(0)<cr>
                               inoremap <buffer> <silent> me	<c-o>:<c-u>call <SID>NetrwMarkFileEdit(0)<cr>
                               inoremap <buffer> <silent> mf	<c-o>:<c-u>call <SID>NetrwMarkFile(0,<SID>NetrwGetWord())<cr>
                               inoremap <buffer> <silent> mg	<c-o>:<c-u>call <SID>NetrwMarkFileGrep(0)<cr>
                               inoremap <buffer> <silent> mh	<c-o>:<c-u>call <SID>NetrwMarkHideSfx(0)<cr>
                               inoremap <buffer> <silent> mm	<c-o>:<c-u>call <SID>NetrwMarkFileMove(0)<cr>
                               inoremap <buffer> <silent> mp	<c-o>:<c-u>call <SID>NetrwMarkFilePrint(0)<cr>
                               inoremap <buffer> <silent> mr	<c-o>:<c-u>call <SID>NetrwMarkFileRegexp(0)<cr>
                               inoremap <buffer> <silent> ms	<c-o>:<c-u>call <SID>NetrwMarkFileSource(0)<cr>
                               inoremap <buffer> <silent> mt	<c-o>:<c-u>call <SID>NetrwMarkFileTgt(0)<cr>
                               inoremap <buffer> <silent> mT	<c-o>:<c-u>call <SID>NetrwMarkFileTag(0)<cr>
                               inoremap <buffer> <silent> mu	<c-o>:<c-u>call <SID>NetrwUnMarkFile(0)<cr>
                               inoremap <buffer> <silent> mx	<c-o>:<c-u>call <SID>NetrwMarkFileExe(0)<cr>
                               inoremap <buffer> <silent> mX	<c-o>:<c-u>call <SID>NetrwMarkFileVimCmd(0)<cr>
                               inoremap <buffer> <silent> mz	<c-o>:<c-u>call <SID>NetrwMarkFileCompress(0)<cr>
                               inoremap <buffer> <silent> gb	<c-o>:<c-u>call <SID>NetrwBookHistHandler(1,b:netrw_curdir)<cr>
                               inoremap <buffer> <silent> gh	<c-o>:<c-u>call <SID>NetrwHidden(0)<cr>
                               inoremap <buffer> <silent> gp	<c-o>:<c-u>call <SID>NetrwChgPerm(0,b:netrw_curdir)<cr>
                               inoremap <buffer> <silent> C		<c-o>:let g:netrw_chgwin= winnr()<cr>
                               inoremap <buffer> <silent> i		<c-o>:call <SID>NetrwListStyle(0)<cr>
                               inoremap <buffer> <silent> I		<c-o>:call <SID>NetrwBannerCtrl(1)<cr>
                               inoremap <buffer> <silent> o		<c-o>:call <SID>NetrwSplit(0)<cr>
                               inoremap <buffer> <silent> O		<c-o>:call <SID>NetrwObtain(0)<cr>
                               inoremap <buffer> <silent> p		<c-o>:call <SID>NetrwPreview(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord(),1))<cr>
                               inoremap <buffer> <silent> P		<c-o>:call <SID>NetrwPrevWinOpen(0)<cr>
                               inoremap <buffer> <silent> qb	<c-o>:<c-u>call <SID>NetrwBookHistHandler(2,b:netrw_curdir)<cr>
                               inoremap <buffer> <silent> mB	<c-o>:<c-u>call <SID>NetrwBookHistHandler(6,b:netrw_curdir)<cr>
                               inoremap <buffer> <silent> qf	<c-o>:<c-u>call <SID>NetrwFileInfo(0,<SID>NetrwGetWord())<cr>
                               inoremap <buffer> <silent> qF	:<c-u>call <SID>NetrwMarkFileQFEL(0,getqflist())<cr>
                               inoremap <buffer> <silent> r		<c-o>:let g:netrw_sort_direction= (g:netrw_sort_direction =~ 'n')? 'r' : 'n'<bar>exe "norm! 0"<bar>call <SID>NetrwBrowse(0,<SID>NetrwBrowseChgDir(0,'./'))<cr>
                               inoremap <buffer> <silent> s		<c-o>:call <SID>NetrwSortStyle(0)<cr>
                               inoremap <buffer> <silent> S		<c-o>:call <SID>NetSortSequence(0)<cr>
                               inoremap <buffer> <silent> t		<c-o>:call <SID>NetrwSplit(1)<cr>
                               inoremap <buffer> <silent> Tb	<c-o>:<c-u>call <SID>NetrwSetTgt('b',v:count1)<cr>
                               inoremap <buffer> <silent> Th	<c-o>:<c-u>call <SID>NetrwSetTgt('h',v:count)<cr>
                               inoremap <buffer> <silent> u		<c-o>:<c-u>call <SID>NetrwBookHistHandler(4,b:netrw_curdir)<cr>
                               inoremap <buffer> <silent> U		<c-o>:<c-u>call <SID>NetrwBookHistHandler(5,b:netrw_curdir)<cr>
                               inoremap <buffer> <silent> v		<c-o>:call <SID>NetrwSplit(2)<cr>
                               inoremap <buffer> <silent> x		<c-o>:call netrw#NetrwBrowseX(<SID>NetrwBrowseChgDir(0,<SID>NetrwGetWord()),1)<cr>
                               inoremap <buffer> <silent> %		<c-o>:call <SID>NetrwOpenFile(0)<cr>
                               if !hasmapto('<Plug>NetrwHideEdit')
                                nmap <buffer> <c-h> <Plug>NetrwHideEdit
                                imap <buffer> <c-h> <Plug>NetrwHideEdit
                               endif
                               nnoremap <buffer> <silent> <Plug>NetrwHideEdit	:call <SID>NetrwHideEdit(0)<cr>
                               if !hasmapto('<Plug>NetrwRefresh')
                                nmap <buffer> <c-l> <Plug>NetrwRefresh
                                imap <buffer> <c-l> <Plug>NetrwRefresh
                               endif
                            
                               let mapsafepath     = escape(s:path, s:netrw_map_escape)
                               let mapsafeusermach = escape(s:user.s:machine, s:netrw_map_escape)
                            
                               nnoremap <buffer> <silent> <Plug>NetrwRefresh	:call <SID>NetrwRefresh(0,<SID>NetrwBrowseChgDir(0,'./'))<cr>
                               if g:netrw_mousemaps == 1
                                nmap <leftmouse>		<Plug>NetrwLeftmouse
                                nno <buffer> <silent>	<Plug>NetrwLeftmouse	<leftmouse>:call <SID>NetrwLeftmouse(0)<cr>
                                nmap <buffer> <leftdrag>	<Plug>NetrwLeftdrag
                                nno  <buffer> <silent>	<Plug>NetrwLeftdrag	:call <SID>NetrwLeftdrag(0)<cr>
                                nmap <middlemouse>		<Plug>NetrwMiddlemouse
                                nno  <buffer> <silent>	<middlemouse>		<Plug>NetrwMiddlemouse <leftmouse>:call <SID>NetrwPrevWinOpen(0)<cr>
                                nmap <buffer> <s-leftmouse>	<Plug>NetrwSLeftmouse
                                nno  <buffer> <silent>	<Plug>NetrwSLeftmouse   <leftmouse>:call <SID>NetrwMarkFile(0,<SID>NetrwGetWord())<cr>
                                nmap <buffer> <2-leftmouse>	<Plug>Netrw2Leftmouse
                                nmap <buffer> <silent>	<Plug>Netrw2Leftmouse	-
                                imap <buffer> <leftmouse>	<Plug>ILeftmouse
                                ino  <buffer> <silent>	<Plug>ILeftmouse	<c-o><leftmouse><c-o>:call <SID>NetrwLeftmouse(0)<cr>
                                imap <buffer> <middlemouse>	<Plug>IMiddlemouse
                                ino  <buffer> <silent>	<Plug>IMiddlemouse	<c-o><leftmouse><c-o>:call <SID>NetrwPrevWinOpen(0)<cr>
                                imap <buffer> <s-leftmouse>	<Plug>ISLeftmouse
                                ino  <buffer> <silent>	<Plug>ISLeftmouse	<c-o><leftmouse><c-o>:call <SID>NetrwMarkFile(0,<SID>NetrwGetWord())<cr>
                                exe 'nnoremap <buffer> <silent> <rightmouse> <leftmouse>:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
                                exe 'vnoremap <buffer> <silent> <rightmouse> <leftmouse>:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
                                exe 'inoremap <buffer> <silent> <rightmouse> <c-o><leftmouse><c-o>:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
                               endif
                               exe 'nnoremap <buffer> <silent> <del>	:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
                               exe 'nnoremap <buffer> <silent> d		:call <SID>NetrwMakeDir("'.mapsafeusermach.'")<cr>'
                               exe 'nnoremap <buffer> <silent> D		:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
                               exe 'nnoremap <buffer> <silent> R		:call <SID>NetrwRemoteRename("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
                               exe 'vnoremap <buffer> <silent> <del>	:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
                               exe 'vnoremap <buffer> <silent> D		:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
                               exe 'vnoremap <buffer> <silent> R		:call <SID>NetrwRemoteRename("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
                               exe 'inoremap <buffer> <silent> <del>	<c-o>:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
                               exe 'inoremap <buffer> <silent> d		<c-o>:call <SID>NetrwMakeDir("'.mapsafeusermach.'")<cr>'
                               exe 'inoremap <buffer> <silent> D		<c-o>:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
                               exe 'inoremap <buffer> <silent> R		<c-o>:call <SID>NetrwRemoteRename("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
                               nnoremap <buffer> <F1>			:he netrw-quickhelp<cr>
                               inoremap <buffer> <F1>			<c-o>:he netrw-quickhelp<cr>
                              endif
                            
                              keepj call s:SetRexDir(a:islocal,b:netrw_curdir)
                            
                            "  call Dret("s:NetrwMaps")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:ExplorePatHls: converts an Explore pattern into a regular expression search pattern {{{2
    1              0.000003 fun! s:ExplorePatHls(pattern)
                            "  call Dfunc("s:ExplorePatHls(pattern<".a:pattern.">)")
                              let repat= substitute(a:pattern,'^**/\{1,2}','','')
                            "  call Decho("repat<".repat.">")
                              let repat= escape(repat,'][.\')
                            "  call Decho("repat<".repat.">")
                              let repat= '\<'.substitute(repat,'\*','\\(\\S\\+ \\)*\\S\\+','g').'\>'
                            "  call Dret("s:ExplorePatHls repat<".repat.">")
                              return repat
                            endfun
                            
                            " ---------------------------------------------------------------------
                            "  s:NetrwBookHistHandler: {{{2
                            "    0: (user: <mb>)   bookmark current directory
                            "    1: (user: <gb>)   change to the bookmarked directory
                            "    2: (user: <qb>)   list bookmarks
                            "    3: (browsing)     record current directory history
                            "    4: (user: <u>)    go up   (previous) bookmark
                            "    5: (user: <U>)    go down (next)     bookmark
                            "    6: (user: <mB>)   delete bookmark
    1              0.000003 fun! s:NetrwBookHistHandler(chg,curdir)
                            "  call Dfunc("s:NetrwBookHistHandler(chg=".a:chg." curdir<".a:curdir.">) cnt=".v:count." histcnt=".g:netrw_dirhist_cnt." histmax=".g:netrw_dirhistmax)
                              if !exists("g:netrw_dirhistmax") || g:netrw_dirhistmax <= 0
                            "   "  call Dret("s:NetrwBookHistHandler - suppressed due to g:netrw_dirhistmax")
                               return
                              endif
                            
                              let ykeep= @@
                              if a:chg == 0
                               " bookmark the current directory
                            "   call Decho("(user: <b>) bookmark the current directory")
                               if !exists("g:netrw_bookmarklist")
                                let g:netrw_bookmarklist= []
                               endif
                               if index(g:netrw_bookmarklist,a:curdir) == -1
                                " curdir not currently in g:netrw_bookmarklist, so include it
                                call add(g:netrw_bookmarklist,a:curdir)
                                call sort(g:netrw_bookmarklist)
                               endif
                               echo "bookmarked the current directory"
                            
                              elseif a:chg == 1
                               " change to the bookmarked directory
                            "   call Decho("(user: <".v:count."gb>) change to the bookmarked directory")
                               if exists("g:netrw_bookmarklist[v:count-1]")
                            "    call Decho("(user: <".v:count."gb>) bookmarklist=".string(g:netrw_bookmarklist))
                                exe "keepj e ".fnameescape(g:netrw_bookmarklist[v:count-1])
                               else
                                echomsg "Sorry, bookmark#".v:count." doesn't exist!"
                               endif
                            
                              elseif a:chg == 2
                            "   redraw!
                               let didwork= 0
                               " list user's bookmarks
                            "   call Decho("(user: <q>) list user's bookmarks")
                               if exists("g:netrw_bookmarklist")
                            "    call Decho('list '.len(g:netrw_bookmarklist).' bookmarks')
                                let cnt= 1
                                for bmd in g:netrw_bookmarklist
                            "     call Decho("Netrw Bookmark#".cnt.": ".g:netrw_bookmarklist[cnt-1])
                                 echo printf("Netrw Bookmark#%-2d: %s",cnt,g:netrw_bookmarklist[cnt-1])
                                 let didwork = 1
                                 let cnt     = cnt + 1
                                endfor
                               endif
                            
                               " list directory history
                               let cnt     = g:netrw_dirhist_cnt
                               let first   = 1
                               let histcnt = 0
                               if g:netrw_dirhistmax > 0
                                while ( first || cnt != g:netrw_dirhist_cnt )
                            "    call Decho("first=".first." cnt=".cnt." dirhist_cnt=".g:netrw_dirhist_cnt)
                                 if exists("g:netrw_dirhist_{cnt}")
                            "     call Decho("Netrw  History#".histcnt.": ".g:netrw_dirhist_{cnt})
                                  echo printf("Netrw  History#%-2d: %s",histcnt,g:netrw_dirhist_{cnt})
                                  let didwork= 1
                                 endif
                                 let histcnt = histcnt + 1
                                 let first   = 0
                                 let cnt     = ( cnt - 1 ) % g:netrw_dirhistmax
                                 if cnt < 0
                                  let cnt= cnt + g:netrw_dirhistmax
                                 endif
                                endwhile
                               else
                                let g:netrw_dirhist_cnt= 0
                               endif
                               if didwork
                                call inputsave()|call input("Press <cr> to continue")|call inputrestore()
                               endif
                            
                              elseif a:chg == 3
                               " saves most recently visited directories (when they differ)
                            "   call Decho("(browsing) record curdir history")
                               if !exists("g:netrw_dirhist_cnt") || !exists("g:netrw_dirhist_{g:netrw_dirhist_cnt}") || g:netrw_dirhist_{g:netrw_dirhist_cnt} != a:curdir
                                if g:netrw_dirhistmax > 0
                                 let g:netrw_dirhist_cnt                   = ( g:netrw_dirhist_cnt + 1 ) % g:netrw_dirhistmax
                                 let g:netrw_dirhist_{g:netrw_dirhist_cnt} = a:curdir
                                endif
                            "    call Decho("save dirhist#".g:netrw_dirhist_cnt."<".g:netrw_dirhist_{g:netrw_dirhist_cnt}.">")
                               endif
                            
                              elseif a:chg == 4
                               " u: change to the previous directory stored on the history list
                            "   call Decho("(user: <u>) chg to prev dir from history")
                               if g:netrw_dirhistmax > 0
                                let g:netrw_dirhist_cnt= ( g:netrw_dirhist_cnt - v:count1 ) % g:netrw_dirhistmax
                                if g:netrw_dirhist_cnt < 0
                                 let g:netrw_dirhist_cnt= g:netrw_dirhist_cnt + g:netrw_dirhistmax
                                endif
                               else
                                let g:netrw_dirhist_cnt= 0
                               endif
                               if exists("g:netrw_dirhist_{g:netrw_dirhist_cnt}")
                            "    call Decho("changedir u#".g:netrw_dirhist_cnt."<".g:netrw_dirhist_{g:netrw_dirhist_cnt}.">")
                                if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST && exists("b:netrw_curdir")
                                 setl ma noro
                            "     call Decho("(NetrwBookHistHandler) setl ma noro")
                                 sil! keepj %d
                                 setl nomod
                            "     call Decho("(NetrwBookHistHandler) setl nomod")
                            "     call Decho("(NetrwBookHistHandler)  ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
                                endif
                            "    "    call Decho("exe e! ".fnameescape(g:netrw_dirhist_{g:netrw_dirhist_cnt}))
                                exe "keepj e! ".fnameescape(g:netrw_dirhist_{g:netrw_dirhist_cnt})
                               else
                                if g:netrw_dirhistmax > 0
                                 let g:netrw_dirhist_cnt= ( g:netrw_dirhist_cnt + v:count1 ) % g:netrw_dirhistmax
                                else
                                 let g:netrw_dirhist_cnt= 0
                                endif
                                echo "Sorry, no predecessor directory exists yet"
                               endif
                            
                              elseif a:chg == 5
                               " U: change to the subsequent directory stored on the history list
                            "   call Decho("(user: <U>) chg to next dir from history")
                               if g:netrw_dirhistmax > 0
                                let g:netrw_dirhist_cnt= ( g:netrw_dirhist_cnt + 1 ) % g:netrw_dirhistmax
                                if exists("g:netrw_dirhist_{g:netrw_dirhist_cnt}")
                            "    call Decho("changedir U#".g:netrw_dirhist_cnt."<".g:netrw_dirhist_{g:netrw_dirhist_cnt}.">")
                                 if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST && exists("b:netrw_curdir")
                            "      call Decho("(NetrwBookHistHandler) setl ma noro")
                                  setl ma noro
                                  sil! keepj %d
                            "      call Decho("removed all lines from buffer (%d)")
                            "      call Decho("(NetrwBookHistHandler) setl nomod")
                                  setl nomod
                            "      call Decho("(set nomod)  ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
                                 endif
                            "    call Decho("exe e! ".fnameescape(g:netrw_dirhist_{g:netrw_dirhist_cnt}))
                                 exe "keepj e! ".fnameescape(g:netrw_dirhist_{g:netrw_dirhist_cnt})
                                else
                                 let g:netrw_dirhist_cnt= ( g:netrw_dirhist_cnt - 1 ) % g:netrw_dirhistmax
                                 if g:netrw_dirhist_cnt < 0
                                  let g:netrw_dirhist_cnt= g:netrw_dirhist_cnt + g:netrw_dirhistmax
                                 endif
                                 echo "Sorry, no successor directory exists yet"
                                endif
                               else
                                let g:netrw_dirhist_cnt= 0
                                echo "Sorry, no successor directory exists yet (g:netrw_dirhistmax is ".g:netrw_dirhistmax.")"
                               endif
                            
                              elseif a:chg == 6
                               " delete the v:count'th bookmark
                            "   call Decho("delete bookmark#".v:count."<".g:netrw_bookmarklist[v:count-1].">")
                               let savefile= s:NetrwHome()."/.netrwbook"
                               if filereadable(savefile)
                            "    call Decho("merge bookmarks (active and file)")
                                keepj call s:NetrwBookHistSave() " done here to merge bookmarks first
                            "    call Decho("bookmark delete savefile<".savefile.">")
                                keepj call delete(savefile)
                               endif
                            "   call Decho("remove g:netrw_bookmarklist[".(v:count-1)."]")
                               keepj call remove(g:netrw_bookmarklist,v:count-1)
                            "   call Decho("resulting g:netrw_bookmarklist=".string(g:netrw_bookmarklist))
                              endif
                              call s:NetrwBookmarkMenu()
                              call s:NetrwTgtMenu()
                              let @@= ykeep
                            "  call Dret("s:NetrwBookHistHandler")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwBookHistRead: this function reads bookmarks and history {{{2
                            "                      Sister function: s:NetrwBookHistSave()
    1              0.000003 fun! s:NetrwBookHistRead()
                            "  call Dfunc("s:NetrwBookHistRead()")
                              if !exists("g:netrw_dirhistmax") || g:netrw_dirhistmax <= 0
                            "   "  call Dret("s:NetrwBookHistRead - suppressed due to g:netrw_dirhistmax")
                               return
                              endif
                              let ykeep= @@
                              if !exists("s:netrw_initbookhist")
                               let home    = s:NetrwHome()
                               let savefile= home."/.netrwbook"
                               if filereadable(savefile)
                            "    call Decho("sourcing .netrwbook")
                                exe "keepalt keepj so ".savefile
                               endif
                               if g:netrw_dirhistmax > 0
                                let savefile= home."/.netrwhist"
                                if filereadable(savefile)
                            "    call Decho("sourcing .netrwhist")
                                 exe "keepalt keepj so ".savefile
                                endif
                                let s:netrw_initbookhist= 1
                                au VimLeave * call s:NetrwBookHistSave()
                               endif
                              endif
                              let @@= ykeep
                            "  call Dret("s:NetrwBookHistRead")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwBookHistSave: this function saves bookmarks and history {{{2
                            "                      Sister function: s:NetrwBookHistRead()
                            "                      I used to do this via viminfo but that appears to
                            "                      be unreliable for long-term storage
    1              0.000002 fun! s:NetrwBookHistSave()
                            "  call Dfunc("s:NetrwBookHistSave() dirhistmax=".g:netrw_dirhistmax)
                              if !exists("g:netrw_dirhistmax") || g:netrw_dirhistmax <= 0
                            "   call Dret("s:NetrwBookHistSave : dirhistmax=".g:netrw_dirhistmax)
                               return
                              endif
                            
                              let savefile= s:NetrwHome()."/.netrwhist"
                              1split
                              call s:NetrwEnew()
                              setl cino= com= cpo-=a cpo-=A fo=nroql2 tw=0 report=10000 noswf
                              setl nocin noai noci magic nospell nohid wig= noaw
                              setl ma noro write
                              if exists("+acd") | setl noacd | endif
                              sil! keepj keepalt %d
                            
                              " save .netrwhist -- no attempt to merge
                              sil! keepalt file .netrwhist
                              call setline(1,"let g:netrw_dirhistmax  =".g:netrw_dirhistmax)
                              call setline(2,"let g:netrw_dirhist_cnt =".g:netrw_dirhist_cnt)
                              let lastline = line("$")
                              let cnt      = 1
                              while cnt <= g:netrw_dirhist_cnt
                               call setline((cnt+lastline),'let g:netrw_dirhist_'.cnt."='".g:netrw_dirhist_{cnt}."'")
                               let cnt= cnt + 1
                              endwhile
                              exe "sil! w! ".savefile
                            
                              sil keepj %d
                              if exists("g:netrw_bookmarklist") && g:netrw_bookmarklist != []
                               " merge and write .netrwbook
                               let savefile= s:NetrwHome()."/.netrwbook"
                            
                               if filereadable(savefile)
                                let booklist= deepcopy(g:netrw_bookmarklist)
                                exe "sil keepj keepalt so ".savefile
                                for bdm in booklist
                                 if index(g:netrw_bookmarklist,bdm) == -1
                                  call add(g:netrw_bookmarklist,bdm)
                                 endif
                                endfor
                                call sort(g:netrw_bookmarklist)
                                exe "sil! w! ".savefile
                               endif
                            
                               " construct and save .netrwbook
                               call setline(1,"let g:netrw_bookmarklist= ".string(g:netrw_bookmarklist))
                               exe "sil! w! ".savefile
                              endif
                              let bgone= bufnr("%")
                              q!
                              exe "keepalt ".bgone."bwipe!"
                            
                            "  call Dret("s:NetrwBookHistSave")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwBrowse: This function uses the command in g:netrw_list_cmd to provide a {{{2
                            "  list of the contents of a local or remote directory.  It is assumed that the
                            "  g:netrw_list_cmd has a string, USEPORT HOSTNAME, that needs to be substituted
                            "  with the requested remote hostname first.
    1              0.000002 fun! s:NetrwBrowse(islocal,dirname)
                              if !exists("w:netrw_liststyle")|let w:netrw_liststyle= g:netrw_liststyle|endif
                            "  call Dfunc("s:NetrwBrowse(islocal=".a:islocal." dirname<".a:dirname.">) liststyle=".w:netrw_liststyle." ".g:loaded_netrw." buf#".bufnr("%")."<".bufname("%")."> win#".winnr())
                            "  call Decho("(NetrwBrowse) tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")." modified=".&modified." modifiable=".&modifiable." readonly=".&readonly)
                              " s:NetrwBrowse: initialize history {{{3
                              if !exists("s:netrw_initbookhist")
                               keepj call s:NetrwBookHistRead()
                              endif
                            
                              " s:NetrwBrowse: simplify the dirname (especially for ".."s in dirnames) {{{3
                              if a:dirname !~ '^\a\+://'
                               let dirname= simplify(a:dirname)
                              else
                               let dirname= a:dirname
                              endif
                            
                              if exists("s:netrw_skipbrowse")
                               unlet s:netrw_skipbrowse
                            "   call Decho("(NetrwBrowse)  ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
                            "   call Dret("s:NetrwBrowse : s:netrw_skipbrowse=".s:netrw_skipbrowse)
                               return
                              endif
                            
                              " s:NetrwBrowse: sanity checks: {{{3
                              if !exists("*shellescape")
                               keepj call netrw#ErrorMsg(s:ERROR,"netrw can't run -- your vim is missing shellescape()",69)
                            "   call Dret("s:NetrwBrowse : missing shellescape()")
                               return
                              endif
                              if !exists("*fnameescape")
                               keepj call netrw#ErrorMsg(s:ERROR,"netrw can't run -- your vim is missing fnameescape()",70)
                            "   call Dret("s:NetrwBrowse : missing fnameescape()")
                               return
                              endif
                            
                              " s:NetrwBrowse: save options: {{{3
                              call s:NetrwOptionSave("w:")                                                                                                            
                            
                              " s:NetrwBrowse: re-instate any marked files {{{3
                              if exists("s:netrwmarkfilelist_{bufnr('%')}")
                            "   call Decho("(NetrwBrowse) clearing marked files")
                               exe "2match netrwMarkFile /".s:netrwmarkfilemtch_{bufnr("%")}."/"
                              endif
                            
                              if a:islocal && exists("w:netrw_acdkeep") && w:netrw_acdkeep
                               " s:NetrwBrowse: set up "safe" options for local directory/file {{{3
                            "   call Decho("(NetrwBrowse) handle w:netrw_acdkeep:")
                            "   call Decho("(NetrwBrowse) keepjumps lcd ".fnameescape(dirname)." (due to w:netrw_acdkeep=".w:netrw_acdkeep." - acd=".&acd.")")
                               exe 'keepj lcd '.fnameescape(dirname)
                               call s:NetrwSafeOptions()
                            "   call Decho("(NetrwBrowse) getcwd<".getcwd().">")
                            
                              elseif !a:islocal && dirname !~ '[\/]$' && dirname !~ '^"'
                               " s:NetrwBrowse: looks like a remote regular file, attempt transfer {{{3
                            "   call Decho("(NetrwBrowse) attempt transfer as regular file<".dirname.">")
                            
                               " remove any filetype indicator from end of dirname, except for the
                               " "this is a directory" indicator (/).
                               " There shouldn't be one of those here, anyway.
                               let path= substitute(dirname,'[*=@|]\r\=$','','e')
                            "   call Decho("(NetrwBrowse) new path<".path.">")
                               call s:RemotePathAnalysis(dirname)
                            
                               " s:NetrwBrowse: remote-read the requested file into current buffer {{{3
                               keepj mark '
                               call s:NetrwEnew(dirname)
                               call s:NetrwSafeOptions()
                               setl ma noro
                            "   call Decho("(NetrwBrowse) setl ma noro")
                               let b:netrw_curdir = dirname
                               let url            = s:method."://".s:user.s:machine.(s:port ? ":".s:port : "")."/".s:path
                            "   call Decho("(NetrwBrowse) exe sil! keepalt file ".fnameescape(url)." (bt=".&bt.")")
                               exe "sil! keepj keepalt file ".fnameescape(url)
                               exe "sil! keepj keepalt doau BufReadPre ".fnameescape(s:fname)
                               sil call netrw#NetRead(2,url)
                               if s:path !~ '.tar.bz2$' && s:path !~ '.tar.gz' && s:path !~ '.tar.xz' && s:path !~ '.txz'
                                " netrw.vim and tar.vim have already handled decompression of the tarball; avoiding gzip.vim error
                                exe "sil keepj keepalt doau BufReadPost ".fnameescape(s:fname)
                               endif
                            
                               " s:NetrwBrowse: save certain window-oriented variables into buffer-oriented variables {{{3
                               call s:SetBufWinVars()
                               call s:NetrwOptionRestore("w:")
                            "   call Decho("(NetrwBrowse) setl ma nomod")
                               setl ma nomod
                            "   call Decho("(NetrwBrowse)  ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
                            
                            "   call Dret("s:NetrwBrowse : file<".s:fname.">")
                               return
                              endif
                            
                              " use buffer-oriented WinVars if buffer variables exist but associated window variables don't {{{3
                              call s:UseBufWinVars()
                            
                              " set up some variables {{{3
                              let b:netrw_browser_active = 1
                              let dirname                = dirname
                              let s:last_sort_by         = g:netrw_sort_by
                            
                              " set up menu {{{3
                              keepj call s:NetrwMenu(1)
                            
                              " get/set-up buffer {{{3
                              let reusing= s:NetrwGetBuffer(a:islocal,dirname)
                              " maintain markfile highlighting
                              if exists("s:netrwmarkfilemtch_{bufnr('%')}") && s:netrwmarkfilemtch_{bufnr("%")} != ""
                            "   call Decho("(NetrwBrowse) bufnr(%)=".bufnr('%'))
                            "   call Decho("(NetrwBrowse) exe 2match netrwMarkFile /".s:netrwmarkfilemtch_{bufnr("%")}."/")
                               exe "2match netrwMarkFile /".s:netrwmarkfilemtch_{bufnr("%")}."/"
                              else
                            "   call Decho("(NetrwBrowse) 2match none")
                               2match none
                              endif
                              if reusing && line("$") > 1
                               call s:NetrwOptionRestore("w:")
                            "   call Decho("(NetrwBrowse) setl noma nomod nowrap")
                               setl noma nomod nowrap
                            "   call Decho("(NetrwBrowse) (set noma nomod nowrap)  ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
                            "   call Dret("s:NetrwBrowse : re-using buffer")
                               return
                              endif
                            
                              " set b:netrw_curdir to the new directory name {{{3
                            "  call Decho("(NetrwBrowse) set b:netrw_curdir to the new directory name:  (buf#".bufnr("%").")")
                              let b:netrw_curdir= dirname
                              if b:netrw_curdir =~ '[/\\]$'
                               let b:netrw_curdir= substitute(b:netrw_curdir,'[/\\]$','','e')
                              endif
                              if b:netrw_curdir == ''
                               if has("amiga")
                                " On the Amiga, the empty string connotes the current directory
                                let b:netrw_curdir= getcwd()
                               else
                                " under unix, when the root directory is encountered, the result
                                " from the preceding substitute is an empty string.
                                let b:netrw_curdir= '/'
                               endif
                              endif
                              if !a:islocal && b:netrw_curdir !~ '/$'
                               let b:netrw_curdir= b:netrw_curdir.'/'
                              endif
                            "  call Decho("(NetrwBrowse) b:netrw_curdir<".b:netrw_curdir.">")
                            
                              " ------------
                              " (local only) {{{3
                              " ------------
                              if a:islocal
                            "   call Decho("(NetrwBrowse) local only:")
                            
                               " Set up ShellCmdPost handling.  Append current buffer to browselist
                               call s:LocalFastBrowser()
                            
                              " handle g:netrw_keepdir: set vim's current directory to netrw's notion of the current directory {{{3
                               if !g:netrw_keepdir
                            "    call Decho("(NetrwBrowse) handle g:netrw_keepdir=".g:netrw_keepdir.": getcwd<".getcwd()."> acd=".&acd)
                            "    call Decho("(NetrwBrowse) l:acd".(exists("&l:acd")? "=".&l:acd : " doesn't exist"))
                                if !exists("&l:acd") || !&l:acd
                            "     call Decho('exe keepjumps lcd '.fnameescape(b:netrw_curdir))
                                 try
                                  exe 'keepj lcd '.fnameescape(b:netrw_curdir)
                                 catch /^Vim\%((\a\+)\)\=:E472/
                                  call netrw#ErrorMsg(s:ERROR,"unable to change directory to <".b:netrw_curdir."> (permissions?)",61)
                                  if exists("w:netrw_prvdir")
                                   let b:netrw_curdir= w:netrw_prvdir
                                  else
                                   call s:NetrwOptionRestore("w:")
                            "       call Decho("(NetrwBrowse) setl noma nomod nowrap")
                                   setl noma nomod nowrap
                            "       call Decho("(NetrwBrowse)  ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
                                   let b:netrw_curdir= dirname
                            "       call Dret("s:NetrwBrowse : reusing buffer#".(exists("bufnum")? bufnum : 'N/A')."<".dirname."> getcwd<".getcwd().">")
                                   return
                                  endif
                                 endtry
                                endif
                               endif
                            
                              " --------------------------------
                              " remote handling: {{{3
                              " --------------------------------
                              else
                            "   call Decho("(NetrwBrowse) remote only:")
                            
                               " analyze dirname and g:netrw_list_cmd {{{3
                            "   call Decho("(NetrwBrowse) b:netrw_curdir<".(exists("b:netrw_curdir")? b:netrw_curdir : "doesn't exist")."> dirname<".dirname.">")
                               if dirname =~ "^NetrwTreeListing\>"
                                let dirname= b:netrw_curdir
                            "    call Decho("(NetrwBrowse) (dirname was <NetrwTreeListing>) dirname<".dirname.">")
                               elseif exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST && exists("b:netrw_curdir")
                                let dirname= substitute(b:netrw_curdir,'\\','/','g')
                                if dirname !~ '/$'
                                 let dirname= dirname.'/'
                                endif
                                let b:netrw_curdir = dirname
                            "    call Decho("(NetrwBrowse) (liststyle is TREELIST) dirname<".dirname.">")
                               else
                                let dirname = substitute(dirname,'\\','/','g')
                            "    call Decho("(NetrwBrowse) (normal) dirname<".dirname.">")
                               endif
                            
                               let dirpat  = '^\(\w\{-}\)://\(\w\+@\)\=\([^/]\+\)/\(.*\)$'
                               if dirname !~ dirpat
                                if !exists("g:netrw_quiet")
                                 keepj call netrw#ErrorMsg(s:ERROR,"netrw doesn't understand your dirname<".dirname.">",20)
                                endif
                                keepj call s:NetrwOptionRestore("w:")
                            "    call Decho("(NetrwBrowse) setl noma nomod nowrap")
                                setl noma nomod nowrap
                            "    call Decho("(NetrwBrowse)  ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
                            "    call Dret("s:NetrwBrowse : badly formatted dirname<".dirname.">")
                                return
                               endif
                               let b:netrw_curdir= dirname
                            "   call Decho("(NetrwBrowse) b:netrw_curdir<".b:netrw_curdir."> (remote)")
                              endif  " (additional remote handling)
                            
                              " -----------------------
                              " Directory Listing: {{{3
                              " -----------------------
                              keepj call s:NetrwMaps(a:islocal)
                              keepj call s:PerformListing(a:islocal)
                              if v:version >= 700 && has("balloon_eval") && &beval == 0 && &l:bexpr == "" && !exists("g:netrw_nobeval")
                               let &l:bexpr= "netrw#NetrwBalloonHelp()"
                            "   call Decho("(NetrwBrowse) set up balloon help: l:bexpr=".&l:bexpr)
                               set beval
                              endif
                              call s:NetrwOptionRestore("w:")
                            
                              " The s:LocalBrowseShellCmdRefresh() function is called by an autocmd
                              " installed by s:LocalFastBrowser() when g:netrw_fastbrowse <= 1 (ie. slow, medium speed).
                              " However, s:NetrwBrowse() causes the ShellCmdPost event itself to fire once; setting
                              " the variable below avoids that second refresh of the screen.  The s:LocalBrowseShellCmdRefresh()
                              " function gets called due to that autocmd; it notices that the following variable is set
                              " and skips the refresh and sets s:locbrowseshellcmd to zero. Oct 13, 2008
                              let s:locbrowseshellcmd= 1
                            
                            "  call Decho("(NetrwBrowse) ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
                            "  call Dret("s:NetrwBrowse : did PerformListing  ft<".&ft.">")
                              return
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwFileInfo: supports qf (query for file information) {{{2
    1              0.000003 fun! s:NetrwFileInfo(islocal,fname)
                            "  call Dfunc("s:NetrwFileInfo(islocal=".a:islocal." fname<".a:fname.">)")
                              let ykeep= @@
                              if a:islocal
                               if (has("unix") || has("macunix")) && executable("/bin/ls")
                                if exists("b:netrw_curdir")
                            "     call Decho('using ls with b:netrw_curdir<'.b:netrw_curdir.'>')
                                 if b:netrw_curdir =~ '/$'
                                  echo system("/bin/ls -lsad ".shellescape(b:netrw_curdir.a:fname))
                                 else
                                  echo system("/bin/ls -lsad ".shellescape(b:netrw_curdir."/".a:fname))
                                 endif
                                else
                            "     call Decho('using ls '.a:fname." using cwd<".getcwd().">")
                                 echo system("/bin/ls -lsad ".shellescape(a:fname))
                                endif
                               else
                                " use vim functions to return information about file below cursor
                            "    call Decho("using vim functions to query for file info")
                                if !isdirectory(a:fname) && !filereadable(a:fname) && a:fname =~ '[*@/]'
                                 let fname= substitute(a:fname,".$","","")
                                else
                                 let fname= a:fname
                                endif
                                let t  = getftime(fname)
                                let sz = getfsize(fname)
                                echo a:fname.":  ".sz."  ".strftime(g:netrw_timefmt,getftime(fname))
                            "    call Decho(fname.":  ".sz."  ".strftime(g:netrw_timefmt,getftime(fname)))
                               endif
                              else
                               echo "sorry, \"qf\" not supported yet for remote files"
                              endif
                              let @@= ykeep
                            "  call Dret("s:NetrwFileInfo")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwGetBuffer: {{{2
                            "   returns 0=cleared buffer
                            "           1=re-used buffer
    1              0.000003 fun! s:NetrwGetBuffer(islocal,dirname)
                            "  call Dfunc("s:NetrwGetBuffer(islocal=".a:islocal." dirname<".a:dirname.">) liststyle=".g:netrw_liststyle)
                            "  call Decho("(NetrwGetBuffer) modiable=".&mod." modifiable=".&ma." readonly=".&ro)
                              let dirname= a:dirname
                            
                              " re-use buffer if possible {{{3
                            "  call Decho("(NetrwGetBuffer) --re-use a buffer if possible--")
                              if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST
                               " find NetrwTreeList buffer if there is one
                            "   call Decho("(NetrwGetBuffer) case liststyle=treelist: find NetrwTreeList buffer if there is one")
                               if exists("w:netrw_treebufnr") && w:netrw_treebufnr > 0
                            "    call Decho("(NetrwGetBuffer)   re-using w:netrw_treebufnr=".w:netrw_treebufnr)
                                setl mod
                                sil! keepj %d
                                let eikeep= &ei
                                set ei=all
                                exe "sil! keepalt b ".w:netrw_treebufnr
                                let &ei= eikeep
                            "    call Dret("s:NetrwGetBuffer 0<buffer cleared> : bufnum#".w:netrw_treebufnr."<NetrwTreeListing>")
                                return 0
                               endif
                               let bufnum= -1
                            "   call Decho("(NetrwGetBuffer)   liststyle=TREE but w:netrw_treebufnr doesn't exist")
                            
                              else
                               " find buffer number of buffer named precisely the same as dirname {{{3
                            "   call Decho("(NetrwGetBuffer) case listtyle not treelist: find buffer numnber of buffer named precisely the same as dirname--")
                            
                               " get dirname and associated buffer number
                               let bufnum  = bufnr(escape(dirname,'\'))
                            "   call Decho("(NetrwGetBuffer)   find buffer<".dirname.">'s number ")
                            "   call Decho("(NetrwGetBuffer)   bufnr(dirname<".escape(dirname,'\').">)=".bufnum)
                            
                               if bufnum < 0 && dirname !~ '/$'
                                " try appending a trailing /
                            "    call Decho("(NetrwGetBuffer)   try appending a trailing / to dirname<".dirname.">")
                                let bufnum= bufnr(escape(dirname.'/','\'))
                                if bufnum > 0
                                 let dirname= dirname.'/'
                                endif
                               endif
                            
                               if bufnum < 0 && dirname =~ '/$'
                                " try removing a trailing /
                            "    call Decho("(NetrwGetBuffer)   try removing a trailing / from dirname<".dirname.">")
                                let bufnum= bufnr(escape(substitute(dirname,'/$','',''),'\'))
                                if bufnum > 0
                                 let dirname= substitute(dirname,'/$','','')
                                endif
                               endif
                            
                            "   call Decho("(NetrwGetBuffer)   findbuf1: bufnum=bufnr('".dirname."')=".bufnum." bufname(".bufnum.")<".bufname(bufnum)."> (initial)")
                               " note: !~ was used just below, but that means using ../ to go back would match (ie. abc/def/  and abc/ matches)
                               if bufnum > 0 && bufname(bufnum) != dirname && bufname(bufnum) != '.'
                                " handle approximate matches
                            "    call Decho("(NetrwGetBuffer)   handling approx match: bufnum#".bufnum.">0 AND bufname<".bufname(bufnum).">!=dirname<".dirname."> AND bufname(".bufnum.")!='.'")
                                let ibuf    = 1
                                let buflast = bufnr("$")
                            "    call Decho("(NetrwGetBuffer)   findbuf2: buflast=bufnr($)=".buflast)
                                while ibuf <= buflast
                                 let bname= substitute(bufname(ibuf),'\\','/','g')
                                 let bname= substitute(bname,'.\zs/$','','')
                            "     call Decho("(NetrwGetBuffer)   findbuf3: while [ibuf=",ibuf."]<=[buflast=".buflast."]: dirname<".dirname."> bname=bufname(".ibuf.")<".bname.">")
                                 if bname != '' && dirname =~ '/'.bname.'/\=$' && dirname !~ '^/'
                                  " bname is not empty
                                  " dirname ends with bname,
                                  " dirname doesn't start with /, so its not a absolute path
                            "      call Decho("(NetrwGetBuffer)   findbuf3a: passes test 1 : dirname<".dirname.'> =~ /'.bname.'/\=$ && dirname !~ ^/')
                                  break
                                 endif
                                 if bname =~ '^'.dirname.'/\=$'
                                  " bname begins with dirname
                            "      call Decho('  findbuf3b: passes test 2 : bname<'.bname.'>=~^'.dirname.'/\=$')
                                  break
                                 endif
                                 if dirname =~ '^'.bname.'/$'
                            "      call Decho('  findbuf3c: passes test 3 : dirname<'.dirname.'>=~^'.bname.'/$')
                                  break
                                 endif
                                 if bname != '' && dirname =~ '/'.bname.'$' && bname == bufname("%") && line("$") == 1
                            "      call Decho('  findbuf3d: passes test 4 : dirname<'.dirname.'>=~ /'.bname.'$')
                                  break
                                 endif
                                 let ibuf= ibuf + 1
                                endwhile
                                if ibuf > buflast
                                 let bufnum= -1
                                else
                                 let bufnum= ibuf
                                endif
                            "    call Decho("(NetrwGetBuffer)   findbuf4: bufnum=".bufnum." (ibuf=".ibuf." buflast=".buflast.")")
                               endif
                              endif
                            
                              " get enew buffer and name it -or- re-use buffer {{{3
                            "  call Decho("(NetrwGetBuffer)   get enew buffer and name it OR re-use buffer")
                              sil! keepj keepalt mark '
                              if bufnum < 0 || !bufexists(bufnum)
                            "   call Decho("(NetrwGetBuffer) --get enew buffer and name it  (bufnum#".bufnum."<0 OR bufexists(".bufnum.")=".bufexists(bufnum)."==0)")
                               call s:NetrwEnew(dirname)
                            "   call Decho("(NetrwGetBuffer)   got enew buffer#".bufnr("%")." (altbuf<".expand("#").">)")
                               " name the buffer
                               if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST
                                " Got enew buffer; transform into a NetrwTreeListing
                            "    call Decho("(NetrwGetBuffer) --transform enew buffer#".bufnr("%")." into a NetrwTreeListing --")
                                if !exists("s:netrw_treelistnum")
                                 let s:netrw_treelistnum= 1
                                else
                                 let s:netrw_treelistnum= s:netrw_treelistnum + 1
                                endif
                                let w:netrw_treebufnr= bufnr("%")
                            "    call Decho("(NetrwGetBuffer)   exe sil! keepalt file NetrwTreeListing ".fnameescape(s:netrw_treelistnum))
                                exe 'sil! keepalt file NetrwTreeListing\ '.fnameescape(s:netrw_treelistnum)
                                set bt=nofile noswf
                                nnoremap <silent> <buffer> [	:sil call <SID>TreeListMove('[')<cr>
                                nnoremap <silent> <buffer> ]	:sil call <SID>TreeListMove(']')<cr>
                                nnoremap <silent> <buffer> [[       :sil call <SID>TreeListMove('[')<cr>
                                nnoremap <silent> <buffer> ]]       :sil call <SID>TreeListMove(']')<cr>
                            "    call Decho("(NetrwGetBuffer)   tree listing#".s:netrw_treelistnum." bufnr=".w:netrw_treebufnr)
                               else
                            "    let v:errmsg= "" " Decho
                                let escdirname= fnameescape(dirname)
                            "    call Decho("(NetrwGetBuffer)   errmsg<".v:errmsg."> bufnr(escdirname<".escdirname.">)=".bufnr(escdirname)." bufname()<".bufname(bufnr(escdirname)).">")
                            "    call Decho('  exe sil! keepalt file '.escdirname)
                            "    let v:errmsg= "" " Decho
                                exe 'sil! keepalt file '.escdirname
                            "    call Decho("(NetrwGetBuffer)   errmsg<".v:errmsg."> bufnr(".escdirname.")=".bufnr(escdirname)."<".bufname(bufnr(escdirname)).">")
                               endif
                            "   call Decho("(NetrwGetBuffer)   named enew buffer#".bufnr("%")."<".bufname("%").">")
                            
                              else " Re-use the buffer
                            "   call Decho("(NetrwGetBuffer) --re-use buffer#".bufnum." (bufnum#".bufnum.">=0 AND bufexists(".bufnum.")=".bufexists(bufnum)."!=0)")
                               let eikeep= &ei
                               set ei=all
                               if getline(2) =~ '^" Netrw Directory Listing'
                            "    call Decho("(NetrwGetBuffer)   getline(2)<".getline(2).'> matches "Netrw Directory Listing" : using keepalt b '.bufnum)
                                exe "sil! keepalt b ".bufnum
                               else
                            "    call Decho("(NetrwGetBuffer)   getline(2)<".getline(2).'> does not match "Netrw Directory Listing" : using b '.bufnum)
                                exe "sil! keepalt b ".bufnum
                               endif
                               if bufname("%") == '.'
                            "    call Decho("(NetrwGetBuffer) exe sil! keepalt file ".fnameescape(getcwd()))
                                exe "sil! keepalt file ".fnameescape(getcwd())
                               endif
                               let &ei= eikeep
                               if line("$") <= 1
                                keepj call s:NetrwListSettings(a:islocal)
                            "    call Dret("s:NetrwGetBuffer 0<buffer empty> : re-using buffer#".bufnr("%").", but its empty, so refresh it")
                                return 0
                               elseif g:netrw_fastbrowse == 0 || (a:islocal && g:netrw_fastbrowse == 1)
                                keepj call s:NetrwListSettings(a:islocal)
                                sil keepj %d
                            "    call Dret("s:NetrwGetBuffer 0<cleared buffer> : re-using buffer#".bufnr("%").", but refreshing due to g:netrw_fastbrowse=".g:netrw_fastbrowse)
                                return 0
                               elseif exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST
                            "    call Decho("(NetrwGetBuffer) --re-use tree listing--")
                            "    call Decho("(NetrwGetBuffer)   clear buffer<".expand("%")."> with :%d")
                                sil keepj %d
                                keepj call s:NetrwListSettings(a:islocal)
                            "    call Dret("s:NetrwGetBuffer 0<cleared buffer> : re-using buffer#".bufnr("%").", but treelist mode always needs a refresh")
                                return 0
                               else
                            "    call Dret("s:NetrwGetBuffer 1<buffer not cleared> : buf#".bufnr("%"))
                                return 1
                               endif
                              endif
                            
                              " do netrw settings: make this buffer not-a-file, modifiable, not line-numbered, etc {{{3
                              "     fastbrowse  Local  Remote   Hiding a buffer implies it may be re-used (fast)
                              "  slow   0         D      D      Deleting a buffer implies it will not be re-used (slow)
                              "  med    1         D      H
                              "  fast   2         H      H
                            "  call Decho("(NetrwGetBuffer) --do netrw settings: make this buffer#".bufnr("%")." not-a-file, modifiable, not line-numbered, etc--")
                              let fname= expand("%")
                              keepj call s:NetrwListSettings(a:islocal)
                            "  call Decho("(NetrwGetBuffer) exe sil! keepalt file ".fnameescape(fname))
                              exe "sil! keepj keepalt file ".fnameescape(fname)
                            
                              " delete all lines from buffer {{{3
                            "  call Decho("(NetrwGetBuffer) --delete all lines from buffer--")
                            "  call Decho("(NetrwGetBuffer)   clear buffer<".expand("%")."> with :%d")
                              sil! keepalt keepj %d
                            
                            "  call Dret("s:NetrwGetBuffer 0<cleared buffer> : tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> modified=".&modified." modifiable=".&modifiable." readonly=".&readonly)
                              return 0
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwGetcwd: get the current directory. {{{2
                            "   Change backslashes to forward slashes, if any.
                            "   If doesc is true, escape certain troublesome characters
    1              0.000008 fun! s:NetrwGetcwd(doesc)
                            "  call Dfunc("NetrwGetcwd(doesc=".a:doesc.")")
                              let curdir= substitute(getcwd(),'\\','/','ge')
                              if curdir !~ '[\/]$'
                               let curdir= curdir.'/'
                              endif
                              if a:doesc
                               let curdir= fnameescape(curdir)
                              endif
                            "  call Dret("NetrwGetcwd <".curdir.">")
                              return curdir
                            endfun
                            
                            " ---------------------------------------------------------------------
                            "  s:NetrwGetWord: it gets the directory/file named under the cursor {{{2
    1              0.000005 fun! s:NetrwGetWord()
                            "  call Dfunc("s:NetrwGetWord() line#".line(".")." liststyle=".g:netrw_liststyle." virtcol=".virtcol("."))
                              call s:UseBufWinVars()
                            
                              " insure that w:netrw_liststyle is set up
                              if !exists("w:netrw_liststyle")
                               if exists("g:netrw_liststyle")
                                let w:netrw_liststyle= g:netrw_liststyle
                               else
                                let w:netrw_liststyle= s:THINLIST
                               endif
                            "   call Decho("w:netrw_liststyle=".w:netrw_liststyle)
                              endif
                            
                              if exists("w:netrw_bannercnt") && line(".") < w:netrw_bannercnt
                               " Active Banner support
                            "   call Decho("active banner handling")
                               keepj norm! 0
                               let dirname= "./"
                               let curline= getline('.')
                            
                               if curline =~ '"\s*Sorted by\s'
                                keepj norm s
                                let s:netrw_skipbrowse= 1
                                echo 'Pressing "s" also works'
                            
                               elseif curline =~ '"\s*Sort sequence:'
                                let s:netrw_skipbrowse= 1
                                echo 'Press "S" to edit sorting sequence'
                            
                               elseif curline =~ '"\s*Quick Help:'
                                keepj norm ?
                                let s:netrw_skipbrowse= 1
                                echo 'Pressing "?" also works'
                            
                               elseif curline =~ '"\s*\%(Hiding\|Showing\):'
                                keepj norm a
                                let s:netrw_skipbrowse= 1
                                echo 'Pressing "a" also works'
                            
                               elseif line("$") > w:netrw_bannercnt
                                exe 'sil keepj '.w:netrw_bannercnt
                               endif
                            
                              elseif w:netrw_liststyle == s:THINLIST
                            "   call Decho("thin column handling")
                               keepj norm! 0
                               let dirname= getline('.')
                            
                              elseif w:netrw_liststyle == s:LONGLIST
                            "   call Decho("long column handling")
                               keepj norm! 0
                               let dirname= substitute(getline('.'),'^\(\%(\S\+ \)*\S\+\).\{-}$','\1','e')
                            
                              elseif w:netrw_liststyle == s:TREELIST
                            "   call Decho("treelist handling")
                               let dirname= substitute(getline('.'),'^\(| \)*','','e')
                            
                              else
                            "   call Decho("obtain word from wide listing")
                               let dirname= getline('.')
                            
                               if !exists("b:netrw_cpf")
                                let b:netrw_cpf= 0
                                exe 'sil keepj '.w:netrw_bannercnt.',$g/^./if virtcol("$") > b:netrw_cpf|let b:netrw_cpf= virtcol("$")|endif'
                                call histdel("/",-1)
                            "   call Decho("computed cpf=".b:netrw_cpf)
                               endif
                            
                            "   call Decho("buf#".bufnr("%")."<".bufname("%").">")
                               let filestart = (virtcol(".")/b:netrw_cpf)*b:netrw_cpf
                            "   call Decho("filestart= ([virtcol=".virtcol(".")."]/[b:netrw_cpf=".b:netrw_cpf."])*b:netrw_cpf=".filestart."  bannercnt=".w:netrw_bannercnt)
                            "   call Decho("1: dirname<".dirname.">")
                               if filestart == 0
                                keepj norm! 0ma
                               else
                                call cursor(line("."),filestart+1)
                                keepj norm! ma
                               endif
                               let rega= @a
                               let eofname= filestart + b:netrw_cpf + 1
                               if eofname <= col("$")
                                call cursor(line("."),filestart+b:netrw_cpf+1)
                                keepj norm! "ay`a
                               else
                                keepj norm! "ay$
                               endif
                               let dirname = @a
                               let @a      = rega
                            "   call Decho("2: dirname<".dirname.">")
                               let dirname= substitute(dirname,'\s\+$','','e')
                            "   call Decho("3: dirname<".dirname.">")
                              endif
                            
                              " symlinks are indicated by a trailing "@".  Remove it before further processing.
                              let dirname= substitute(dirname,"@$","","")
                            
                              " executables are indicated by a trailing "*".  Remove it before further processing.
                              let dirname= substitute(dirname,"\*$","","")
                            
                            "  call Dret("s:NetrwGetWord <".dirname.">")
                              return dirname
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwListSettings: make standard settings for a netrw listing {{{2
    1              0.000004 fun! s:NetrwListSettings(islocal)
                            "  call Dfunc("s:NetrwListSettings(islocal=".a:islocal.")")
                              let fname= bufname("%")
                            "  call Decho("(NetrwListSettings) setl bt=nofile nobl ma nonu nowrap noro")
                              setl bt=nofile nobl ma nonu nowrap noro
                            "  call Decho("(NetrwListSettings) exe sil! keepalt file ".fnameescape(fname))
                              exe "sil! keepalt file ".fnameescape(fname)
                              if g:netrw_use_noswf
                               setl noswf
                              endif
                            "  call Decho("(NetrwListSettings) exe setl ts=".(g:netrw_maxfilenamelen+1))
                              exe "setl ts=".(g:netrw_maxfilenamelen+1)
                              setl isk+=.,~,-
                              if g:netrw_fastbrowse > a:islocal
                               setl bh=hide
                              else
                               setl bh=delete
                              endif
                            "  call Dret("s:NetrwListSettings")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            "  s:NetrwListStyle: {{{2
                            "  islocal=0: remote browsing
                            "         =1: local browsing
    1              0.000002 fun! s:NetrwListStyle(islocal)
                            "  call Dfunc("NetrwListStyle(islocal=".a:islocal.") w:netrw_liststyle=".w:netrw_liststyle)
                              let ykeep             = @@
                              let fname             = s:NetrwGetWord()
                              if !exists("w:netrw_liststyle")|let w:netrw_liststyle= g:netrw_liststyle|endif
                              let w:netrw_liststyle = (w:netrw_liststyle + 1) % s:MAXLIST
                            "  call Decho("fname<".fname.">")
                            "  call Decho("chgd w:netrw_liststyle to ".w:netrw_liststyle)
                            "  call Decho("b:netrw_curdir<".(exists("b:netrw_curdir")? b:netrw_curdir : "doesn't exist").">")
                            
                              if w:netrw_liststyle == s:THINLIST
                               " use one column listing
                            "   call Decho("use one column list")
                               let g:netrw_list_cmd = substitute(g:netrw_list_cmd,' -l','','ge')
                            
                              elseif w:netrw_liststyle == s:LONGLIST
                               " use long list
                            "   call Decho("use long list")
                               let g:netrw_list_cmd = g:netrw_list_cmd." -l"
                            
                              elseif w:netrw_liststyle == s:WIDELIST
                               " give wide list
                            "   call Decho("use wide list")
                               let g:netrw_list_cmd = substitute(g:netrw_list_cmd,' -l','','ge')
                            
                              elseif w:netrw_liststyle == s:TREELIST
                            "   call Decho("use tree list")
                               let g:netrw_list_cmd = substitute(g:netrw_list_cmd,' -l','','ge')
                            
                              else
                               keepj call netrw#ErrorMsg(s:WARNING,"bad value for g:netrw_liststyle (=".w:netrw_liststyle.")",46)
                               let g:netrw_liststyle = s:THINLIST
                               let w:netrw_liststyle = g:netrw_liststyle
                               let g:netrw_list_cmd  = substitute(g:netrw_list_cmd,' -l','','ge')
                              endif
                              setl ma noro
                            "  call Decho("setl ma noro")
                            
                              " clear buffer - this will cause NetrwBrowse/LocalBrowseCheck to do a refresh
                            "  call Decho("clear buffer<".expand("%")."> with :%d")
                              sil! keepj %d
                              " following prevents tree listing buffer from being marked "modified"
                            "  call Decho("(NetrwListStyle) setl nomod")
                              setl nomod
                            "  call Decho("(NetrwListStyle) ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
                            
                              " refresh the listing
                            "  call Decho("(NetrwListStyle) refresh the listing")
                              let svpos= netrw#NetrwSavePosn()
                              keepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
                              keepj call netrw#NetrwRestorePosn(svpos)
                              keepj call s:NetrwCursor()
                            
                              " keep cursor on the filename
                              sil! keepj $
                              let result= search('\%(^\%(|\+\s\)\=\|\s\{2,}\)\zs'.escape(fname,'.\[]*$^').'\%(\s\{2,}\|$\)','bc')
                            "  call Decho("search result=".result." w:netrw_bannercnt=".(exists("w:netrw_bannercnt")? w:netrw_bannercnt : 'N/A'))
                              if result <= 0 && exists("w:netrw_bannercnt")
                               exe "sil! keepj ".w:netrw_bannercnt
                              endif
                              let @@= ykeep
                            
                            "  call Dret("NetrwListStyle".(exists("w:netrw_liststyle")? ' : w:netrw_liststyle='.w:netrw_liststyle : ""))
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwBannerCtrl: toggles the display of the banner {{{2
    1              0.000005 fun! s:NetrwBannerCtrl(islocal)
                            "  call Dfunc("s:NetrwBannerCtrl(islocal=".a:islocal.") g:netrw_banner=".g:netrw_banner)
                            
                              let ykeep= @@
                              " toggle the banner (enable/suppress)
                              let g:netrw_banner= !g:netrw_banner
                            
                              " refresh the listing
                              let svpos= netrw#NetrwSavePosn()
                              call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
                            
                              " keep cursor on the filename
                              let fname= s:NetrwGetWord()
                              sil keepj $
                              let result= search('\%(^\%(|\+\s\)\=\|\s\{2,}\)\zs'.escape(fname,'.\[]*$^').'\%(\s\{2,}\|$\)','bc')
                            "  call Decho("search result=".result." w:netrw_bannercnt=".(exists("w:netrw_bannercnt")? w:netrw_bannercnt : 'N/A'))
                              if result <= 0 && exists("w:netrw_bannercnt")
                               exe "keepj ".w:netrw_bannercnt
                              endif
                              let @@= ykeep
                            "  call Dret("s:NetrwBannerCtrl : g:netrw_banner=".g:netrw_banner)
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwBookmarkMenu: Uses menu priorities {{{2
                            "                      .2.[cnt] for bookmarks, and
                            "                      .3.[cnt] for history
                            "                      (see s:NetrwMenu())
    1              0.000005 fun! s:NetrwBookmarkMenu()
                              if !exists("s:netrw_menucnt")
                               return
                              endif
                            "  call Dfunc("NetrwBookmarkMenu()  histcnt=".g:netrw_dirhist_cnt." menucnt=".s:netrw_menucnt)
                            
                              " the following test assures that gvim is running, has menus available, and has menus enabled.
                              if has("gui") && has("menu") && has("gui_running") && &go =~# 'm' && g:netrw_menu
                               if exists("g:NetrwTopLvlMenu")
                            "    call Decho("removing ".g:NetrwTopLvlMenu."Bookmarks menu item(s)")
                                exe 'sil! unmenu '.g:NetrwTopLvlMenu.'Bookmarks'
                                exe 'sil! unmenu '.g:NetrwTopLvlMenu.'Bookmarks\ and\ History.Bookmark\ Delete'
                               endif
                               if !exists("s:netrw_initbookhist")
                                call s:NetrwBookHistRead()
                               endif
                            
                               " show bookmarked places
                               if exists("g:netrw_bookmarklist") && g:netrw_bookmarklist != [] && g:netrw_dirhistmax > 0
                                let cnt= 1
                                for bmd in g:netrw_bookmarklist
                                 let ebmd= escape(bmd,g:netrw_menu_escape)
                            "     call Decho('sil! menu '.g:NetrwMenuPriority.".2.".cnt." ".g:NetrwTopLvlMenu.'Bookmark.'.ebmd.'	:e '.bmd)
                            
                                 " show bookmarks for goto menu
                                 exe 'sil! menu '.g:NetrwMenuPriority.".2.".cnt." ".g:NetrwTopLvlMenu.'Bookmarks.'.ebmd.'	:e '.bmd."\<cr>"
                            
                                 " show bookmarks for deletion menu
                                 exe 'sil! menu '.g:NetrwMenuPriority.".8.2.".cnt." ".g:NetrwTopLvlMenu.'Bookmarks\ and\ History.Bookmark\ Delete.'.ebmd.'	'.cnt."mB"
                                 let cnt= cnt + 1
                                endfor
                            
                               endif
                            
                               " show directory browsing history
                               if g:netrw_dirhistmax > 0
                                let cnt     = g:netrw_dirhist_cnt
                                let first   = 1
                                let histcnt = 0
                                while ( first || cnt != g:netrw_dirhist_cnt )
                                 let histcnt  = histcnt + 1
                                 let priority = g:netrw_dirhist_cnt + histcnt
                                 if exists("g:netrw_dirhist_{cnt}")
                                  let histdir= escape(g:netrw_dirhist_{cnt},g:netrw_menu_escape)
                            "     call Decho('sil! menu '.g:NetrwMenuPriority.".3.".priority." ".g:NetrwTopLvlMenu.'History.'.histdir.'	:e '.histdir)
                                  exe 'sil! menu '.g:NetrwMenuPriority.".3.".priority." ".g:NetrwTopLvlMenu.'History.'.histdir.'	:e '.histdir."\<cr>"
                                 endif
                                 let first = 0
                                 let cnt   = ( cnt - 1 ) % g:netrw_dirhistmax
                                 if cnt < 0
                                  let cnt= cnt + g:netrw_dirhistmax
                                 endif
                                endwhile
                               endif
                            
                              endif
                            "  call Dret("NetrwBookmarkMenu")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            "  s:NetrwBrowseChgDir: constructs a new directory based on the current {{{2
                            "                       directory and a new directory name.  Also, if the
                            "                       "new directory name" is actually a file,
                            "                       NetrwBrowseChgDir() edits the file.
    1              0.000005 fun! s:NetrwBrowseChgDir(islocal,newdir,...)
                            "  call Dfunc("s:NetrwBrowseChgDir(islocal=".a:islocal."> newdir<".a:newdir.">) a:0=".a:0." curpos<".string(getpos("."))."> b:netrw_curdir<".(exists("b:netrw_curdir")? b:netrw_curdir : "").">")
                            
                              let ykeep= @@
                              if !exists("b:netrw_curdir")
                               " Don't try to change-directory: this can happen, for example, when netrw#ErrorMsg has been called
                               " and the current window is the NetrwMessage window.
                               let @@= ykeep
                            "   call Decho("(NetrwBrowseChgDir) b:netrw_curdir doesn't exist!")
                            "   call Decho("(NetrwBrowseChgDir) getcwd<".getcwd().">")
                            "   call Dret("s:NetrwBrowseChgDir")
                               return
                              endif
                            
                              " NetrwBrowseChgDir: save options and initialize {{{3
                              keepj call s:NetrwOptionSave("s:")
                              keepj call s:NetrwSafeOptions()
                              let nbcd_curpos                = netrw#NetrwSavePosn()
                              let s:nbcd_curpos_{bufnr('%')} = nbcd_curpos
                            "  call Decho("(NetrwBrowseChgDir) setting s:nbcd_curpos_".bufnr('%')." to SavePosn")
                              if (has("win32") || has("win95") || has("win64") || has("win16"))
                               let dirname                   = substitute(b:netrw_curdir,'\\','/','ge')
                              else
                               let dirname= b:netrw_curdir
                              endif
                              let newdir    = a:newdir
                              let dolockout = 0
                            
                              " set up o/s-dependent directory recognition pattern
                              if has("amiga")
                               let dirpat= '[\/:]$'
                              else
                               let dirpat= '[\/]$'
                              endif
                            "  call Decho("(NetrwBrowseChgDir) dirname<".dirname.">  dirpat<".dirpat.">")
                            
                              if dirname !~ dirpat
                               " apparently vim is "recognizing" that it is in a directory and
                               " is removing the trailing "/".  Bad idea, so let's put it back.
                               let dirname= dirname.'/'
                            "   call Decho("(NetrwBrowseChgDir) adjusting dirname<".dirname.">")
                              endif
                            
                              if newdir !~ dirpat
                               " ------------------------------
                               " NetrwBrowseChgDir: edit a file {{{3
                               " ------------------------------
                            "   call Decho('(NetrwBrowseChgDir:edit-a-file) case "handling a file": newdir<'.newdir.'> !~ dirpat<'.dirpat.">")
                            
                               " save position for benefit of Rexplore
                               let s:rexposn_{bufnr("%")}= netrw#NetrwSavePosn()
                            
                            "   call Decho("(NetrwBrowseChgDir:edit-a-file) setting s:rexposn_".bufnr("%")." to SavePosn")
                               if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST && exists("w:netrw_treedict") && newdir !~ '^\(/\|\a:\)'
                                let dirname= s:NetrwTreeDir()
                                if dirname =~ '/$'
                                 let dirname= dirname.newdir
                                else
                                 let dirname= s:NetrwTreeDir()."/".newdir
                                endif
                            "    call Decho("(NetrwBrowseChgDir:edit-a-file) dirname<".dirname.">")
                            "    call Decho("(NetrwBrowseChgDir:edit-a-file) tree listing")
                               elseif newdir =~ '^\(/\|\a:\)'
                                let dirname= newdir
                               else
                                let dirname= s:ComposePath(dirname,newdir)
                               endif
                            "   call Decho("(NetrwBrowseChgDir:edit-a-file) handling a file: dirname<".dirname."> (a:0=".a:0.")")
                               " this lets NetrwBrowseX avoid the edit
                               if a:0 < 1
                            "    call Decho("(NetrwBrowseChgDir:edit-a-file) set up windows for editing<".fnameescape(dirname).">  didsplit=".(exists("s:didsplit")? s:didsplit : "doesn't exist"))
                                keepj call s:NetrwOptionRestore("s:")
                                if !exists("s:didsplit")
                            "     call Decho("(NetrwBrowseChgDir:edit-a-file) s:didsplit does not exist; g:netrw_browse_split=".g:netrw_browse_split." win#".winnr())
                                 if     g:netrw_browse_split == 1
                                  " horizontally splitting the window first
                                  keepalt new
                                  if !&ea
                                   keepalt wincmd _
                                  endif
                                 elseif g:netrw_browse_split == 2
                                  " vertically splitting the window first
                                  keepalt rightb vert new
                                  if !&ea
                                   keepalt wincmd |
                                  endif
                                 elseif g:netrw_browse_split == 3
                                  " open file in new tab
                                  keepalt tabnew
                                 elseif g:netrw_browse_split == 4
                                  " act like "P" (ie. open previous window)
                                  if s:NetrwPrevWinOpen(2) == 3
                                   let @@= ykeep
                            "       call Dret("s:NetrwBrowseChgDir")
                                   return
                                  endif
                                 else
                                  " handling a file, didn't split, so remove menu
                            "      call Decho("(NetrwBrowseChgDir:edit-a-file) handling a file+didn't split, so remove menu")
                                  call s:NetrwMenu(0)
                                  " optional change to window
                                  if g:netrw_chgwin >= 1
                                   exe "keepj keepalt ".g:netrw_chgwin."wincmd w"
                                  endif
                                 endif
                                endif
                            
                                " the point where netrw actually edits the (local) file
                                " if its local only: LocalBrowseCheck() doesn't edit a file, but NetrwBrowse() will
                                if a:islocal
                            "     call Decho("(NetrwBrowseChgDir:edit-a-file) edit local file: exe e! ".fnameescape(dirname))
                                 exe "keepj keepalt e! ".fnameescape(dirname)
                                 call s:NetrwCursor()
                                else
                            "     call Decho("(NetrwBrowseChgDir:edit-a-file) remote file: NetrwBrowse will edit it")
                                endif
                                let dolockout= 1
                            
                                " handle g:Netrw_funcref -- call external-to-netrw functions
                                "   This code will handle g:Netrw_funcref as an individual function reference
                                "   or as a list of function references.  It will ignore anything that's not
                                "   a function reference.  See  :help Funcref  for information about function references.
                                if exists("g:Netrw_funcref")
                            "     call Decho("(NetrwBrowseChgDir:edit-a-file) handle optional Funcrefs")
                                 if type(g:Netrw_funcref) == 2
                            "      call Decho("(NetrwBrowseChgDir:edit-a-file) handling a g:Netrw_funcref")
                                  keepj call g:Netrw_funcref()
                                 elseif type(g:Netrw_funcref) == 3
                            "      call Decho("(NetrwBrowseChgDir:edit-a-file) handling a list of g:Netrw_funcrefs")
                                  for Fncref in g:Netrw_funcref
                                   if type(FncRef) == 2
                                    keepj call FncRef()
                                   endif
                                  endfor
                                 endif
                                endif
                               endif
                            
                              elseif newdir =~ '^/'
                               " ----------------------------------------------------
                               " NetrwBrowseChgDir: just go to the new directory spec {{{3
                               " ----------------------------------------------------
                            "   call Decho('(NetrwBrowseChgDir:goto-newdir) case "just go to new directory spec": newdir<'.newdir.'>')
                               let dirname    = newdir
                               keepj call s:SetRexDir(a:islocal,dirname)
                               keepj call s:NetrwOptionRestore("s:")
                            
                              elseif newdir == './'
                               " ---------------------------------------------
                               " NetrwBrowseChgDir: refresh the directory list {{{3
                               " ---------------------------------------------
                            "   call Decho('(NetrwBrowseChgDir:refresh-dirlist) case "refresh directory listing": newdir == "./"')
                               keepj call s:SetRexDir(a:islocal,dirname)
                            
                              elseif newdir == '../'
                               " --------------------------------------
                               " NetrwBrowseChgDir: go up one directory {{{3
                               " --------------------------------------
                            "   call Decho('(NetrwBrowseChgDir:go-up) case "go up one directory": newdir == "../"')
                            
                               if w:netrw_liststyle == s:TREELIST && exists("w:netrw_treedict")
                                " force a refresh
                            "    call Decho("(NetrwBrowseChgDir:go-up) clear buffer<".expand("%")."> with :%d")
                            "    call Decho("(NetrwBrowseChgDir:go-up) setl noro ma")
                                setl noro ma
                                keepj %d
                               endif
                            
                               if has("amiga")
                                " amiga
                            "    call Decho('(NetrwBrowseChgDir:go-up) case "go up one directory": newdir == "../" and amiga')
                                if a:islocal
                                 let dirname= substitute(dirname,'^\(.*[/:]\)\([^/]\+$\)','\1','')
                                 let dirname= substitute(dirname,'/$','','')
                                else
                                 let dirname= substitute(dirname,'^\(.*[/:]\)\([^/]\+/$\)','\1','')
                                endif
                            "    call Decho("(NetrwBrowseChgDir:go-up) amiga: dirname<".dirname."> (go up one dir)")
                            
                               else
                                " unix or cygwin
                            "    call Decho('(NetrwBrowseChgDir:go-up) case "go up one directory": newdir == "../" and unix or cygwin')
                                if a:islocal
                                 let dirname= substitute(dirname,'^\(.*\)/\([^/]\+\)/$','\1','')
                                 if dirname == ""
                                  let dirname= '/'
                                 endif
                                else
                                 let dirname= substitute(dirname,'^\(\a\+://.\{-}/\{1,2}\)\(.\{-}\)\([^/]\+\)/$','\1\2','')
                                endif
                            "    call Decho("(NetrwBrowseChgDir:go-up) unix: dirname<".dirname."> (go up one dir)")
                               endif
                               keepj call s:SetRexDir(a:islocal,dirname)
                            
                              elseif exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST && exists("w:netrw_treedict")
                               " --------------------------------------
                               " NetrwBrowseChgDir: Handle Tree Listing {{{3
                               " --------------------------------------
                            "   call Decho('(NetrwBrowseChgDir:tree-list) case liststyle is TREELIST and w:netrw_treedict exists')
                               " force a refresh (for TREELIST, wait for NetrwTreeDir() to force the refresh)
                            "   call Decho("(NetrwBrowseChgDir) (treelist) setl noro ma")
                               setl noro ma
                               if !(exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST && exists("b:netrw_curdir"))
                            "    call Decho("(NetrwBrowseChgDir) clear buffer<".expand("%")."> with :%d")
                                keepj %d
                               endif
                               let treedir      = s:NetrwTreeDir()
                               let s:treecurpos = nbcd_curpos
                               let haskey= 0
                            "   call Decho("(NetrwBrowseChgDir:tree-list) w:netrw_treedict<".string(w:netrw_treedict).">")
                            
                               " search treedict for tree dir as-is
                               if has_key(w:netrw_treedict,treedir)
                            "    call Decho('(NetrwBrowseChgDir:tree-list) ....searched for treedir<'.treedir.'> : found it!')
                                let haskey= 1
                               else
                            "    call Decho('(NetrwBrowseChgDir:tree-list) ....searched for treedir<'.treedir.'> : not found')
                               endif
                            
                               " search treedict for treedir with a / appended
                               if !haskey && treedir !~ '/$'
                                if has_key(w:netrw_treedict,treedir."/")
                                 let treedir= treedir."/"
                            "     call Decho('(NetrwBrowseChgDir:tree-list) ....searched.for treedir<'.treedir.'> found it!')
                                 let haskey = 1
                                else
                            "     call Decho('(NetrwBrowseChgDir:tree-list) ....searched for treedir<'.treedir.'/> : not found')
                                endif
                               endif
                            
                               " search treedict for treedir with any trailing / elided
                               if !haskey && treedir =~ '/$'
                                let treedir= substitute(treedir,'/$','','')
                                if has_key(w:netrw_treedict,treedir)
                            "     call Decho('(NetrwBrowseChgDir:tree-list) ....searched.for treedir<'.treedir.'> found it!')
                                 let haskey = 1
                                else
                            "     call Decho('(NetrwBrowseChgDir:tree-list) ....searched for treedir<'.treedir.'> : not found')
                                endif
                               endif
                            
                               if haskey
                                " close tree listing for selected subdirectory
                            "    call Decho("(NetrwBrowseChgDir:tree-list) closing selected subdirectory<".dirname.">")
                                call remove(w:netrw_treedict,treedir)
                            "    call Decho("(NetrwBrowseChgDir) removed     entry<".treedir."> from treedict")
                            "    call Decho("(NetrwBrowseChgDir) yielding treedict<".string(w:netrw_treedict).">")
                                let dirname= w:netrw_treetop
                               else
                                " go down one directory
                                let dirname= substitute(treedir,'/*$','/','')
                            "    call Decho("(NetrwBrowseChgDir:tree-list) go down one dir: treedir<".treedir.">")
                               endif
                               keepj call s:SetRexDir(a:islocal,dirname)
                               let s:treeforceredraw = 1
                            
                              else
                               " ----------------------------------------
                               " NetrwBrowseChgDir: Go down one directory {{{3
                               " ----------------------------------------
                               let dirname    = s:ComposePath(dirname,newdir)
                            "   call Decho("(NetrwBrowseChgDir:go-down) go down one dir: dirname<".dirname."> newdir<".newdir.">")
                               keepj call s:SetRexDir(a:islocal,dirname)
                              endif
                            
                             " --------------------------------------
                             " NetrwBrowseChgDir: Restore and Cleanup {{{3
                             " --------------------------------------
                              keepj call s:NetrwOptionRestore("s:")
                              if dolockout
                            "   call Decho("(NetrwBrowseChgDir:restore) filewritable(dirname<".dirname.">)=".filewritable(dirname))
                               if filewritable(dirname)
                            "    call Decho("(NetrwBrowseChgDir:restore) doing modification lockout settings: ma nomod noro")
                            "    call Decho("(NetrwBrowseChgDir:restore) setl ma nomod noro")
                                setl ma nomod noro
                            "    call Decho("(NetrwBrowseChgDir:restore) ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
                               else
                            "    call Decho("(NetrwBrowseChgDir:restore) doing modification lockout settings: ma nomod ro")
                            "    call Decho("(NetrwBrowseChgDir:restore) setl ma nomod noro")
                                setl ma nomod ro
                            "    call Decho("(NetrwBrowseChgDir:restore) ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
                               endif
                              endif
                              let @@= ykeep
                            
                            "  call Dret("s:NetrwBrowseChgDir <".dirname."> : curpos<".string(getpos(".")).">")
                              return dirname
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwBrowseX:  (implements "x") executes a special "viewer" script or program for the {{{2
                            "              given filename; typically this means given their extension.
                            "              0=local, 1=remote
    1              0.000007 fun! netrw#NetrwBrowseX(fname,remote)
                            "  call Dfunc("NetrwBrowseX(fname<".a:fname."> remote=".a:remote.")")
                            
                              let ykeep      = @@
                              let screenposn = netrw#NetrwSavePosn()
                            
                              " special core dump handler
                              if a:fname =~ '/core\(\.\d\+\)\=$'
                               if exists("g:Netrw_corehandler")
                                if type(g:Netrw_corehandler) == 2
                                 " g:Netrw_corehandler is a function reference (see :help Funcref)
                            "     call Decho("g:Netrw_corehandler is a funcref")
                                 call g:Netrw_corehandler(a:fname)
                                elseif type(g:Netrw_corehandler) == 3
                                 " g:Netrw_corehandler is a List of function references (see :help Funcref)
                            "     call Decho("g:Netrw_corehandler is a List")
                                 for Fncref in g:Netrw_corehandler
                                  if type(FncRef) == 2
                                   call FncRef(a:fname)
                                  endif
                                 endfor
                                endif
                                call netrw#NetrwRestorePosn(screenposn)
                                let @@= ykeep
                            "    call Dret("NetrwBrowseX : coredump handler invoked")
                                return
                               endif
                              endif
                            
                              " set up the filename
                              " (lower case the extension, make a local copy of a remote file)
                              let exten= substitute(a:fname,'.*\.\(.\{-}\)','\1','e')
                              if has("win32") || has("win95") || has("win64") || has("win16")
                               let exten= substitute(exten,'^.*$','\L&\E','')
                              endif
                            "  call Decho("exten<".exten.">")
                            
                              " seems kde systems often have gnome-open due to dependencies, even though
                              " gnome-open's subsidiary display tools are largely absent.  Kde systems
                              " usually have "kdeinit" running, though...  (tnx Mikolaj Machowski)
                              if !exists("s:haskdeinit")
                               if has("unix") && executable("ps") && !has("win32unix")
                                let s:haskdeinit= system("ps -e") =~ 'kdeinit' 
                                if v:shell_error
                                 let s:haskdeinit = 0
                                endif
                               else
                                let s:haskdeinit= 0
                               endif
                            "   call Decho("setting s:haskdeinit=".s:haskdeinit)
                              endif
                            
                              if a:remote == 1
                               " create a local copy
                            "   call Decho("(remote) a:remote=".a:remote.": create a local copy of <".a:fname.">")
                               setl bh=delete
                               call netrw#NetRead(3,a:fname)
                               " attempt to rename tempfile
                               let basename= substitute(a:fname,'^\(.*\)/\(.*\)\.\([^.]*\)$','\2','')
                               let newname = substitute(s:netrw_tmpfile,'^\(.*\)/\(.*\)\.\([^.]*\)$','\1/'.basename.'.\3','')
                            "   call Decho("basename<".basename.">")
                            "   call Decho("newname <".newname.">")
                               if rename(s:netrw_tmpfile,newname) == 0
                                " renaming succeeded
                                let fname= newname
                               else
                                " renaming failed
                                let fname= s:netrw_tmpfile
                               endif
                              else
                            "   call Decho("(local) a:remote=".a:remote.": handling local copy of <".a:fname.">")
                               let fname= a:fname
                               " special ~ handler for local
                               if fname =~ '^\~' && expand("$HOME") != ""
                            "    call Decho('invoking special ~ handler')
                                let fname= substitute(fname,'^\~',expand("$HOME"),'')
                               endif
                              endif
                            "  call Decho("fname<".fname.">")
                            "  call Decho("exten<".exten."> "."netrwFileHandlers#NFH_".exten."():exists=".exists("*netrwFileHandlers#NFH_".exten))
                            
                              " set up redirection
                              if &srr =~ "%s"
                               if (has("win32") || has("win95") || has("win64") || has("win16"))
                                let redir= substitute(&srr,"%s","nul","")
                               else
                                let redir= substitute(&srr,"%s","/dev/null","")
                               endif
                              elseif (has("win32") || has("win95") || has("win64") || has("win16"))
                               let redir= &srr . "nul"
                              else
                               let redir= &srr . "/dev/null"
                              endif
                            "  call Decho("set up redirection: redir{".redir."} srr{".&srr."}")
                            
                              " extract any viewing options.  Assumes that they're set apart by quotes.
                            "  call Decho("extract any viewing options")
                              if exists("g:netrw_browsex_viewer")
                            "   call Decho("g:netrw_browsex_viewer<".g:netrw_browsex_viewer.">")
                               if g:netrw_browsex_viewer =~ '\s'
                                let viewer  = substitute(g:netrw_browsex_viewer,'\s.*$','','')
                                let viewopt = substitute(g:netrw_browsex_viewer,'^\S\+\s*','','')." "
                                let oviewer = ''
                                let cnt     = 1
                                while !executable(viewer) && viewer != oviewer
                                 let viewer  = substitute(g:netrw_browsex_viewer,'^\(\(^\S\+\s\+\)\{'.cnt.'}\S\+\)\(.*\)$','\1','')
                                 let viewopt = substitute(g:netrw_browsex_viewer,'^\(\(^\S\+\s\+\)\{'.cnt.'}\S\+\)\(.*\)$','\3','')." "
                                 let cnt     = cnt + 1
                                 let oviewer = viewer
                            "     call Decho("!exe: viewer<".viewer.">  viewopt<".viewopt.">")
                                endwhile
                               else
                                let viewer  = g:netrw_browsex_viewer
                                let viewopt = ""
                               endif
                            "   call Decho("viewer<".viewer.">  viewopt<".viewopt.">")
                              endif
                            
                              " execute the file handler
                            "  call Decho("execute the file handler (if any)")
                              if exists("g:netrw_browsex_viewer") && g:netrw_browsex_viewer == '-'
                            "   call Decho("g:netrw_browsex_viewer<".g:netrw_browsex_viewer.">")
                               let ret= netrwFileHandlers#Invoke(exten,fname)
                            
                              elseif exists("g:netrw_browsex_viewer") && executable(viewer)
                            "   call Decho("g:netrw_browsex_viewer<".g:netrw_browsex_viewer.">")
                            "   call Decho("exe sil !".viewer." ".viewopt.shellescape(fname,1).redir)
                               exe "sil !".viewer." ".viewopt.shellescape(fname,1).redir
                               let ret= v:shell_error
                            
                              elseif has("win32") || has("win64")
                            "   call Decho("windows")
                               if executable("start")
                            "    call Decho('exe sil !start rundll32 url.dll,FileProtocolHandler '.shellescape(fname,1))
                                exe 'sil !start rundll32 url.dll,FileProtocolHandler '.shellescape(fname,1)
                               elseif executable("rundll32")
                            "    call Decho('exe sil !rundll32 url.dll,FileProtocolHandler '.shellescape(fname,1))
                                exe 'sil !rundll32 url.dll,FileProtocolHandler '.shellescape(fname,1)
                               else
                                call netrw#ErrorMsg(s:WARNING,"rundll32 not on path",74)
                               endif
                               call inputsave()|call input("Press <cr> to continue")|call inputrestore()
                               let ret= v:shell_error
                            
                              elseif has("win32unix")
                               let winfname= 'c:\cygwin'.substitute(fname,'/','\\','g')
                            "   call Decho("cygwin: winfname<".shellescape(winfname,1).">")
                               if executable("start")
                            "    call Decho('exe sil !start rundll32 url.dll,FileProtocolHandler '.shellescape(winfname,1))
                                exe 'sil !start rundll32 url.dll,FileProtocolHandler '.shellescape(winfname,1)
                               elseif executable("rundll32")
                            "    call Decho('exe sil !rundll32 url.dll,FileProtocolHandler '.shellescape(winfname,1))
                                exe 'sil !rundll32 url.dll,FileProtocolHandler '.shellescape(winfname,1)
                               else
                                call netrw#ErrorMsg(s:WARNING,"rundll32 not on path",74)
                               endif
                               call inputsave()|call input("Press <cr> to continue")|call inputrestore()
                               let ret= v:shell_error
                            
                              elseif has("unix") && executable("xdg-open") && !s:haskdeinit
                            "   call Decho("unix and xdg-open")
                            "   call Decho("exe sil !xdg-open ".shellescape(fname,1)." ".redir)
                               exe "sil !xdg-open ".shellescape(fname,1).redir
                               let ret= v:shell_error
                            
                              elseif has("unix") && executable("kfmclient") && s:haskdeinit
                            "   call Decho("unix and kfmclient")
                            "   call Decho("exe sil !kfmclient exec ".shellescape(fname,1)." ".redir)
                               exe "sil !kfmclient exec ".shellescape(fname,1)." ".redir
                               let ret= v:shell_error
                            
                              elseif has("macunix") && executable("open")
                            "   call Decho("macunix and open")
                            "   call Decho("exe sil !open ".shellescape(fname,1)." ".redir)
                               exe "sil !open ".shellescape(fname,1)." ".redir
                               let ret= v:shell_error
                            
                              else
                               " netrwFileHandlers#Invoke() always returns 0
                               let ret= netrwFileHandlers#Invoke(exten,fname)
                              endif
                            
                              " if unsuccessful, attempt netrwFileHandlers#Invoke()
                              if ret
                               let ret= netrwFileHandlers#Invoke(exten,fname)
                              endif
                            
                              " restoring redraw! after external file handlers
                              redraw!
                            
                              " cleanup: remove temporary file,
                              "          delete current buffer if success with handler,
                              "          return to prior buffer (directory listing)
                              "          Feb 12, 2008: had to de-activiate removal of
                              "          temporary file because it wasn't getting seen.
                            "  if a:remote == 1 && fname != a:fname
                            ""   call Decho("deleting temporary file<".fname.">")
                            "   call s:NetrwDelete(fname)
                            "  endif
                            
                              if a:remote == 1
                               setl bh=delete bt=nofile
                               if g:netrw_use_noswf
                                setl noswf
                               endif
                               exe "sil! keepj norm! \<c-o>"
                            "   redraw!
                              endif
                              call netrw#NetrwRestorePosn(screenposn)
                              let @@= ykeep
                            
                            "  call Dret("NetrwBrowseX")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwChgPerm: (implements "gp") change file permission {{{2
    1              0.000005 fun! s:NetrwChgPerm(islocal,curdir)
                            "  call Dfunc("s:NetrwChgPerm(islocal=".a:islocal." curdir<".a:curdir.">)")
                              let ykeep  = @@
                              call inputsave()
                              let newperm= input("Enter new permission: ")
                              call inputrestore()
                              let chgperm= substitute(g:netrw_chgperm,'\<FILENAME\>',shellescape(expand("<cfile>")),'')
                              let chgperm= substitute(chgperm,'\<PERM\>',shellescape(newperm),'')
                            "  call Decho("chgperm<".chgperm.">")
                              call system(chgperm)
                              if v:shell_error != 0
                               keepj call netrw#ErrorMsg(1,"changing permission on file<".expand("<cfile>")."> seems to have failed",75)
                              endif
                              if a:islocal
                               keepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
                              endif
                              let @@= ykeep
                            "  call Dret("s:NetrwChgPerm")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwClearExplore: clear explore variables (if any) {{{2
    1              0.000003 fun! s:NetrwClearExplore()
                            "  call Dfunc("s:NetrwClearExplore()")
                              2match none
                              if exists("s:explore_match")        |unlet s:explore_match        |endif
                              if exists("s:explore_indx")         |unlet s:explore_indx         |endif
                              if exists("s:netrw_explore_prvdir") |unlet s:netrw_explore_prvdir |endif
                              if exists("s:dirstarstar")          |unlet s:dirstarstar          |endif
                              if exists("s:explore_prvdir")       |unlet s:explore_prvdir       |endif
                              if exists("w:netrw_explore_indx")   |unlet w:netrw_explore_indx   |endif
                              if exists("w:netrw_explore_listlen")|unlet w:netrw_explore_listlen|endif
                              if exists("w:netrw_explore_list")   |unlet w:netrw_explore_list   |endif
                              if exists("w:netrw_explore_bufnr")  |unlet w:netrw_explore_bufnr  |endif
                            "   redraw!
                              echo " "
                              echo " "
                            "  call Dret("s:NetrwClearExplore")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwExploreListUniq: {{{2
    1              0.000003 fun! s:NetrwExploreListUniq(explist)
                            "  call Dfunc("s:NetrwExploreListUniq(explist<".string(a:explist).">)")
                            
                              " this assumes that the list is already sorted
                              let newexplist= []
                              for member in a:explist
                               if !exists("uniqmember") || member != uniqmember
                                let uniqmember = member
                                let newexplist = newexplist + [ member ]
                               endif
                              endfor
                            
                            "  call Dret("s:NetrwExploreListUniq newexplist<".string(newexplist).">")
                              return newexplist
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwForceChgDir: (gd support) Force treatment as a directory {{{2
    1              0.000004 fun! s:NetrwForceChgDir(islocal,newdir)
                            "  call Dfunc("s:NetrwForceChgDir(islocal=".a:islocal." newdir<".a:newdir.">)")
                              let ykeep= @@
                              if a:newdir !~ '/$'
                               " ok, looks like force is needed to get directory-style treatment
                               if a:newdir =~ '@$'
                                let newdir= substitute(a:newdir,'@$','/','')
                               elseif a:newdir =~ '[*=|\\]$'
                                let newdir= substitute(a:newdir,'.$','/','')
                               else
                                let newdir= a:newdir.'/'
                               endif
                            "   call Decho("adjusting newdir<".newdir."> due to gd")
                              else
                               " should already be getting treatment as a directory
                               let newdir= a:newdir
                              endif
                              let newdir= s:NetrwBrowseChgDir(a:islocal,newdir)
                              call s:NetrwBrowse(a:islocal,newdir)
                              let @@= ykeep
                            "  call Dret("s:NetrwForceChgDir")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwForceFile: (gf support) Force treatment as a file {{{2
    1              0.000003 fun! s:NetrwForceFile(islocal,newfile)
                            "  call Dfunc("s:NetrwForceFile(islocal=".a:islocal." newdir<".a:newfile.">)")
                              if a:newfile =~ '[/@*=|\\]$'
                               let newfile= substitute(a:newfile,'.$','','')
                              else
                               let newfile= a:newfile
                              endif
                              if a:islocal
                               call s:NetrwBrowseChgDir(a:islocal,newfile)
                              else
                               call s:NetrwBrowse(a:islocal,s:NetrwBrowseChgDir(a:islocal,newfile))
                              endif
                            "  call Dret("s:NetrwForceFile")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwHide: this function is invoked by the "a" map for browsing {{{2
                            "          and switches the hiding mode.  The actual hiding is done by
                            "          s:NetrwListHide().
                            "             g:netrw_hide= 0: show all
                            "                           1: show not-hidden files
                            "                           2: show hidden files only
    1              0.000007 fun! s:NetrwHide(islocal)
                            "  call Dfunc("NetrwHide(islocal=".a:islocal.") g:netrw_hide=".g:netrw_hide)
                              let ykeep= @@
                              let svpos= netrw#NetrwSavePosn()
                            
                              if exists("s:netrwmarkfilelist_{bufnr('%')}")
                            "   call Decho(((g:netrw_hide == 1)? "unhide" : "hide")." files in markfilelist<".string(s:netrwmarkfilelist_{bufnr("%")}).">")
                            "   call Decho("g:netrw_list_hide<".g:netrw_list_hide.">")
                            
                               " hide the files in the markfile list
                               for fname in s:netrwmarkfilelist_{bufnr("%")}
                            "    call Decho("match(g:netrw_list_hide<".g:netrw_list_hide.'> fname<\<'.fname.'\>>)='.match(g:netrw_list_hide,'\<'.fname.'\>')." l:isk=".&l:isk)
                                if match(g:netrw_list_hide,'\<'.fname.'\>') != -1
                                 " remove fname from hiding list
                                 let g:netrw_list_hide= substitute(g:netrw_list_hide,'..\<'.escape(fname,g:netrw_fname_escape).'\>..','','')
                                 let g:netrw_list_hide= substitute(g:netrw_list_hide,',,',',','g')
                                 let g:netrw_list_hide= substitute(g:netrw_list_hide,'^,\|,$','','')
                            "     call Decho("unhide: g:netrw_list_hide<".g:netrw_list_hide.">")
                                else
                                 " append fname to hiding list
                                 if exists("g:netrw_list_hide") && g:netrw_list_hide != ""
                                  let g:netrw_list_hide= g:netrw_list_hide.',\<'.escape(fname,g:netrw_fname_escape).'\>'
                                 else
                                  let g:netrw_list_hide= '\<'.escape(fname,g:netrw_fname_escape).'\>'
                                 endif
                            "     call Decho("hide: g:netrw_list_hide<".g:netrw_list_hide.">")
                                endif
                               endfor
                               keepj call s:NetrwUnmarkList(bufnr("%"),b:netrw_curdir)
                               let g:netrw_hide= 1
                            
                              else
                            
                               " switch between show-all/show-not-hidden/show-hidden
                               let g:netrw_hide=(g:netrw_hide+1)%3
                               exe "keepj norm! 0"
                               if g:netrw_hide && g:netrw_list_hide == ""
                                keepj call netrw#ErrorMsg(s:WARNING,"your hiding list is empty!",49)
                                let @@= ykeep
                            "    call Dret("NetrwHide")
                                return
                               endif
                              endif
                            
                              keepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
                              keepj call netrw#NetrwRestorePosn(svpos)
                              let @@= ykeep
                            "  call Dret("NetrwHide")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwHidden: invoked by "gh" {{{2
    1              0.000003 fun! s:NetrwHidden(islocal)
                            "  call Dfunc("s:NetrwHidden()")
                              let ykeep= @@
                              "  save current position
                              let svpos= netrw#NetrwSavePosn()
                            
                              if g:netrw_list_hide =~ '\(^\|,\)\\(^\\|\\s\\s\\)\\zs\\.\\S\\+'
                               " remove pattern from hiding list
                               let g:netrw_list_hide= substitute(g:netrw_list_hide,'\(^\|,\)\\(^\\|\\s\\s\\)\\zs\\.\\S\\+','','')
                              elseif s:Strlen(g:netrw_list_hide) >= 1
                               let g:netrw_list_hide= g:netrw_list_hide . ',\(^\|\s\s\)\zs\.\S\+'
                              else
                               let g:netrw_list_hide= '\(^\|\s\s\)\zs\.\S\+'
                              endif
                            
                              " refresh screen and return to saved position
                              keepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
                              keepj call netrw#NetrwRestorePosn(svpos)
                              let @@= ykeep
                            "  call Dret("s:NetrwHidden")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            "  s:NetrwHome: this function determines a "home" for saving bookmarks and history {{{2
    1              0.000003 fun! s:NetrwHome()
                              if exists("g:netrw_home")
                               let home= g:netrw_home
                              else
                               " go to vim plugin home
                               for home in split(&rtp,',') + ['']
                                if isdirectory(home) && filewritable(home) | break | endif
                                 let basehome= substitute(home,'[/\\]\.vim$','','')
                                if isdirectory(basehome) && filewritable(basehome)
                                 let home= basehome."/.vim"
                                 break
                                endif
                               endfor
                               if home == ""
                                " just pick the first directory
                                let home= substitute(&rtp,',.*$','','')
                               endif
                               if (has("win32") || has("win95") || has("win64") || has("win16"))
                                let home= substitute(home,'/','\\','g')
                               endif
                              endif
                              " insure that the home directory exists
                              if g:netrw_dirhistmax > 0 && !isdirectory(home)
                               if exists("g:netrw_mkdir")
                                call system(g:netrw_mkdir." ".shellescape(home))
                               else
                                call mkdir(home)
                               endif
                              endif
                              let g:netrw_home= home
                              return home
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwLeftmouse: handles the <leftmouse> when in a netrw browsing window {{{2
    1              0.000003 fun! s:NetrwLeftmouse(islocal)
                              if exists("s:netrwdrag")
                               return
                              endif
                            "  call Dfunc("s:NetrwLeftmouse(islocal=".a:islocal.")")
                            
                              let ykeep= @@
                              " check if the status bar was clicked on instead of a file/directory name
                              while getchar(0) != 0
                               "clear the input stream
                              endwhile
                              call feedkeys("\<LeftMouse>")
                              let c          = getchar()
                              let mouse_lnum = v:mouse_lnum
                              let wlastline  = line('w$')
                              let lastline   = line('$')
                            "  call Decho("v:mouse_lnum=".mouse_lnum." line(w$)=".wlastline." line($)=".lastline." v:mouse_win=".v:mouse_win." winnr#".winnr())
                            "  call Decho("v:mouse_col =".v:mouse_col."     col=".col(".")."  wincol =".wincol()." winwidth   =".winwidth(0))
                              if mouse_lnum >= wlastline + 1 || v:mouse_win != winnr()
                               " appears to be a status bar leftmouse click
                               let @@= ykeep
                            "   call Dret("s:NetrwLeftmouse : detected a status bar leftmouse click")
                               return
                              endif
                              if v:mouse_col != col('.')
                               let @@= ykeep
                            "   call Dret("s:NetrwLeftmouse : detected a vertical separator bar leftmouse click")
                               return
                              endif
                            
                              if a:islocal
                               if exists("b:netrw_curdir")
                                keepj call netrw#LocalBrowseCheck(s:NetrwBrowseChgDir(1,s:NetrwGetWord()))
                               endif
                              else
                               if exists("b:netrw_curdir")
                                keepj call s:NetrwBrowse(0,s:NetrwBrowseChgDir(0,s:NetrwGetWord()))
                               endif
                              endif
                              let @@= ykeep
                            "  call Dret("s:NetrwLeftmouse")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwRightdrag: {{{2
                            "DechoTabOn
    1              0.000003 fun! s:NetrwRightdrag(islocal)
                            "  call Dfunc("s:NetrwRightdrag(islocal=".a:islocal.")")
                              if !exists("s:netrwdrag")
                               let s:netrwdrag     = winnr()
                               call s:NetrwMarkFile(a:islocal,s:NetrwGetWord())
                               if a:islocal
                                nno <silent> <s-rightrelease> <leftmouse>:<c-u>call <SID>NetrwRightrelease(1)<cr>
                               else
                                nno <silent> <s-rightrelease> <leftmouse>:<c-u>call <SID>NetrwRightrelease(0)<cr>
                               endif
                              endif
                            "  call Dret("s:NetrwRightdrag : s:netrwdrag=".s:netrwdrag." buf#".bufnr("%"))
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwRightrelease: {{{2
    1              0.000003 fun! s:NetrwRightrelease(islocal)
                            "  call Dfunc("s:NetrwRightrelease(islocal=".a:islocal.") s:netrwdrag=".s:netrwdrag." buf#".bufnr("%"))
                              if exists("s:netrwdrag")
                               nunmap <s-rightrelease>
                               let tgt = s:NetrwGetWord()
                            "   call Decho("target#1: ".tgt)
                               if tgt =~ '/$' && tgt !~ '^\./$'
                                let tgt = b:netrw_curdir."/".tgt
                               else
                                let tgt= b:netrw_curdir
                               endif
                            "   call Decho("target#2: ".tgt)
                               call netrw#NetrwMakeTgt(tgt)
                               let curwin= winnr()
                               exe s:netrwdrag."wincmd w"
                               call s:NetrwMarkFileMove(a:islocal)
                               exe curwin."wincmd w"
                               unlet s:netrwdrag
                              endif
                            "  call Dret("s:NetrwRightrelease")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwListHide: uses [range]g~...~d to delete files that match comma {{{2
                            " separated patterns given in g:netrw_list_hide
    1              0.000003 fun! s:NetrwListHide()
                            "  call Dfunc("NetrwListHide() g:netrw_hide=".g:netrw_hide." g:netrw_list_hide<".g:netrw_list_hide.">")
                              let ykeep= @@
                            
                              " find a character not in the "hide" string to use as a separator for :g and :v commands
                              " How-it-works: take the hiding command, convert it into a range.  Duplicate
                              " characters don't matter.  Remove all such characters from the '/~...90'
                              " string.  Use the first character left as a separator character.
                              let listhide= g:netrw_list_hide
                              let sep     = strpart(substitute('/~@#$%^&*{};:,<.>?|1234567890','['.escape(listhide,'-]^\').']','','ge'),1,1)
                            "  call Decho("sep=".sep)
                            
                              while listhide != ""
                               if listhide =~ ','
                                let hide     = substitute(listhide,',.*$','','e')
                                let listhide = substitute(listhide,'^.\{-},\(.*\)$','\1','e')
                               else
                                let hide     = listhide
                                let listhide = ""
                               endif
                            
                               " Prune the list by hiding any files which match
                               if g:netrw_hide == 1
                            "    call Decho("hiding<".hide."> listhide<".listhide.">")
                                exe 'sil! keepj '.w:netrw_bannercnt.',$g'.sep.hide.sep.'d'
                               elseif g:netrw_hide == 2
                            "    call Decho("showing<".hide."> listhide<".listhide.">")
                                exe 'sil! keepj '.w:netrw_bannercnt.',$g'.sep.hide.sep.'s@^@ /-KEEP-/ @'
                               endif
                              endwhile
                              if g:netrw_hide == 2
                               exe 'sil! keepj '.w:netrw_bannercnt.',$v@^ /-KEEP-/ @d'
                               exe 'sil! keepj '.w:netrw_bannercnt.',$s@^\%( /-KEEP-/ \)\+@@e'
                              endif
                            
                              " remove any blank lines that have somehow remained.
                              " This seems to happen under Windows.
                              exe 'sil! keepj 1,$g@^\s*$@d'
                            
                              let @@= ykeep
                            "  call Dret("NetrwListHide")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " NetrwHideEdit: allows user to edit the file/directory hiding list
    1              0.000004 fun! s:NetrwHideEdit(islocal)
                            "  call Dfunc("NetrwHideEdit(islocal=".a:islocal.")")
                            
                              let ykeep= @@
                              " save current cursor position
                              let svpos= netrw#NetrwSavePosn()
                            
                              " get new hiding list from user
                              call inputsave()
                              let newhide= input("Edit Hiding List: ",g:netrw_list_hide)
                              call inputrestore()
                              let g:netrw_list_hide= newhide
                            "  call Decho("new g:netrw_list_hide<".g:netrw_list_hide.">")
                            
                              " refresh the listing
                              sil keepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,"./"))
                            
                              " restore cursor position
                              call netrw#NetrwRestorePosn(svpos)
                              let @@= ykeep
                            
                            "  call Dret("NetrwHideEdit")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " NetSortSequence: allows user to edit the sorting sequence
    1              0.000002 fun! s:NetSortSequence(islocal)
                            "  call Dfunc("NetSortSequence(islocal=".a:islocal.")")
                            
                              let ykeep= @@
                              let svpos= netrw#NetrwSavePosn()
                              call inputsave()
                              let newsortseq= input("Edit Sorting Sequence: ",g:netrw_sort_sequence)
                              call inputrestore()
                            
                              " refresh the listing
                              let g:netrw_sort_sequence= newsortseq
                              keepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
                              keepj call netrw#NetrwRestorePosn(svpos)
                              let @@= ykeep
                            
                            "  call Dret("NetSortSequence")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwMakeDir: this function makes a directory (both local and remote) {{{2
    1              0.000002 fun! s:NetrwMakeDir(usrhost)
                            "  call Dfunc("NetrwMakeDir(usrhost<".a:usrhost.">)")
                            
                              let ykeep= @@
                              " get name of new directory from user.  A bare <CR> will skip.
                              " if its currently a directory, also request will be skipped, but with
                              " a message.
                              call inputsave()
                              let newdirname= input("Please give directory name: ")
                              call inputrestore()
                            "  call Decho("newdirname<".newdirname.">")
                            
                              if newdirname == ""
                               let @@= ykeep
                            "   call Dret("NetrwMakeDir : user aborted with bare <cr>")
                               return
                              endif
                            
                              if a:usrhost == ""
                            "   call Decho("local mkdir")
                            
                               " Local mkdir:
                               " sanity checks
                               let fullnewdir= b:netrw_curdir.'/'.newdirname
                            "   call Decho("fullnewdir<".fullnewdir.">")
                               if isdirectory(fullnewdir)
                                if !exists("g:netrw_quiet")
                                 keepj call netrw#ErrorMsg(s:WARNING,"<".newdirname."> is already a directory!",24)
                                endif
                                let @@= ykeep
                            "    call Dret("NetrwMakeDir : directory<".newdirname."> exists previously")
                                return
                               endif
                               if s:FileReadable(fullnewdir)
                                if !exists("g:netrw_quiet")
                                 keepj call netrw#ErrorMsg(s:WARNING,"<".newdirname."> is already a file!",25)
                                endif
                                let @@= ykeep
                            "    call Dret("NetrwMakeDir : file<".newdirname."> exists previously")
                                return
                               endif
                            
                               " requested new local directory is neither a pre-existing file or
                               " directory, so make it!
                               if exists("*mkdir")
                                call mkdir(fullnewdir,"p")
                               else
                                let netrw_origdir= s:NetrwGetcwd(1)
                                exe 'keepj lcd '.fnameescape(b:netrw_curdir)
                            "    call Decho("netrw_origdir<".netrw_origdir.">: lcd b:netrw_curdir<".fnameescape(b:netrw_curdir).">")
                            "    call Decho("exe sil! !".g:netrw_localmkdir.' '.shellescape(newdirname,1))
                                exe "sil! !".g:netrw_localmkdir.' '.shellescape(newdirname,1)
                                if v:shell_error != 0
                                 let @@= ykeep
                                 call netrw#ErrorMsg(s:ERROR,"consider setting g:netrw_localmkdir<".g:netrw_localmkdir."> to something that works",80)
                            "     call Dret("NetrwMakeDir : failed: sil! !".g:netrw_localmkdir.' '.shellescape(newdirname,1))
                                 return
                                endif
                                if !g:netrw_keepdir
                                 exe 'keepj lcd '.fnameescape(netrw_origdir)
                            "     call Decho("netrw_keepdir=".g:netrw_keepdir.": keepjumps lcd ".fnameescape(netrw_origdir)." getcwd<".getcwd().">")
                                endif
                               endif
                            
                               if v:shell_error == 0
                                " refresh listing
                            "    call Decho("refresh listing")
                                let svpos= netrw#NetrwSavePosn()
                                call s:NetrwRefresh(1,s:NetrwBrowseChgDir(1,'./'))
                                call netrw#NetrwRestorePosn(svpos)
                               elseif !exists("g:netrw_quiet")
                                call netrw#ErrorMsg(s:ERROR,"unable to make directory<".newdirname.">",26)
                               endif
                            "   redraw!
                            
                              elseif !exists("b:netrw_method") || b:netrw_method == 4
                               " Remote mkdir:
                            "   call Decho("remote mkdir")
                               let mkdircmd  = s:MakeSshCmd(g:netrw_mkdir_cmd)
                               let newdirname= substitute(b:netrw_curdir,'^\%(.\{-}/\)\{3}\(.*\)$','\1','').newdirname
                            "   call Decho("exe sil! !".mkdircmd." ".shellescape(newdirname,1))
                               exe "sil! !".mkdircmd." ".shellescape(newdirname,1)
                               if v:shell_error == 0
                                " refresh listing
                                let svpos= netrw#NetrwSavePosn()
                                keepj call s:NetrwRefresh(0,s:NetrwBrowseChgDir(0,'./'))
                                keepj call netrw#NetrwRestorePosn(svpos)
                               elseif !exists("g:netrw_quiet")
                                keepj call netrw#ErrorMsg(s:ERROR,"unable to make directory<".newdirname.">",27)
                               endif
                            "   redraw!
                            
                              elseif b:netrw_method == 2
                               let svpos= netrw#NetrwSavePosn()
                               call s:NetrwRemoteFtpCmd("",g:netrw_remote_mkdir.' "'.newdirname.'"')
                               keepj call s:NetrwRefresh(0,s:NetrwBrowseChgDir(0,'./'))
                               keepj call netrw#NetrwRestorePosn(svpos)
                              elseif b:netrw_method == 3
                               let svpos= netrw#NetrwSavePosn()
                               call s:NetrwRemoteFtpCmd("",g:netrw_remote_mkdir.' "'.newdirname.'"')
                               keepj call s:NetrwRefresh(0,s:NetrwBrowseChgDir(0,'./'))
                               keepj call netrw#NetrwRestorePosn(svpos)
                              endif
                            
                              let @@= ykeep
                            "  call Dret("NetrwMakeDir")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwMarkFile: (invoked by mf) This function is used to both {{{2
                            "                  mark and unmark files.  If a markfile list exists,
                            "                  then the rename and delete functions will use it instead
                            "                  of whatever may happen to be under the cursor at that
                            "                  moment.  When the mouse and gui are available,
                            "                  shift-leftmouse may also be used to mark files.
                            "
                            "  Creates two lists
                            "    s:netrwmarkfilelist    -- holds complete paths to all marked files
                            "    s:netrwmarkfilelist_#  -- holds list of marked files in current-buffer's directory (#==bufnr())
                            "
                            "  Creates a marked file match string
                            "    s:netrwmarfilemtch_#   -- used with 2match to display marked files
                            "
                            "  Creates a buffer version of islocal
                            "    b:netrw_islocal
    1              0.000003 fun! s:NetrwMarkFile(islocal,fname)
                            "  call Dfunc("s:NetrwMarkFile(islocal=".a:islocal." fname<".a:fname.">)")
                            
                              " sanity check
                              if empty(a:fname)
                            "   call Dret("s:NetrwMarkFile : emtpy fname")
                               return
                              endif
                            
                              let ykeep   = @@
                              let curbufnr= bufnr("%")
                              let curdir  = b:netrw_curdir
                              let trailer = '[@=|\/\*]\=\ze\%(  \|\t\|$\)'
                            
                              if exists("s:netrwmarkfilelist_{curbufnr}")
                               " markfile list pre-exists
                            "   call Decho("starting s:netrwmarkfilelist_{curbufnr}<".string(s:netrwmarkfilelist_{curbufnr}).">")
                            "   call Decho("starting s:netrwmarkfilemtch_{curbufnr}<".s:netrwmarkfilemtch_{curbufnr}.">")
                               let b:netrw_islocal= a:islocal
                            
                               if index(s:netrwmarkfilelist_{curbufnr},a:fname) == -1
                                " append filename to buffer's markfilelist
                            "    call Decho("append filename<".a:fname."> to local markfilelist_".curbufnr."<".string(s:netrwmarkfilelist_{curbufnr}).">")
                                call add(s:netrwmarkfilelist_{curbufnr},a:fname)
                                let s:netrwmarkfilemtch_{curbufnr}= s:netrwmarkfilemtch_{curbufnr}.'\|\<'.escape(a:fname,g:netrw_markfileesc."'".g:netrw_markfileesc."'").trailer
                            
                               else
                                " remove filename from buffer's markfilelist
                            "    call Decho("remove filename<".a:fname."> from local markfilelist_".curbufnr."<".string(s:netrwmarkfilelist_{curbufnr}).">")
                                call filter(s:netrwmarkfilelist_{curbufnr},'v:val != a:fname')
                                if s:netrwmarkfilelist_{curbufnr} == []
                                 " local markfilelist is empty; remove it entirely
                            "     call Decho("markfile list now empty")
                                 call s:NetrwUnmarkList(curbufnr,curdir)
                                else
                                 " rebuild match list to display markings correctly
                            "     call Decho("rebuild s:netrwmarkfilemtch_".curbufnr)
                                 let s:netrwmarkfilemtch_{curbufnr}= ""
                                 let first                           = 1
                                 for fname in s:netrwmarkfilelist_{curbufnr}
                                  if first
                                   let s:netrwmarkfilemtch_{curbufnr}= s:netrwmarkfilemtch_{curbufnr}.'\<'.escape(fname,g:netrw_markfileesc."'".g:netrw_markfileesc."'").trailer
                                  else
                                   let s:netrwmarkfilemtch_{curbufnr}= s:netrwmarkfilemtch_{curbufnr}.'\|\<'.escape(fname,g:netrw_markfileesc."'".g:netrw_markfileesc."'").trailer
                                  endif
                                  let first= 0
                                 endfor
                            "     call Decho("ending s:netrwmarkfilelist_".curbufnr."<".string(s:netrwmarkfilelist_{curbufnr}).">")
                                endif
                               endif
                            
                              else
                               " initialize new markfilelist
                            
                            "   call Decho("add fname<".a:fname."> to new markfilelist_".curbufnr)
                               let s:netrwmarkfilelist_{curbufnr}= []
                               call add(s:netrwmarkfilelist_{curbufnr},a:fname)
                            "   call Decho("ending s:netrwmarkfilelist_{curbufnr}<".string(s:netrwmarkfilelist_{curbufnr}).">")
                            
                               " build initial markfile matching pattern
                               if a:fname =~ '/$'
                                let s:netrwmarkfilemtch_{curbufnr}= '\<'.escape(a:fname,g:netrw_markfileesc)
                               else
                                let s:netrwmarkfilemtch_{curbufnr}= '\<'.escape(a:fname,g:netrw_markfileesc).trailer
                               endif
                            "   call Decho("ending s:netrwmarkfilemtch_".curbufnr."<".s:netrwmarkfilemtch_{curbufnr}.">")
                              endif
                            
                              " handle global markfilelist
                              if exists("s:netrwmarkfilelist")
                               let dname= s:ComposePath(b:netrw_curdir,a:fname)
                               if index(s:netrwmarkfilelist,dname) == -1
                                " append new filename to global markfilelist
                                call add(s:netrwmarkfilelist,s:ComposePath(b:netrw_curdir,a:fname))
                            "    call Decho("append filename<".a:fname."> to global markfilelist<".string(s:netrwmarkfilelist).">")
                               else
                                " remove new filename from global markfilelist
                            "    call Decho("filter(".string(s:netrwmarkfilelist).",'v:val != '.".dname.")")
                                call filter(s:netrwmarkfilelist,'v:val != "'.dname.'"')
                            "    call Decho("ending s:netrwmarkfilelist  <".string(s:netrwmarkfilelist).">")
                                if s:netrwmarkfilelist == []
                                 unlet s:netrwmarkfilelist
                                endif
                               endif
                              else
                               " initialize new global-directory markfilelist
                               let s:netrwmarkfilelist= []
                               call add(s:netrwmarkfilelist,s:ComposePath(b:netrw_curdir,a:fname))
                            "   call Decho("init s:netrwmarkfilelist<".string(s:netrwmarkfilelist).">")
                              endif
                            
                              " set up 2match'ing to netrwmarkfilemtch list
                              if exists("s:netrwmarkfilemtch_{curbufnr}") && s:netrwmarkfilemtch_{curbufnr} != ""
                            "   call Decho("exe 2match netrwMarkFile /".s:netrwmarkfilemtch_{curbufnr}."/")
                               if exists("g:did_drchip_netrwlist_syntax")
                                exe "2match netrwMarkFile /".s:netrwmarkfilemtch_{curbufnr}."/"
                               endif
                              else
                            "   call Decho("2match none")
                               2match none
                              endif
                              let @@= ykeep
                            "  call Dret("s:NetrwMarkFile : s:netrwmarkfilelist_".curbufnr."<".(exists("s:netrwmarkfilelist_{curbufnr}")? string(s:netrwmarkfilelist_{curbufnr}) : " doesn't exist").">")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwMarkFileCompress: (invoked by mz) This function is used to {{{2
                            "                          compress/decompress files using the programs
                            "                          in g:netrw_compress and g:netrw_uncompress,
                            "                          using g:netrw_compress_suffix to know which to
                            "                          do.  By default:
                            "                            g:netrw_compress        = "gzip"
                            "                            g:netrw_decompress      = { ".gz" : "gunzip" , ".bz2" : "bunzip2" , ".zip" : "unzip" , ".tar" : "tar -xf", ".xz" : "unxz"}
    1              0.000003 fun! s:NetrwMarkFileCompress(islocal)
                            "  call Dfunc("s:NetrwMarkFileCompress(islocal=".a:islocal.")")
                              let svpos    = netrw#NetrwSavePosn()
                              let curdir   = b:netrw_curdir
                              let curbufnr = bufnr("%")
                            
                              " sanity check
                              if !exists("s:netrwmarkfilelist_{curbufnr}") || empty(s:netrwmarkfilelist_{curbufnr})
                               keepj call netrw#ErrorMsg(2,"there are no marked files in this window (:help netrw-mf)",66)
                            "   call Dret("s:NetrwMarkFileCompress")
                               return
                              endif
                            "  call Decho("sanity chk passed: s:netrwmarkfilelist_".curbufnr."<".string(s:netrwmarkfilelist_{curbufnr}))
                            
                              if exists("s:netrwmarkfilelist_{curbufnr}") && exists("g:netrw_compress") && exists("g:netrw_decompress")
                            
                               " for every filename in the marked list
                               for fname in s:netrwmarkfilelist_{curbufnr}
                                let sfx= substitute(fname,'^.\{-}\(\.\a\+\)$','\1','')
                            "    call Decho("extracted sfx<".sfx.">")
                                if exists("g:netrw_decompress['".sfx."']")
                                 " fname has a suffix indicating that its compressed; apply associated decompression routine
                                 let exe= g:netrw_decompress[sfx]
                            "     call Decho("fname<".fname."> is compressed so decompress with <".exe.">")
                                 let exe= netrw#WinPath(exe)
                                 if a:islocal
                                  if g:netrw_keepdir
                                   let fname= shellescape(s:ComposePath(curdir,fname))
                                  endif
                                 else
                                  let fname= shellescape(b:netrw_curdir.fname,1)
                                 endif
                                 if executable(exe)
                                  if a:islocal
                                   call system(exe." ".fname)
                                  else
                                   keepj call s:RemoteSystem(exe." ".fname)
                                  endif
                                 else
                                  keepj call netrw#ErrorMsg(s:WARNING,"unable to apply<".exe."> to file<".fname.">",50)
                                 endif
                                endif
                                unlet sfx
                            
                                if exists("exe")
                                 unlet exe
                                elseif a:islocal
                                 " fname not a compressed file, so compress it
                                 call system(netrw#WinPath(g:netrw_compress)." ".shellescape(s:ComposePath(b:netrw_curdir,fname)))
                                else
                                 " fname not a compressed file, so compress it
                                 keepj call s:RemoteSystem(netrw#WinPath(g:netrw_compress)." ".shellescape(fname))
                                endif
                               endfor	" for every file in the marked list
                            
                               call s:NetrwUnmarkList(curbufnr,curdir)
                               keepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
                               keepj call netrw#NetrwRestorePosn(svpos)
                              endif
                            "  call Dret("s:NetrwMarkFileCompress")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwMarkFileCopy: (invoked by mc) copy marked files to target {{{2
                            "                      If no marked files, then set up directory as the
                            "                      target.  Currently does not support copying entire
                            "                      directories.  Uses the local-buffer marked file list.
                            "                      Returns 1=success  (used by NetrwMarkFileMove())
                            "                              0=failure
    1              0.000003 fun! s:NetrwMarkFileCopy(islocal,...)
                            "  call Dfunc("s:NetrwMarkFileCopy(islocal=".a:islocal.") target<".(exists("s:netrwmftgt")? s:netrwmftgt : '---')."> a:0=".a:0)
                            
                              if !exists("b:netrw_curdir")
                               let b:netrw_curdir= getcwd()
                            "   call Decho("set b:netrw_curdir<".b:netrw_curdir."> (used getcwd)")
                              endif
                              let curdir   = b:netrw_curdir
                              let curbufnr = bufnr("%")
                            
                              " sanity check
                              if !exists("s:netrwmarkfilelist_{curbufnr}") || empty(s:netrwmarkfilelist_{curbufnr})
                               keepj call netrw#ErrorMsg(2,"there are no marked files in this window (:help netrw-mf)",66)
                            "   call Dret("s:NetrwMarkFileCopy")
                               return
                              endif
                            "  call Decho("sanity chk passed: s:netrwmarkfilelist_".curbufnr."<".string(s:netrwmarkfilelist_{curbufnr}))
                            
                              if !exists("s:netrwmftgt")
                               keepj call netrw#ErrorMsg(s:ERROR,"your marked file target is empty! (:help netrw-mt)",67)
                            "   call Dret("s:NetrwMarkFileCopy 0")
                               return 0
                              endif
                            "  call Decho("sanity chk passed: s:netrwmftgt<".s:netrwmftgt.">")
                            
                              if      a:islocal &&  s:netrwmftgt_islocal
                               " Copy marked files, local directory to local directory
                            "   call Decho("copy from local to local")
                               if !executable(g:netrw_localcopycmd) && g:netrw_localcopycmd !~ '\<cmd\s'
                                call netrw#ErrorMsg(s:ERROR,"g:netrw_localcopycmd<".g:netrw_localcopycmd."> not executable on your system, aborting",91)
                            "    call Dfunc("s:NetrwMarkFileMove : g:netrw_localcopycmd<".g:netrw_localcopycmd."> n/a!")
                                return
                               endif
                            
                               " copy marked files while within the same directory (ie. allow renaming)
                               if simplify(s:netrwmftgt) == simplify(b:netrw_curdir)
                                if len(s:netrwmarkfilelist_{bufnr('%')}) == 1
                                 " only one marked file
                                 let args    = shellescape(b:netrw_curdir."/".s:netrwmarkfilelist_{bufnr('%')}[0])
                                 let oldname = s:netrwmarkfilelist_{bufnr('%')}[0]
                                elseif a:0 == 1
                                 " this happens when the next case was used to recursively call s:NetrwMarkFileCopy()
                                 let args    = shellescape(b:netrw_curdir."/".a:1)
                                 let oldname = a:1
                                else
                                 " copy multiple marked files inside the same directory
                                 let s:recursive= 1
                                 for oldname in s:netrwmarkfilelist_{bufnr("%")}
                                  let ret= s:NetrwMarkFileCopy(a:islocal,oldname)
                                  if ret == 0
                                   break
                                  endif
                                 endfor
                                 unlet s:recursive
                                 call s:NetrwUnmarkList(curbufnr,curdir)
                            "     call Dret("s:NetrwMarkFileCopy ".ret)
                                 return ret
                                endif
                            
                                call inputsave()
                                let newname= input("Copy ".oldname." to : ",oldname,"file")
                                call inputrestore()
                                if newname == ""
                            "     call Dret("s:NetrwMarkFileCopy 0")
                                 return 0
                                endif
                                let args= shellescape(oldname)
                                let tgt = shellescape(s:netrwmftgt.'/'.newname)
                               else
                                let args= join(map(deepcopy(s:netrwmarkfilelist_{bufnr('%')}),"shellescape(b:netrw_curdir.\"/\".v:val)"))
                                let tgt = shellescape(s:netrwmftgt)
                               endif
                               if !g:netrw_cygwin && (has("win32") || has("win95") || has("win64") || has("win16"))
                                let args= substitute(args,'/','\\','g')
                                let tgt = substitute(tgt, '/','\\','g')
                               endif
                               if g:netrw_localcopycmd =~ '\s'
                                let copycmd     = substitute(g:netrw_localcopycmd,'\s.*$','','')
                                let copycmdargs = substitute(g:netrw_localcopycmd,'^.\{-}\(\s.*\)$','\1','')
                                let copycmd     = netrw#WinPath(copycmd).copycmdargs
                               else
                                let copycmd = netrw#WinPath(g:netrw_localcopycmd)
                               endif
                            "   call Decho("args   <".args.">")
                            "   call Decho("tgt    <".tgt.">")
                            "   call Decho("copycmd<".copycmd.">")
                            "   call Decho("system(".copycmd." ".args." ".tgt.")")
                               call system(copycmd." ".args." ".tgt)
                               if v:shell_error != 0
                                call netrw#ErrorMsg(s:ERROR,"tried using g:netrw_localcopycmd<".g:netrw_localcopycmd.">; it doesn't work!",80)
                            "    call Dret("s:NetrwMarkFileCopy 0 : failed: system(".g:netrw_localcopycmd." ".args." ".shellescape(s:netrwmftgt))
                                return 0
                               endif
                            
                              elseif  a:islocal && !s:netrwmftgt_islocal
                               " Copy marked files, local directory to remote directory
                            "   call Decho("copy from local to remote")
                               keepj call s:NetrwUpload(s:netrwmarkfilelist_{bufnr('%')},s:netrwmftgt)
                            
                              elseif !a:islocal &&  s:netrwmftgt_islocal
                               " Copy marked files, remote directory to local directory
                            "   call Decho("copy from remote to local")
                               keepj call netrw#NetrwObtain(a:islocal,s:netrwmarkfilelist_{bufnr('%')},s:netrwmftgt)
                            
                              elseif !a:islocal && !s:netrwmftgt_islocal
                               " Copy marked files, remote directory to remote directory
                            "   call Decho("copy from remote to remote")
                               let curdir = getcwd()
                               let tmpdir = s:GetTempfile("")
                               if tmpdir !~ '/'
                                let tmpdir= curdir."/".tmpdir
                               endif
                               if exists("*mkdir")
                                call mkdir(tmpdir)
                               else
                                exe "sil! !".g:netrw_localmkdir.' '.shellescape(tmpdir,1)
                                if v:shell_error != 0
                                 call netrw#ErrorMsg(s:WARNING,"consider setting g:netrw_localmkdir<".g:netrw_localmkdir."> to something that works",80)
                            "     call Dret("s:NetrwMarkFileCopy : failed: sil! !".g:netrw_localmkdir.' '.shellescape(tmpdir,1) )
                                 return
                                endif
                               endif
                               if isdirectory(tmpdir)
                                exe "keepj lcd ".fnameescape(tmpdir)
                                keepj call netrw#NetrwObtain(a:islocal,s:netrwmarkfilelist_{bufnr('%')},tmpdir)
                                let localfiles= map(deepcopy(s:netrwmarkfilelist_{bufnr('%')}),'substitute(v:val,"^.*/","","")')
                                keepj call s:NetrwUpload(localfiles,s:netrwmftgt)
                                if getcwd() == tmpdir
                                 for fname in s:netrwmarkfilelist_{bufnr('%')}
                                  keepj call s:NetrwDelete(fname)
                                 endfor
                                 exe "keepj lcd ".fnameescape(curdir)
                                 exe "sil !".g:netrw_localrmdir." ".shellescape(tmpdir,1)
                                 if v:shell_error != 0
                                  call netrw#ErrorMsg(s:WARNING,"consider setting g:netrw_localrmdir<".g:netrw_localrmdir."> to something that works",80)
                            "      call Dret("s:NetrwMarkFileCopy : failed: sil !".g:netrw_localrmdir." ".shellescape(tmpdir,1) )
                                  return
                                 endif
                                else
                                 exe "keepj lcd ".fnameescape(curdir)
                                endif
                               endif
                              endif
                            
                              " -------
                              " cleanup
                              " -------
                            "   call Decho("cleanup")
                              if !exists("s:recursive")
                               " remove markings from local buffer
                               call s:NetrwUnmarkList(curbufnr,curdir)
                              endif
                            
                              " refresh buffers
                              if !s:netrwmftgt_islocal
                               call s:NetrwRefreshDir(s:netrwmftgt_islocal,s:netrwmftgt)
                              endif
                              if a:islocal
                               keepj call s:NetrwRefreshDir(a:islocal,curdir)
                              endif
                              if g:netrw_fastbrowse <= 1
                               keepj call s:LocalBrowseShellCmdRefresh()
                              endif
                              
                            "  call Dret("s:NetrwMarkFileCopy 1")
                              return 1
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwMarkFileDiff: (invoked by md) This function is used to {{{2
                            "                      invoke vim's diff mode on the marked files.
                            "                      Either two or three files can be so handled.
                            "                      Uses the global marked file list.
    1              0.000003 fun! s:NetrwMarkFileDiff(islocal)
                            "  call Dfunc("s:NetrwMarkFileDiff(islocal=".a:islocal.") b:netrw_curdir<".b:netrw_curdir.">")
                              let curbufnr= bufnr("%")
                            
                              " sanity check
                              if !exists("s:netrwmarkfilelist_{curbufnr}") || empty(s:netrwmarkfilelist_{curbufnr})
                               keepj call netrw#ErrorMsg(2,"there are no marked files in this window (:help netrw-mf)",66)
                            "   call Dret("s:NetrwMarkFileDiff")
                               return
                              endif
                            "  call Decho("sanity chk passed: s:netrwmarkfilelist_".curbufnr."<".string(s:netrwmarkfilelist_{curbufnr}))
                            
                              if exists("s:netrwmarkfilelist_{."curbufnr}")
                               let cnt    = 0
                               let curdir = b:netrw_curdir
                               for fname in s:netrwmarkfilelist
                                let cnt= cnt + 1
                                if cnt == 1
                            "     call Decho("diffthis: fname<".fname.">")
                                 exe "e ".fnameescape(fname)
                                 diffthis
                                elseif cnt == 2 || cnt == 3
                                 vsplit
                                 wincmd l
                            "     call Decho("diffthis: ".fname)
                                 exe "e ".fnameescape(fname)
                                 diffthis
                                else
                                 break
                                endif
                               endfor
                               call s:NetrwUnmarkList(curbufnr,curdir)
                              endif
                            
                            "  call Dret("s:NetrwMarkFileDiff")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwMarkFileEdit: (invoked by me) put marked files on arg list and start editing them {{{2
                            "                       Uses global markfilelist
    1              0.000003 fun! s:NetrwMarkFileEdit(islocal)
                            "  call Dfunc("s:NetrwMarkFileEdit(islocal=".a:islocal.")")
                            
                              let curdir   = b:netrw_curdir
                              let curbufnr = bufnr("%")
                            
                              " sanity check
                              if !exists("s:netrwmarkfilelist_{curbufnr}") || empty(s:netrwmarkfilelist_{curbufnr})
                               keepj call netrw#ErrorMsg(2,"there are no marked files in this window (:help netrw-mf)",66)
                            "   call Dret("s:NetrwMarkFileEdit")
                               return
                              endif
                            "  call Decho("sanity chk passed: s:netrwmarkfilelist_".curbufnr."<".string(s:netrwmarkfilelist_{curbufnr}))
                            
                              if exists("s:netrwmarkfilelist_{curbufnr}")
                               call s:SetRexDir(a:islocal,curdir)
                               let flist= join(map(deepcopy(s:netrwmarkfilelist), "fnameescape(v:val)"))
                               " unmark markedfile list
                            "   call s:NetrwUnmarkList(curbufnr,curdir)
                               call s:NetrwUnmarkAll()
                            "   call Decho("exe sil args ".flist)
                               exe "sil args ".flist
                              endif
                              echo "(use :bn, :bp to navigate files; :Rex to return)"
                              
                            "  call Dret("s:NetrwMarkFileEdit")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwMarkFileQFEL: convert a quickfix-error list into a marked file list {{{2
    1              0.000003 fun! s:NetrwMarkFileQFEL(islocal,qfel)
                            "  call Dfunc("s:NetrwMarkFileQFEL(islocal=".a:islocal.",qfel)")
                              call s:NetrwUnmarkAll()
                              let curbufnr= bufnr("%")
                            
                              if !empty(a:qfel)
                               for entry in a:qfel
                                let bufnmbr= entry["bufnr"]
                            "    call Decho("bufname(".bufnmbr.")<".bufname(bufnmbr)."> line#".entry["lnum"]." text=".entry["text"])
                                if !exists("s:netrwmarkfilelist_{curbufnr}")
                            "     call Decho("case: no marked file list")
                                 call s:NetrwMarkFile(a:islocal,bufname(bufnmbr))
                                elseif index(s:netrwmarkfilelist_{curbufnr},bufname(bufnmbr)) == -1
                                 " s:NetrwMarkFile will remove duplicate entries from the marked file list.
                                 " So, this test lets two or more hits on the same pattern to be ignored.
                            "     call Decho("case: ".bufname(bufnmbr)." not currently in marked file list")
                                 call s:NetrwMarkFile(a:islocal,bufname(bufnmbr))
                                else
                            "     call Decho("case: ".bufname(bufnmbr)." already in marked file list")
                                endif
                               endfor
                               echo "(use me to edit marked files)"
                              else
                               call netrw#ErrorMsg(s:WARNING,"can't convert quickfix error list; its empty!",92)
                              endif
                            
                            "  call Dret("s:NetrwMarkFileQFEL")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwMarkFileExe: (invoked by mx) execute arbitrary system command on marked files, one at a time {{{2
                            "                     Uses the local marked-file list.
    1              0.000003 fun! s:NetrwMarkFileExe(islocal)
                            "  call Dfunc("s:NetrwMarkFileExe(islocal=".a:islocal.")")
                              let svpos    = netrw#NetrwSavePosn()
                              let curdir   = b:netrw_curdir
                              let curbufnr = bufnr("%")
                            
                              " sanity check
                              if !exists("s:netrwmarkfilelist_{curbufnr}") || empty(s:netrwmarkfilelist_{curbufnr})
                               keepj call netrw#ErrorMsg(2,"there are no marked files in this window (:help netrw-mf)",66)
                            "   call Dret("s:NetrwMarkFileExe")
                               return
                              endif
                            "  call Decho("sanity chk passed: s:netrwmarkfilelist_".curbufnr."<".string(s:netrwmarkfilelist_{curbufnr}))
                            
                              if exists("s:netrwmarkfilelist_{curbufnr}")
                               " get the command
                               call inputsave()
                               let cmd= input("Enter command: ","","file")
                               call inputrestore()
                            "   call Decho("cmd<".cmd.">")
                               if cmd == ""
                            "    "   call Dret("s:NetrwMarkFileExe : early exit, empty command")
                                return
                               endif
                            
                               " apply command to marked files.  Substitute: filename -> %
                               " If no %, then append a space and the filename to the command
                               for fname in s:netrwmarkfilelist_{curbufnr}
                                if a:islocal
                                 if g:netrw_keepdir
                                  let fname= shellescape(netrw#WinPath(s:ComposePath(curdir,fname)))
                                 endif
                                else
                                 let fname= shellescape(netrw#WinPath(b:netrw_curdir.fname))
                                endif
                                if cmd =~ '%'
                                 let xcmd= substitute(cmd,'%',fname,'g')
                                else
                                 let xcmd= cmd.' '.fname
                                endif
                                if a:islocal
                            "     call Decho("local: xcmd<".xcmd.">")
                                 let ret= system(xcmd)
                                else
                            "     call Decho("remote: xcmd<".xcmd.">")
                                 let ret= s:RemoteSystem(xcmd)
                                endif
                                if v:shell_error < 0
                                 keepj call netrw#ErrorMsg(s:ERROR,"command<".xcmd."> failed, aborting",54)
                                 break
                                else
                                 echo ret
                                endif
                               endfor
                            
                               " unmark marked file list
                               call s:NetrwUnmarkList(curbufnr,curdir)
                            
                               " refresh the listing
                               keepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
                               keepj call netrw#NetrwRestorePosn(svpos)
                              else
                               keepj call netrw#ErrorMsg(s:ERROR,"no files marked!",59)
                              endif
                              
                            "  call Dret("s:NetrwMarkFileExe")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwMarkHideSfx: (invoked by mh) (un)hide files having same suffix
                            "                  as the marked file(s) (toggles suffix presence)
                            "                  Uses the local marked file list.
    1              0.000002 fun! s:NetrwMarkHideSfx(islocal)
                            "  call Dfunc("s:NetrwMarkHideSfx(islocal=".a:islocal.")")
                              let svpos    = netrw#NetrwSavePosn()
                              let curbufnr = bufnr("%")
                            
                              " s:netrwmarkfilelist_{curbufnr}: the List of marked files
                              if exists("s:netrwmarkfilelist_{curbufnr}")
                            
                               for fname in s:netrwmarkfilelist_{curbufnr}
                            "     call Decho("s:NetrwMarkFileCopy: fname<".fname.">")
                                 " construct suffix pattern
                                 if fname =~ '\.'
                                  let sfxpat= "^.*".substitute(fname,'^.*\(\.[^. ]\+\)$','\1','')
                                 else
                                  let sfxpat= '^\%(\%(\.\)\@!.\)*$'
                                 endif
                                 " determine if its in the hiding list or not
                                 let inhidelist= 0
                                 if g:netrw_list_hide != ""
                                  let itemnum = 0
                                  let hidelist= split(g:netrw_list_hide,',')
                                  for hidepat in hidelist
                                   if sfxpat == hidepat
                                    let inhidelist= 1
                                    break
                                   endif
                                   let itemnum= itemnum + 1
                                  endfor
                                 endif
                            "     call Decho("fname<".fname."> inhidelist=".inhidelist." sfxpat<".sfxpat.">")
                                 if inhidelist
                                  " remove sfxpat from list
                                  call remove(hidelist,itemnum)
                                  let g:netrw_list_hide= join(hidelist,",")
                                 elseif g:netrw_list_hide != ""
                                  " append sfxpat to non-empty list
                                  let g:netrw_list_hide= g:netrw_list_hide.",".sfxpat
                                 else
                                  " set hiding list to sfxpat
                                  let g:netrw_list_hide= sfxpat
                                 endif
                                endfor
                            
                               " refresh the listing
                               keepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
                               keepj call netrw#NetrwRestorePosn(svpos)
                              else
                               keepj call netrw#ErrorMsg(s:ERROR,"no files marked!",59)
                              endif
                            
                            "  call Dret("s:NetrwMarkHideSfx")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwMarkFileVimCmd: (invoked by mX) execute arbitrary vim command on marked files, one at a time {{{2
                            "                     Uses the local marked-file list.
    1              0.000003 fun! s:NetrwMarkFileVimCmd(islocal)
                            "  call Dfunc("s:NetrwMarkFileVimCmd(islocal=".a:islocal.")")
                              let svpos    = netrw#NetrwSavePosn()
                              let curdir   = b:netrw_curdir
                              let curbufnr = bufnr("%")
                            
                              " sanity check
                              if !exists("s:netrwmarkfilelist_{curbufnr}") || empty(s:netrwmarkfilelist_{curbufnr})
                               keepj call netrw#ErrorMsg(2,"there are no marked files in this window (:help netrw-mf)",66)
                            "   call Dret("s:NetrwMarkFileVimCmd")
                               return
                              endif
                            "  call Decho("sanity chk passed: s:netrwmarkfilelist_".curbufnr."<".string(s:netrwmarkfilelist_{curbufnr}))
                            
                              if exists("s:netrwmarkfilelist_{curbufnr}")
                               " get the command
                               call inputsave()
                               let cmd= input("Enter vim command: ","","file")
                               call inputrestore()
                            "   call Decho("cmd<".cmd.">")
                               if cmd == ""
                            "    "   call Dret("s:NetrwMarkFileVimCmd : early exit, empty command")
                                return
                               endif
                            
                               " apply command to marked files.  Substitute: filename -> %
                               " If no %, then append a space and the filename to the command
                               for fname in s:netrwmarkfilelist_{curbufnr}
                            "    call Decho("fname<".fname.">")
                                if a:islocal
                                 1split
                                 exe "sil! keepalt e ".fnameescape(fname)
                            "     call Decho("local<".fname.">: exe ".cmd)
                                 exe cmd
                                 exe "sil! keepalt wq!"
                                else
                            "     call Decho("remote<".fname.">: exe ".cmd." : NOT SUPPORTED YET")
                                 echo "sorry, \"mX\" not supported yet for remote files"
                                endif
                               endfor
                            
                               " unmark marked file list
                               call s:NetrwUnmarkList(curbufnr,curdir)
                            
                               " refresh the listing
                               keepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
                               keepj call netrw#NetrwRestorePosn(svpos)
                              else
                               keepj call netrw#ErrorMsg(s:ERROR,"no files marked!",59)
                              endif
                              
                            "  call Dret("s:NetrwMarkFileVimCmd")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwMarkHideSfx: (invoked by mh) (un)hide files having same suffix
                            "                  as the marked file(s) (toggles suffix presence)
                            "                  Uses the local marked file list.
    1              0.000003 fun! s:NetrwMarkHideSfx(islocal)
                            "  call Dfunc("s:NetrwMarkHideSfx(islocal=".a:islocal.")")
                              let svpos    = netrw#NetrwSavePosn()
                              let curbufnr = bufnr("%")
                            
                              " s:netrwmarkfilelist_{curbufnr}: the List of marked files
                              if exists("s:netrwmarkfilelist_{curbufnr}")
                            
                               for fname in s:netrwmarkfilelist_{curbufnr}
                            "     call Decho("s:NetrwMarkFileCopy: fname<".fname.">")
                                 " construct suffix pattern
                                 if fname =~ '\.'
                                  let sfxpat= "^.*".substitute(fname,'^.*\(\.[^. ]\+\)$','\1','')
                                 else
                                  let sfxpat= '^\%(\%(\.\)\@!.\)*$'
                                 endif
                                 " determine if its in the hiding list or not
                                 let inhidelist= 0
                                 if g:netrw_list_hide != ""
                                  let itemnum = 0
                                  let hidelist= split(g:netrw_list_hide,',')
                                  for hidepat in hidelist
                                   if sfxpat == hidepat
                                    let inhidelist= 1
                                    break
                                   endif
                                   let itemnum= itemnum + 1
                                  endfor
                                 endif
                            "     call Decho("fname<".fname."> inhidelist=".inhidelist." sfxpat<".sfxpat.">")
                                 if inhidelist
                                  " remove sfxpat from list
                                  call remove(hidelist,itemnum)
                                  let g:netrw_list_hide= join(hidelist,",")
                                 elseif g:netrw_list_hide != ""
                                  " append sfxpat to non-empty list
                                  let g:netrw_list_hide= g:netrw_list_hide.",".sfxpat
                                 else
                                  " set hiding list to sfxpat
                                  let g:netrw_list_hide= sfxpat
                                 endif
                                endfor
                            
                               " refresh the listing
                               keepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
                               keepj call netrw#NetrwRestorePosn(svpos)
                              else
                               keepj call netrw#ErrorMsg(s:ERROR,"no files marked!",59)
                              endif
                            
                            "  call Dret("s:NetrwMarkHideSfx")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwMarkFileGrep: (invoked by mg) This function applies vimgrep to marked files {{{2
                            "                     Uses the global markfilelist
    1              0.000003 fun! s:NetrwMarkFileGrep(islocal)
                            "  call Dfunc("s:NetrwMarkFileGrep(islocal=".a:islocal.")")
                              let svpos    = netrw#NetrwSavePosn()
                              let curbufnr = bufnr("%")
                            
                              if exists("s:netrwmarkfilelist")
                            "  call Decho("s:netrwmarkfilelist".string(s:netrwmarkfilelist).">")
                               let netrwmarkfilelist= join(map(deepcopy(s:netrwmarkfilelist), "fnameescape(v:val)"))
                               call s:NetrwUnmarkAll()
                              else
                            "   call Decho('no marked files, using "*"')
                               let netrwmarkfilelist= "*"
                              endif
                            
                              " ask user for pattern
                              call inputsave()
                              let pat= input("Enter pattern: ","")
                              call inputrestore()
                              let patbang = ""
                              if pat =~ '^!'
                               let patbang = "!"
                               let pat= strpart(pat,2)
                              endif
                              if pat =~ '^\i'
                               let pat    = escape(pat,'/')
                               let pat    = '/'.pat.'/'
                              else
                               let nonisi = pat[0]
                              endif
                            
                              " use vimgrep for both local and remote
                            "  call Decho("exe vimgrep".patbang." ".pat." ".netrwmarkfilelist)
                              try
                               exe "keepj noautocmd vimgrep".patbang." ".pat." ".netrwmarkfilelist
                              catch /^Vim\%((\a\+)\)\=:E480/
                               keepj call netrw#ErrorMsg(s:WARNING,"no match with pattern<".pat.">",76)
                            "   call Dret("s:NetrwMarkFileGrep : unable to find pattern<".pat.">")
                               return
                              endtry
                              echo "(use :cn, :cp to navigate, :Rex to return)"
                            
                              2match none
                              keepj call netrw#NetrwRestorePosn(svpos)
                            
                              if exists("nonisi")
                               " original, user-supplied pattern did not begin with a character from isident
                            "   call Decho("looking for trailing nonisi<".nonisi."> followed by a j, gj, or jg")
                               if pat =~ nonisi.'j$\|'.nonisi.'gj$\|'.nonisi.'jg$'
                                call s:NetrwMarkFileQFEL(a:islocal,getqflist())
                               endif
                              endif
                            
                            "  call Dret("s:NetrwMarkFileGrep")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwMarkFileMove: (invoked by mm) execute arbitrary command on marked files, one at a time {{{2
                            "                      uses the global marked file list
                            "                      s:netrwmfloc= 0: target directory is remote
                            "                                  = 1: target directory is local
    1              0.000003 fun! s:NetrwMarkFileMove(islocal)
                            "  call Dfunc("s:NetrwMarkFileMove(islocal=".a:islocal.")")
                              let curdir   = b:netrw_curdir
                              let curbufnr = bufnr("%")
                            
                              " sanity check
                              if !exists("s:netrwmarkfilelist_{curbufnr}") || empty(s:netrwmarkfilelist_{curbufnr})
                               keepj call netrw#ErrorMsg(2,"there are no marked files in this window (:help netrw-mf)",66)
                            "   call Dret("s:NetrwMarkFileMove")
                               return
                              endif
                            "  call Decho("sanity chk passed: s:netrwmarkfilelist_".curbufnr."<".string(s:netrwmarkfilelist_{curbufnr}))
                            
                              if !exists("s:netrwmftgt")
                               keepj call netrw#ErrorMsg(2,"your marked file target is empty! (:help netrw-mt)",67)
                            "   call Dret("s:NetrwMarkFileCopy 0")
                               return 0
                              endif
                            "  call Decho("sanity chk passed: s:netrwmftgt<".s:netrwmftgt.">")
                            
                              if      a:islocal &&  s:netrwmftgt_islocal
                               " move: local -> local
                            "   call Decho("move from local to local")
                            "   call Decho("(s:NetrwMarkFileMove) local to local move")
                               if !executable(g:netrw_localmovecmd) && g:netrw_localmovecmd !~ '\<cmd\s'
                                call netrw#ErrorMsg(s:ERROR,"g:netrw_localmovecmd<".g:netrw_localmovecmd."> not executable on your system, aborting",90)
                            "    call Dfunc("s:NetrwMarkFileMove : g:netrw_localmovecmd<".g:netrw_localmovecmd."> n/a!")
                                return
                               endif
                               let tgt         = shellescape(s:netrwmftgt)
                            "   call Decho("tgt<".tgt.">")
                               if !g:netrw_cygwin && (has("win32") || has("win95") || has("win64") || has("win16"))
                                let tgt         = substitute(tgt, '/','\\','g')
                            "    call Decho("windows exception: tgt<".tgt.">")
                                if g:netrw_localmovecmd =~ '\s'
                                 let movecmd     = substitute(g:netrw_localmovecmd,'\s.*$','','')
                                 let movecmdargs = substitute(g:netrw_localmovecmd,'^.\{-}\(\s.*\)$','\1','')
                                 let movecmd     = netrw#WinPath(movecmd).movecmdargs
                            "     call Decho("windows exception: movecmd<".movecmd."> (#1: had a space)")
                                else
                                 let movecmd = netrw#WinPath(movecmd)
                            "     call Decho("windows exception: movecmd<".movecmd."> (#2: no space)")
                                endif
                               else
                                let movecmd = netrw#WinPath(g:netrw_localmovecmd)
                            "    call Decho("movecmd<".movecmd."> (#3 linux or cygwin)")
                               endif
                               for fname in s:netrwmarkfilelist_{bufnr("%")}
                            "    call Decho("system(".movecmd." ".shellescape(fname)." ".tgt.")")
                                if !g:netrw_cygwin && (has("win32") || has("win95") || has("win64") || has("win16"))
                                 let fname= substitute(fname,'/','\\','g')
                                endif
                                let ret= system(g:netrw_localmovecmd." ".shellescape(fname)." ".tgt)
                                if v:shell_error != 0
                                 call netrw#ErrorMsg(s:ERROR,"tried using g:netrw_localmovecmd<".g:netrw_localmovecmd.">; it doesn't work!",54)
                                 break
                                endif
                               endfor
                            
                              elseif  a:islocal && !s:netrwmftgt_islocal
                               " move: local -> remote
                            "   call Decho("move from local to remote")
                            "   call Decho("copy")
                               let mflist= s:netrwmarkfilelist_{bufnr("%")}
                               keepj call s:NetrwMarkFileCopy(a:islocal)
                            "   call Decho("remove")
                               for fname in mflist
                                let barefname = substitute(fname,'^\(.*/\)\(.\{-}\)$','\2','')
                                let ok        = s:NetrwLocalRmFile(b:netrw_curdir,barefname,1)
                               endfor
                               unlet mflist
                            
                              elseif !a:islocal &&  s:netrwmftgt_islocal
                               " move: remote -> local
                            "   call Decho("move from remote to local")
                            "   call Decho("copy")
                               let mflist= s:netrwmarkfilelist_{bufnr("%")}
                               keepj call s:NetrwMarkFileCopy(a:islocal)
                            "   call Decho("remove")
                               for fname in mflist
                                let barefname = substitute(fname,'^\(.*/\)\(.\{-}\)$','\2','')
                                let ok        = s:NetrwRemoteRmFile(b:netrw_curdir,barefname,1)
                               endfor
                               unlet mflist
                            
                              elseif !a:islocal && !s:netrwmftgt_islocal
                               " move: remote -> remote
                            "   call Decho("move from remote to remote")
                            "   call Decho("copy")
                               let mflist= s:netrwmarkfilelist_{bufnr("%")}
                               keepj call s:NetrwMarkFileCopy(a:islocal)
                            "   call Decho("remove")
                               for fname in mflist
                                let barefname = substitute(fname,'^\(.*/\)\(.\{-}\)$','\2','')
                                let ok        = s:NetrwRemoteRmFile(b:netrw_curdir,barefname,1)
                               endfor
                               unlet mflist
                              endif
                            
                              " -------
                              " cleanup
                              " -------
                            "  call Decho("cleanup")
                            
                              " remove markings from local buffer
                              call s:NetrwUnmarkList(curbufnr,curdir)                   " remove markings from local buffer
                            
                              " refresh buffers
                              if !s:netrwmftgt_islocal
                            "   call Decho("refresh netrwmftgt<".s:netrwmftgt.">")
                               keepj call s:NetrwRefreshDir(s:netrwmftgt_islocal,s:netrwmftgt)
                              endif
                              if a:islocal
                            "   call Decho("refresh b:netrw_curdir<".b:netrw_curdir.">")
                               keepj call s:NetrwRefreshDir(a:islocal,b:netrw_curdir)
                              endif
                              if g:netrw_fastbrowse <= 1
                            "   call Decho("since g:netrw_fastbrowse=".g:netrw_fastbrowse.", perform shell cmd refresh")
                               keepj call s:LocalBrowseShellCmdRefresh()
                              endif
                              
                            "  call Dret("s:NetrwMarkFileMove")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwMarkFilePrint: (invoked by mp) This function prints marked files {{{2
                            "                       using the hardcopy command.  Local marked-file list only.
    1              0.000006 fun! s:NetrwMarkFilePrint(islocal)
                            "  call Dfunc("s:NetrwMarkFilePrint(islocal=".a:islocal.")")
                              let curbufnr= bufnr("%")
                            
                              " sanity check
                              if !exists("s:netrwmarkfilelist_{curbufnr}") || empty(s:netrwmarkfilelist_{curbufnr})
                               keepj call netrw#ErrorMsg(2,"there are no marked files in this window (:help netrw-mf)",66)
                            "   call Dret("s:NetrwMarkFilePrint")
                               return
                              endif
                            "  call Decho("sanity chk passed: s:netrwmarkfilelist_".curbufnr."<".string(s:netrwmarkfilelist_{curbufnr}))
                              if exists("s:netrwmarkfilelist_{curbufnr}")
                               let netrwmarkfilelist = s:netrwmarkfilelist_{curbufnr}
                               let curdir            = b:netrw_curdir
                               call s:NetrwUnmarkList(curbufnr,curdir)
                               for fname in netrwmarkfilelist
                                if a:islocal
                                 if g:netrw_keepdir
                                  let fname= s:ComposePath(curdir,fname)
                                 endif
                                else
                                 let fname= curdir.fname
                                endif
                                1split
                                " the autocmds will handle both local and remote files
                            "    call Decho("exe sil e ".escape(fname,' '))
                                exe "sil e ".fnameescape(fname)
                            "    call Decho("hardcopy")
                                hardcopy
                                q
                               endfor
                               2match none
                              endif
                            "  call Dret("s:NetrwMarkFilePrint")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwMarkFileRegexp: (invoked by mr) This function is used to mark {{{2
                            "                        files when given a regexp (for which a prompt is
                            "                        issued) (matches to name of files).
    1              0.000005 fun! s:NetrwMarkFileRegexp(islocal)
                            "  call Dfunc("s:NetrwMarkFileRegexp(islocal=".a:islocal.")")
                            
                              " get the regular expression
                              call inputsave()
                              let regexp= input("Enter regexp: ","","file")
                              call inputrestore()
                            
                              if a:islocal
                               " get the matching list of files using local glob()
                            "   call Decho("handle local regexp")
                               let dirname = escape(b:netrw_curdir,g:netrw_glob_escape)
                               let files   = glob(s:ComposePath(dirname,regexp))
                            "   call Decho("files<".files.">")
                               let filelist= split(files,"\n")
                            
                              " mark the list of files
                              for fname in filelist
                            "   call Decho("fname<".fname.">")
                               keepj call s:NetrwMarkFile(a:islocal,substitute(fname,'^.*/','',''))
                              endfor
                            
                              else
                            "   call Decho("handle remote regexp")
                            
                               " convert displayed listing into a filelist
                               let eikeep = &ei
                               let areg   = @a
                               sil keepj %y a
                               set ei=all ma
                            "   call Decho("set ei=all ma")
                               1split
                               keepj call s:NetrwEnew()
                               keepj call s:NetrwSafeOptions()
                               sil keepj norm! "ap
                               keepj 2
                               let bannercnt= search('^" =====','W')
                               exe "sil keepj 1,".bannercnt."d"
                               set bt=nofile
                               if     g:netrw_liststyle == s:LONGLIST
                                sil keepj %s/\s\{2,}\S.*$//e
                                call histdel("/",-1)
                               elseif g:netrw_liststyle == s:WIDELIST
                                sil keepj %s/\s\{2,}/\r/ge
                                call histdel("/",-1)
                               elseif g:netrw_liststyle == s:TREELIST
                                sil keepj %s/^| //e
                                sil! keepj g/^ .*$/d
                                call histdel("/",-1)
                                call histdel("/",-1)
                               endif
                               " convert regexp into the more usual glob-style format
                               let regexp= substitute(regexp,'\*','.*','g')
                            "   call Decho("regexp<".regexp.">")
                               exe "sil! keepj v/".escape(regexp,'/')."/d"
                               call histdel("/",-1)
                               let filelist= getline(1,line("$"))
                               q!
                               for filename in filelist
                                keepj call s:NetrwMarkFile(a:islocal,substitute(filename,'^.*/','',''))
                               endfor
                               unlet filelist
                               let @a  = areg
                               let &ei = eikeep
                              endif
                              echo "  (use me to edit marked files)"
                            
                            "  call Dret("s:NetrwMarkFileRegexp")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwMarkFileSource: (invoked by ms) This function sources marked files {{{2
                            "                        Uses the local marked file list.
    1              0.000004 fun! s:NetrwMarkFileSource(islocal)
                            "  call Dfunc("s:NetrwMarkFileSource(islocal=".a:islocal.")")
                              let curbufnr= bufnr("%")
                            
                              " sanity check
                              if !exists("s:netrwmarkfilelist_{curbufnr}") || empty(s:netrwmarkfilelist_{curbufnr})
                               keepj call netrw#ErrorMsg(2,"there are no marked files in this window (:help netrw-mf)",66)
                            "   call Dret("s:NetrwMarkFileSource")
                               return
                              endif
                            "  call Decho("sanity chk passed: s:netrwmarkfilelist_".curbufnr."<".string(s:netrwmarkfilelist_{curbufnr}))
                              if exists("s:netrwmarkfilelist_{curbufnr}")
                               let netrwmarkfilelist = s:netrwmarkfilelist_{bufnr("%")}
                               let curdir            = b:netrw_curdir
                               call s:NetrwUnmarkList(curbufnr,curdir)
                               for fname in netrwmarkfilelist
                                if a:islocal
                                 if g:netrw_keepdir
                                  let fname= s:ComposePath(curdir,fname)
                                 endif
                                else
                                 let fname= curdir.fname
                                endif
                                " the autocmds will handle sourcing both local and remote files
                            "    call Decho("exe so ".fnameescape(fname))
                                exe "so ".fnameescape(fname)
                               endfor
                               2match none
                              endif
                            "  call Dret("s:NetrwMarkFileSource")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwMarkFileTag: (invoked by mT) This function applies g:netrw_ctags to marked files {{{2
                            "                     Uses the global markfilelist
    1              0.000004 fun! s:NetrwMarkFileTag(islocal)
                            "  call Dfunc("s:NetrwMarkFileTag(islocal=".a:islocal.")")
                              let svpos    = netrw#NetrwSavePosn()
                              let curdir   = b:netrw_curdir
                              let curbufnr = bufnr("%")
                            
                              " sanity check
                              if !exists("s:netrwmarkfilelist_{curbufnr}") || empty(s:netrwmarkfilelist_{curbufnr})
                               keepj call netrw#ErrorMsg(2,"there are no marked files in this window (:help netrw-mf)",66)
                            "   call Dret("s:NetrwMarkFileTag")
                               return
                              endif
                            "  call Decho("sanity chk passed: s:netrwmarkfilelist_".curbufnr."<".string(s:netrwmarkfilelist_{curbufnr}))
                            
                              if exists("s:netrwmarkfilelist")
                            "   call Decho("s:netrwmarkfilelist".string(s:netrwmarkfilelist).">")
                               let netrwmarkfilelist= join(map(deepcopy(s:netrwmarkfilelist), "shellescape(v:val,".!a:islocal.")"))
                               call s:NetrwUnmarkAll()
                            
                               if a:islocal
                                if executable(g:netrw_ctags)
                            "     call Decho("call system(".g:netrw_ctags." ".netrwmarkfilelist.")")
                                 call system(g:netrw_ctags." ".netrwmarkfilelist)
                                else
                                 call netrw#ErrorMsg(s:ERROR,"g:netrw_ctags<".g:netrw_ctags."> is not executable!",51)
                                endif
                               else
                                let cmd   = s:RemoteSystem(g:netrw_ctags." ".netrwmarkfilelist)
                                call netrw#NetrwObtain(a:islocal,"tags")
                                let curdir= b:netrw_curdir
                                1split
                                e tags
                                let path= substitute(curdir,'^\(.*\)/[^/]*$','\1/','')
                            "    call Decho("curdir<".curdir."> path<".path.">")
                                exe 'keepj %s/\t\(\S\+\)\t/\t'.escape(path,"/\n\r\\").'\1\t/e'
                                call histdel("/",-1)
                                wq!
                               endif
                               2match none
                               call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
                               call netrw#NetrwRestorePosn(svpos)
                              endif
                            
                            "  call Dret("s:NetrwMarkFileTag")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwMarkFileTgt:  (invoked by mt) This function sets up a marked file target {{{2
                            "   Sets up two variables, 
                            "     s:netrwmftgt         : holds the target directory
                            "     s:netrwmftgt_islocal : 0=target directory is remote
                            "                            1=target directory is local
    1              0.000009 fun! s:NetrwMarkFileTgt(islocal)
                            "  call Dfunc("s:NetrwMarkFileTgt(islocal=".a:islocal.")")
                              let svpos  = netrw#NetrwSavePosn()
                              let curdir = b:netrw_curdir
                              let hadtgt = exists("s:netrwmftgt")
                              if !exists("w:netrw_bannercnt")
                               let w:netrw_bannercnt= b:netrw_bannercnt
                              endif
                            
                              " set up target
                              if line(".") < w:netrw_bannercnt
                               " if cursor in banner region, use b:netrw_curdir for the target unless its already the target
                               if exists("s:netrwmftgt") && exists("s:netrwmftgt_islocal") && s:netrwmftgt == b:netrw_curdir
                            "    call Decho("cursor in banner region, and target already is <".b:netrw_curdir.">: removing target")
                                unlet s:netrwmftgt s:netrwmftgt_islocal
                                if g:netrw_fastbrowse <= 1
                                 call s:LocalBrowseShellCmdRefresh()
                                endif
                                call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
                                call netrw#NetrwRestorePosn(svpos)
                            "    call Dret("s:NetrwMarkFileTgt : removed target")
                                return
                               else
                                let s:netrwmftgt= b:netrw_curdir
                            "    call Decho("inbanner: s:netrwmftgt<".s:netrwmftgt.">")
                               endif
                            
                              else
                               " get word under cursor.
                               "  * If directory, use it for the target.
                               "  * If file, use b:netrw_curdir for the target
                               let curword= s:NetrwGetWord()
                               let tgtdir = s:ComposePath(curdir,curword)
                               if a:islocal && isdirectory(tgtdir)
                                let s:netrwmftgt = tgtdir
                            "    call Decho("local isdir: s:netrwmftgt<".s:netrwmftgt.">")
                               elseif !a:islocal && tgtdir =~ '/$'
                                let s:netrwmftgt = tgtdir
                            "    call Decho("remote isdir: s:netrwmftgt<".s:netrwmftgt.">")
                               else
                                let s:netrwmftgt = curdir
                            "    call Decho("isfile: s:netrwmftgt<".s:netrwmftgt.">")
                               endif
                              endif
                              if a:islocal
                               " simplify the target (eg. /abc/def/../ghi -> /abc/ghi)
                               let s:netrwmftgt= simplify(s:netrwmftgt)
                            "   call Decho("simplify: s:netrwmftgt<".s:netrwmftgt.">")
                              endif
                              if g:netrw_cygwin
                               let s:netrwmftgt= substitute(system("cygpath ".shellescape(s:netrwmftgt)),'\n$','','')
                               let s:netrwmftgt= substitute(s:netrwmftgt,'\n$','','')
                              endif
                              let s:netrwmftgt_islocal= a:islocal
                            
                              if g:netrw_fastbrowse <= 1
                               call s:LocalBrowseShellCmdRefresh()
                              endif
                              call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
                              call netrw#NetrwRestorePosn(svpos)
                              if !hadtgt
                               sil! keepj norm! j
                              endif
                            
                            "  call Dret("s:NetrwMarkFileTgt : netrwmftgt<".(exists("s:netrwmftgt")? s:netrwmftgt : "").">")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwOpenFile: query user for a filename and open it {{{2
    1              0.000005 fun! s:NetrwOpenFile(islocal)
                            "  call Dfunc("s:NetrwOpenFile(islocal=".a:islocal.")")
                              let ykeep= @@
                              call inputsave()
                              let fname= input("Enter filename: ")
                              call inputrestore()
                              if fname !~ '[/\\]'
                               if exists("b:netrw_curdir")
                                if exists("g:netrw_quiet")
                                 let netrw_quiet_keep = g:netrw_quiet
                                endif
                                let g:netrw_quiet    = 1
                                if b:netrw_curdir =~ '/$'
                                 exe "e ".fnameescape(b:netrw_curdir.fname)
                                else
                                 exe "e ".fnameescape(b:netrw_curdir."/".fname)
                                endif
                                if exists("netrw_quiet_keep")
                                 let g:netrw_quiet= netrw_quiet_keep
                                else
                                 unlet g:netrw_quiet
                                endif
                               endif
                              else
                               exe "e ".fnameescape(fname)
                              endif
                              let @@= ykeep
                            "  call Dret("s:NetrwOpenFile")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwUnmarkList: delete local marked file lists and remove their contents from the global marked-file list {{{2
                            "   User access provided by the <mu> mapping. (see :help netrw-mu)
                            "   Used by many MarkFile functions.
    1              0.000005 fun! s:NetrwUnmarkList(curbufnr,curdir)
                            "  call Dfunc("s:NetrwUnmarkList(curbufnr=".a:curbufnr." curdir<".a:curdir.">)")
                            
                              "  remove all files in local marked-file list from global list
                              if exists("s:netrwmarkfilelist_{a:curbufnr}")
                               for mfile in s:netrwmarkfilelist_{a:curbufnr}
                                let dfile = s:ComposePath(a:curdir,mfile)       " prepend directory to mfile
                                let idx   = index(s:netrwmarkfilelist,dfile)    " get index in list of dfile
                                call remove(s:netrwmarkfilelist,idx)            " remove from global list
                               endfor
                               if s:netrwmarkfilelist == []
                                unlet s:netrwmarkfilelist
                               endif
                             
                               " getting rid of the local marked-file lists is easy
                               unlet s:netrwmarkfilelist_{a:curbufnr}
                              endif
                              if exists("s:netrwmarkfilemtch_{a:curbufnr}")
                               unlet s:netrwmarkfilemtch_{a:curbufnr}
                              endif
                              2match none
                            "  call Dret("s:NetrwUnmarkList")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwUnmarkAll: remove the global marked file list and all local ones {{{2
    1              0.000004 fun! s:NetrwUnmarkAll()
                            "  call Dfunc("s:NetrwUnmarkAll()")
                              if exists("s:netrwmarkfilelist")
                               unlet s:netrwmarkfilelist
                              endif
                              sil call s:NetrwUnmarkAll2()
                              2match none
                            "  call Dret("s:NetrwUnmarkAll")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwUnmarkAll2: unmark all files from all buffers {{{2
    1              0.000004 fun! s:NetrwUnmarkAll2()
                            "  call Dfunc("s:NetrwUnmarkAll2()")
                              redir => netrwmarkfilelist_let
                              let
                              redir END
                              let netrwmarkfilelist_list= split(netrwmarkfilelist_let,'\n')          " convert let string into a let list
                              call filter(netrwmarkfilelist_list,"v:val =~ '^s:netrwmarkfilelist_'") " retain only those vars that start as s:netrwmarkfilelist_ 
                              call map(netrwmarkfilelist_list,"substitute(v:val,'\\s.*$','','')")    " remove what the entries are equal to
                              for flist in netrwmarkfilelist_list
                               let curbufnr= substitute(flist,'s:netrwmarkfilelist_','','')
                               unlet s:netrwmarkfilelist_{curbufnr}
                               unlet s:netrwmarkfilemtch_{curbufnr}
                              endfor
                            "  call Dret("s:NetrwUnmarkAll2")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwUnMarkFile: {{{2
    1              0.000009 fun! s:NetrwUnMarkFile(islocal)
                            "  call Dfunc("s:NetrwUnMarkFile(islocal=".a:islocal.")")
                              let svpos    = netrw#NetrwSavePosn()
                              let curbufnr = bufnr("%")
                            
                              " unmark marked file list (although I expect s:NetrwUpload()
                              " to do it, I'm just making sure)
                              if exists("s:netrwmarkfilelist_{bufnr('%')}")
                            "   call Decho("unlet'ing: s:netrwmarkfile[list|mtch]_".bufnr("%"))
                               unlet s:netrwmarkfilelist
                               unlet s:netrwmarkfilelist_{curbufnr}
                               unlet s:netrwmarkfilemtch_{curbufnr}
                               2match none
                              endif
                            
                            "  call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
                              call netrw#NetrwRestorePosn(svpos)
                            "  call Dret("s:NetrwUnMarkFile")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwMenu: generates the menu for gvim and netrw {{{2
    1              0.000012 fun! s:NetrwMenu(domenu)
                            
                              if !exists("g:NetrwMenuPriority")
                               let g:NetrwMenuPriority= 80
                              endif
                            
                              if has("menu") && has("gui_running") && &go =~# 'm' && g:netrw_menu
                            "   call Dfunc("NetrwMenu(domenu=".a:domenu.")")
                            
                               if !exists("s:netrw_menu_enabled") && a:domenu
                            "    call Decho("initialize menu")
                                let s:netrw_menu_enabled= 1
                                exe 'sil! menu '.g:NetrwMenuPriority.'.1      '.g:NetrwTopLvlMenu.'Help<tab><F1>	<F1>'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.5      '.g:NetrwTopLvlMenu.'-Sep1-	:'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.6      '.g:NetrwTopLvlMenu.'Go\ Up\ Directory<tab>-	-'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.7      '.g:NetrwTopLvlMenu.'Apply\ Special\ Viewer<tab>x	x'
                                if g:netrw_dirhistmax > 0
                                 exe 'sil! menu '.g:NetrwMenuPriority.'.8.1   '.g:NetrwTopLvlMenu.'Bookmarks\ and\ History.Bookmark\ Current\ Directory<tab>mb	mb'
                                 exe 'sil! menu '.g:NetrwMenuPriority.'.8.4   '.g:NetrwTopLvlMenu.'Bookmarks\ and\ History.Goto\ Prev\ Dir\ (History)<tab>u	u'
                                 exe 'sil! menu '.g:NetrwMenuPriority.'.8.5   '.g:NetrwTopLvlMenu.'Bookmarks\ and\ History.Goto\ Next\ Dir\ (History)<tab>U	U'
                                 exe 'sil! menu '.g:NetrwMenuPriority.'.8.6   '.g:NetrwTopLvlMenu.'Bookmarks\ and\ History.List<tab>qb	qb'
                                else
                                 exe 'sil! menu '.g:NetrwMenuPriority.'.8     '.g:NetrwTopLvlMenu.'Bookmarks\ and\ History	:echo "(disabled)"'."\<cr>"
                                endif
                                exe 'sil! menu '.g:NetrwMenuPriority.'.9.1    '.g:NetrwTopLvlMenu.'Browsing\ Control.Horizontal\ Split<tab>o	o'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.9.2    '.g:NetrwTopLvlMenu.'Browsing\ Control.Vertical\ Split<tab>v	v'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.9.3    '.g:NetrwTopLvlMenu.'Browsing\ Control.New\ Tab<tab>t	t'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.9.4    '.g:NetrwTopLvlMenu.'Browsing\ Control.Preview<tab>p	p'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.9.5    '.g:NetrwTopLvlMenu.'Browsing\ Control.Edit\ File\ Hiding\ List<tab><ctrl-h>'."	\<c-h>'"
                                exe 'sil! menu '.g:NetrwMenuPriority.'.9.6    '.g:NetrwTopLvlMenu.'Browsing\ Control.Edit\ Sorting\ Sequence<tab>S	S'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.9.7    '.g:NetrwTopLvlMenu.'Browsing\ Control.Quick\ Hide/Unhide\ Dot\ Files<tab>'."gh	gh"
                                exe 'sil! menu '.g:NetrwMenuPriority.'.9.8    '.g:NetrwTopLvlMenu.'Browsing\ Control.Refresh\ Listing<tab>'."<ctrl-l>	\<c-l>"
                                exe 'sil! menu '.g:NetrwMenuPriority.'.9.9    '.g:NetrwTopLvlMenu.'Browsing\ Control.Settings/Options<tab>:NetrwSettings	'.":NetrwSettings\<cr>"
                                exe 'sil! menu '.g:NetrwMenuPriority.'.10     '.g:NetrwTopLvlMenu.'Delete\ File/Directory<tab>D	D'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.11.1   '.g:NetrwTopLvlMenu.'Edit\ File/Dir.Create\ New\ File<tab>%	%'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.11.1   '.g:NetrwTopLvlMenu.'Edit\ File/Dir.In\ Current\ Window<tab><cr>	'."\<cr>"
                                exe 'sil! menu '.g:NetrwMenuPriority.'.11.2   '.g:NetrwTopLvlMenu.'Edit\ File/Dir.Preview\ File/Directory<tab>p	p'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.11.3   '.g:NetrwTopLvlMenu.'Edit\ File/Dir.In\ Previous\ Window<tab>P	P'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.11.4   '.g:NetrwTopLvlMenu.'Edit\ File/Dir.In\ New\ Window<tab>o	o'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.11.5   '.g:NetrwTopLvlMenu.'Edit\ File/Dir.In\ New\ Vertical\ Window<tab>v	v'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.12.1   '.g:NetrwTopLvlMenu.'Explore.Directory\ Name	:Explore '
                                exe 'sil! menu '.g:NetrwMenuPriority.'.12.2   '.g:NetrwTopLvlMenu.'Explore.Filenames\ Matching\ Pattern\ (curdir\ only)<tab>:Explore\ */	:Explore */'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.12.2   '.g:NetrwTopLvlMenu.'Explore.Filenames\ Matching\ Pattern\ (+subdirs)<tab>:Explore\ **/	:Explore **/'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.12.3   '.g:NetrwTopLvlMenu.'Explore.Files\ Containing\ String\ Pattern\ (curdir\ only)<tab>:Explore\ *//	:Explore *//'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.12.4   '.g:NetrwTopLvlMenu.'Explore.Files\ Containing\ String\ Pattern\ (+subdirs)<tab>:Explore\ **//	:Explore **//'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.12.4   '.g:NetrwTopLvlMenu.'Explore.Next\ Match<tab>:Nexplore	:Nexplore<cr>'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.12.4   '.g:NetrwTopLvlMenu.'Explore.Prev\ Match<tab>:Pexplore	:Pexplore<cr>'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.13     '.g:NetrwTopLvlMenu.'Make\ Subdirectory<tab>d	d'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.14.1   '.g:NetrwTopLvlMenu.'Marked\ Files.Mark\ File<tab>mf	mf'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.14.2   '.g:NetrwTopLvlMenu.'Marked\ Files.Mark\ Files\ by\ Regexp<tab>mr	mr'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.14.3   '.g:NetrwTopLvlMenu.'Marked\ Files.Hide-Show-List\ Control<tab>a	a'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.14.4   '.g:NetrwTopLvlMenu.'Marked\ Files.Copy\ To\ Target<tab>mc	mc'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.14.5   '.g:NetrwTopLvlMenu.'Marked\ Files.Delete<tab>D	D'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.14.6   '.g:NetrwTopLvlMenu.'Marked\ Files.Diff<tab>md	md'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.14.7   '.g:NetrwTopLvlMenu.'Marked\ Files.Edit<tab>me	me'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.14.8   '.g:NetrwTopLvlMenu.'Marked\ Files.Exe\ Cmd<tab>mx	mx'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.14.9   '.g:NetrwTopLvlMenu.'Marked\ Files.Move\ To\ Target<tab>mm	mm'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.14.10  '.g:NetrwTopLvlMenu.'Marked\ Files.Obtain<tab>O	O'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.14.11  '.g:NetrwTopLvlMenu.'Marked\ Files.Print<tab>mp	mp'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.14.12  '.g:NetrwTopLvlMenu.'Marked\ Files.Replace<tab>R	R'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.14.13  '.g:NetrwTopLvlMenu.'Marked\ Files.Set\ Target<tab>mt	mt'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.14.14  '.g:NetrwTopLvlMenu.'Marked\ Files.Tag<tab>mT	mT'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.14.15  '.g:NetrwTopLvlMenu.'Marked\ Files.Zip/Unzip/Compress/Uncompress<tab>mz	mz'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.15     '.g:NetrwTopLvlMenu.'Obtain\ File<tab>O	O'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.16.1.1 '.g:NetrwTopLvlMenu.'Style.Listing.thin<tab>i	:let w:netrw_liststyle=0<cr><c-L>'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.16.1.1 '.g:NetrwTopLvlMenu.'Style.Listing.long<tab>i	:let w:netrw_liststyle=1<cr><c-L>'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.16.1.1 '.g:NetrwTopLvlMenu.'Style.Listing.wide<tab>i	:let w:netrw_liststyle=2<cr><c-L>'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.16.1.1 '.g:NetrwTopLvlMenu.'Style.Listing.tree<tab>i	:let w:netrw_liststyle=3<cr><c-L>'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.16.2.1 '.g:NetrwTopLvlMenu.'Style.Normal-Hide-Show.Show\ All<tab>a	:let g:netrw_hide=0<cr><c-L>'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.16.2.3 '.g:NetrwTopLvlMenu.'Style.Normal-Hide-Show.Normal<tab>a	:let g:netrw_hide=1<cr><c-L>'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.16.2.2 '.g:NetrwTopLvlMenu.'Style.Normal-Hide-Show.Hidden\ Only<tab>a	:let g:netrw_hide=2<cr><c-L>'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.16.3   '.g:NetrwTopLvlMenu.'Style.Reverse\ Sorting\ Order<tab>'."r	r"
                                exe 'sil! menu '.g:NetrwMenuPriority.'.16.4.1 '.g:NetrwTopLvlMenu.'Style.Sorting\ Method.Name<tab>s       :let g:netrw_sort_by="name"<cr><c-L>'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.16.4.2 '.g:NetrwTopLvlMenu.'Style.Sorting\ Method.Time<tab>s       :let g:netrw_sort_by="time"<cr><c-L>'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.16.4.3 '.g:NetrwTopLvlMenu.'Style.Sorting\ Method.Size<tab>s       :let g:netrw_sort_by="size"<cr><c-L>'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.17     '.g:NetrwTopLvlMenu.'Rename\ File/Directory<tab>R	R'
                                exe 'sil! menu '.g:NetrwMenuPriority.'.18     '.g:NetrwTopLvlMenu.'Set\ Current\ Directory<tab>c	c'
                                let s:netrw_menucnt= 28
                                call s:NetrwBookmarkMenu() " provide some history!  uses priorities 2,3, reserves 4, 8.2.x
                                call s:NetrwTgtMenu()      " let bookmarks and history be easy targets
                            
                               elseif !a:domenu
                                let s:netrwcnt = 0
                                let curwin     = winnr()
                                windo if getline(2) =~ "Netrw" | let s:netrwcnt= s:netrwcnt + 1 | endif
                                exe curwin."wincmd w"
                            
                                if s:netrwcnt <= 1
                            "     call Decho("clear menus")
                                 exe 'sil! unmenu '.g:NetrwTopLvlMenu
                            "     call Decho('exe sil! unmenu '.g:NetrwTopLvlMenu.'*')
                                 sil! unlet s:netrw_menu_enabled
                                endif
                               endif
                            "   call Dret("NetrwMenu")
                               return
                              endif
                            
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwObtain: obtain file under cursor or from markfile list {{{2
                            "                Used by the O maps (as <SID>NetrwObtain())
    1              0.000005 fun! s:NetrwObtain(islocal)
                            "  call Dfunc("NetrwObtain(islocal=".a:islocal.")")
                            
                              let ykeep= @@
                              if exists("s:netrwmarkfilelist_{bufnr('%')}")
                               let islocal= s:netrwmarkfilelist_{bufnr('%')}[1] !~ '^\a\+://'
                               call netrw#NetrwObtain(islocal,s:netrwmarkfilelist_{bufnr('%')})
                               call s:NetrwUnmarkList(bufnr('%'),b:netrw_curdir)
                              else
                               call netrw#NetrwObtain(a:islocal,expand("<cWORD>"))
                              endif
                              let @@= ykeep
                            
                            "  call Dret("NetrwObtain")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwPrevWinOpen: open file/directory in previous window.  {{{2
                            "   If there's only one window, then the window will first be split.
                            "   Returns:
                            "     choice = 0 : didn't have to choose
                            "     choice = 1 : saved modified file in window first
                            "     choice = 2 : didn't save modified file, opened window
                            "     choice = 3 : cancel open
    1              0.000004 fun! s:NetrwPrevWinOpen(islocal)
                            "  call Dfunc("NetrwPrevWinOpen(islocal=".a:islocal.")")
                            
                              let ykeep= @@
                              " grab a copy of the b:netrw_curdir to pass it along to newly split windows
                              let curdir    = b:netrw_curdir
                            
                              " get last window number and the word currently under the cursor
                              let lastwinnr = winnr("$")
                              let curword   = s:NetrwGetWord()
                              let choice    = 0
                            "  call Decho("lastwinnr=".lastwinnr." curword<".curword.">")
                            
                              let didsplit  = 0
                              if lastwinnr == 1
                               " if only one window, open a new one first
                            "   call Decho("only one window, so open a new one (g:netrw_alto=".g:netrw_alto.")")
                               if g:netrw_preview
                                let winsz= (g:netrw_winsize > 0)? (g:netrw_winsize*winheight(0))/100 : -g:netrw_winsize
                            "    call Decho("exe ".(g:netrw_alto? "top " : "bot ")."vert ".winsz."wincmd s")
                                exe (g:netrw_alto? "top " : "bot ")."vert ".winsz."wincmd s"
                               else
                                let winsz= (g:netrw_winsize > 0)? (g:netrw_winsize*winwidth(0))/100 : -g:netrw_winsize
                            "    call Decho("exe ".(g:netrw_alto? "bel " : "abo ").winsz."wincmd s")
                                exe (g:netrw_alto? "bel " : "abo ").winsz."wincmd s"
                               endif
                               let didsplit  = 1
                            
                              else
                               keepj call s:SaveBufVars()
                            "   call Decho("wincmd p")
                               wincmd p
                               keepj call s:RestoreBufVars()
                               " if the previous window's buffer has been changed (is modified),
                               " and it doesn't appear in any other extant window, then ask the
                               " user if s/he wants to abandon modifications therein.
                               let bnr    = winbufnr(0)
                               let bnrcnt = 0
                               if &mod
                            "    call Decho("detected: prev window's buffer has been modified: bnr=".bnr." winnr#".winnr())
                                let eikeep= &ei
                                set ei=all
                                windo if winbufnr(0) == bnr | let bnrcnt=bnrcnt+1 | endif
                                exe bnr."wincmd p"
                                let &ei= eikeep
                            "    call Decho("bnr=".bnr." bnrcnt=".bnrcnt." buftype=".&bt." winnr#".winnr())
                                if bnrcnt == 1
                                 let bufname = bufname(winbufnr(winnr()))
                                 let choice  = confirm("Save modified file<".bufname.">?","&Yes\n&No\n&Cancel")
                            "     call Decho("bufname<".bufname."> choice=".choice." winnr#".winnr())
                            
                                 if choice == 1
                                  " Yes -- write file & then browse
                                  let v:errmsg= ""
                                  sil w
                                  if v:errmsg != ""
                                   call netrw#ErrorMsg(s:ERROR,"unable to write <".bufname.">!",30)
                                   if didsplit
                                   	q
                                   else
                                   	wincmd p
                                   endif
                                   let @@= ykeep
                            "       call Dret("NetrwPrevWinOpen ".choice." : unable to write <".bufname.">")
                                   return choice
                                  endif
                            
                                 elseif choice == 2
                                  " No -- don't worry about changed file, just browse anyway
                            "      call Decho("(NetrwPrevWinOpen) setl nomod")
                                  setl nomod
                            "      call Decho("(NetrwPrevWinOpen) ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
                                  keepj call netrw#ErrorMsg(s:WARNING,bufname." changes to ".bufname." abandoned",31)
                                  wincmd p
                            
                                 else
                                  " Cancel -- don't do this
                                  if didsplit
                                   q
                                  else
                                   wincmd p
                                  endif
                                  let @@= ykeep
                            "      call Dret("NetrwPrevWinOpen ".choice." : cancelled")
                                  return choice
                                 endif
                                endif
                               endif
                              endif
                            
                              " restore b:netrw_curdir (window split/enew may have lost it)
                              let b:netrw_curdir= curdir
                              if a:islocal < 2
                               if a:islocal
                                call netrw#LocalBrowseCheck(s:NetrwBrowseChgDir(a:islocal,curword))
                               else
                                call s:NetrwBrowse(a:islocal,s:NetrwBrowseChgDir(a:islocal,curword))
                               endif
                              endif
                              let @@= ykeep
                            "  call Dret("NetrwPrevWinOpen ".choice)
                              return choice
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwUpload: load fname to tgt (used by NetrwMarkFileCopy()) {{{2
                            "                Always assumed to be local -> remote
                            "                call s:NetrwUpload(filename, target)
                            "                call s:NetrwUpload(filename, target, fromdirectory)
    1              0.000006 fun! s:NetrwUpload(fname,tgt,...)
                            "  call Dfunc("s:NetrwUpload(fname<".((type(a:fname) == 1)? a:fname : string(a:fname))."> tgt<".a:tgt.">) a:0=".a:0)
                            
                              if a:tgt =~ '^\a\+://'
                               let tgtdir= substitute(a:tgt,'^\a\+://[^/]\+/\(.\{-}\)$','\1','')
                              else
                               let tgtdir= substitute(a:tgt,'^\(.*\)/[^/]*$','\1','')
                              endif
                            "  call Decho("tgtdir<".tgtdir.">")
                            
                              if a:0 > 0
                               let fromdir= a:1
                              else
                               let fromdir= getcwd()
                              endif
                            "  call Decho("fromdir<".fromdir.">")
                            
                              if type(a:fname) == 1
                               " handle uploading a single file using NetWrite
                            "   call Decho("handle uploading a single file via NetWrite")
                               1split
                            "   call Decho("exe e ".fnameescape(a:fname))
                               exe "e ".fnameescape(a:fname)
                            "   call Decho("now locally editing<".expand("%").">, has ".line("$")." lines")
                               if a:tgt =~ '/$'
                                let wfname= substitute(a:fname,'^.*/','','')
                            "    call Decho("exe w! ".fnameescape(wfname))
                                exe "w! ".fnameescape(a:tgt.wfname)
                               else
                            "    call Decho("writing local->remote: exe w ".fnameescape(a:tgt))
                                exe "w ".fnameescape(a:tgt)
                            "    call Decho("done writing local->remote")
                               endif
                               q!
                            
                              elseif type(a:fname) == 3
                               " handle uploading a list of files via scp
                            "   call Decho("handle uploading a list of files via scp")
                               let curdir= getcwd()
                               if a:tgt =~ '^scp:'
                                exe "keepjumps sil lcd ".fnameescape(fromdir)
                                let filelist= deepcopy(s:netrwmarkfilelist_{bufnr('%')})
                                let args    = join(map(filelist,"shellescape(v:val, 1)"))
                                if exists("g:netrw_port") && g:netrw_port != ""
                                 let useport= " ".g:netrw_scpport." ".g:netrw_port
                                else
                                 let useport= ""
                                endif
                                let machine = substitute(a:tgt,'^scp://\([^/:]\+\).*$','\1','')
                                let tgt     = substitute(a:tgt,'^scp://[^/]\+/\(.*\)$','\1','')
                            "    call Decho("exe ".s:netrw_silentxfer."!".g:netrw_scp_cmd.shellescape(useport,1)." ".args." ".shellescape(machine.":".tgt,1))
                                exe s:netrw_silentxfer."!".g:netrw_scp_cmd.shellescape(useport,1)." ".args." ".shellescape(machine.":".tgt,1)
                                exe "keepjumps sil lcd ".fnameescape(curdir)
                            
                               elseif a:tgt =~ '^ftp:'
                                call s:NetrwMethod(a:tgt)
                            
                                if b:netrw_method == 2
                                 " handle uploading a list of files via ftp+.netrc
                                 let netrw_fname = b:netrw_fname
                                 sil keepj new
                            "     call Decho("filter input window#".winnr())
                            
                                 keepj put =g:netrw_ftpmode
                            "     call Decho("filter input: ".getline('$'))
                            
                                 if exists("g:netrw_ftpextracmd")
                                  keepj put =g:netrw_ftpextracmd
                            "      call Decho("filter input: ".getline('$'))
                                 endif
                            
                                 keepj call setline(line("$")+1,'lcd "'.fromdir.'"')
                            "     call Decho("filter input: ".getline('$'))
                            
                                 if tgtdir == ""
                                  let tgtdir= '/'
                                 endif
                                 keepj call setline(line("$")+1,'cd "'.tgtdir.'"')
                            "     call Decho("filter input: ".getline('$'))
                            
                                 for fname in a:fname
                                  keepj call setline(line("$")+1,'put "'.fname.'"')
                            "      call Decho("filter input: ".getline('$'))
                                 endfor
                            
                                 if exists("g:netrw_port") && g:netrw_port != ""
                            "      call Decho("executing: ".s:netrw_silentxfer."%!".s:netrw_ftp_cmd." -i ".shellescape(g:netrw_machine,1)." ".shellescape(g:netrw_port,1))
                                  exe s:netrw_silentxfer."%!".s:netrw_ftp_cmd." -i ".shellescape(g:netrw_machine,1)." ".shellescape(g:netrw_port,1)
                                 else
                            "      call Decho("filter input window#".winnr())
                            "      call Decho("executing: ".s:netrw_silentxfer."%!".s:netrw_ftp_cmd." -i ".shellescape(g:netrw_machine,1))
                                  exe s:netrw_silentxfer."%!".s:netrw_ftp_cmd." -i ".shellescape(g:netrw_machine,1)
                                 endif
                                 " If the result of the ftp operation isn't blank, show an error message (tnx to Doug Claar)
                                 sil keepj g/Local directory now/d
                                 call histdel("/",-1)
                                 if getline(1) !~ "^$" && !exists("g:netrw_quiet") && getline(1) !~ '^Trying '
                                  call netrw#ErrorMsg(s:ERROR,getline(1),14)
                                 else
                                  bw!|q
                                 endif
                            
                                elseif b:netrw_method == 3
                                 " upload with ftp + machine, id, passwd, and fname (ie. no .netrc)
                                 let netrw_fname= b:netrw_fname
                                 keepj call s:SaveBufVars()|sil keepj new|keepj call s:RestoreBufVars()
                                 let tmpbufnr= bufnr("%")
                                 setl ff=unix
                            
                                 if exists("g:netrw_port") && g:netrw_port != ""
                                  keepj put ='open '.g:netrw_machine.' '.g:netrw_port
                            "      call Decho("filter input: ".getline('$'))
                                 else
                                  keepj put ='open '.g:netrw_machine
                            "      call Decho("filter input: ".getline('$'))
                                 endif
                            
                                 if exists("g:netrw_uid") && g:netrw_uid != ""
                                  if exists("g:netrw_ftp") && g:netrw_ftp == 1
                                   keepj put =g:netrw_uid
                            "       call Decho("filter input: ".getline('$'))
                                   if exists("s:netrw_passwd")
                                    keepj call setline(line("$")+1,'"'.s:netrw_passwd.'"')
                                   endif
                            "       call Decho("filter input: ".getline('$'))
                                  elseif exists("s:netrw_passwd")
                                   keepj put ='user \"'.g:netrw_uid.'\" \"'.s:netrw_passwd.'\"'
                            "       call Decho("filter input: ".getline('$'))
                                  endif
                                 endif
                            
                                 keepj call setline(line("$")+1,'lcd "'.fromdir.'"')
                            "     call Decho("filter input: ".getline('$'))
                            
                                 if exists("b:netrw_fname") && b:netrw_fname != ""
                                  keepj call setline(line("$")+1,'cd "'.b:netrw_fname.'"')
                            "      call Decho("filter input: ".getline('$'))
                                 endif
                            
                                 if exists("g:netrw_ftpextracmd")
                                  keepj put =g:netrw_ftpextracmd
                            "      call Decho("filter input: ".getline('$'))
                                 endif
                            
                                 for fname in a:fname
                                  keepj call setline(line("$")+1,'put "'.fname.'"')
                            "      call Decho("filter input: ".getline('$'))
                                 endfor
                            
                                 " perform ftp:
                                 " -i       : turns off interactive prompting from ftp
                                 " -n  unix : DON'T use <.netrc>, even though it exists
                                 " -n  win32: quit being obnoxious about password
                                 keepj norm! 1Gdd
                            "     call Decho("executing: ".s:netrw_silentxfer."%!".s:netrw_ftp_cmd." ".g:netrw_ftp_options)
                                 exe s:netrw_silentxfer."%!".s:netrw_ftp_cmd." ".g:netrw_ftp_options
                                 " If the result of the ftp operation isn't blank, show an error message (tnx to Doug Claar)
                                 sil keepj g/Local directory now/d
                                 call histdel("/",-1)
                                 if getline(1) !~ "^$" && !exists("g:netrw_quiet") && getline(1) !~ '^Trying '
                                  let debugkeep= &debug
                                  setl debug=msg
                                  call netrw#ErrorMsg(s:ERROR,getline(1),15)
                                  let &debug = debugkeep
                                  let mod    = 1
                                 else
                                  bw!|q
                                 endif
                                elseif !exists("b:netrw_method") || b:netrw_method < 0
                            "     call Dfunc("netrw#NetrwUpload : unsupported method")
                                 return
                                endif
                               else
                                call netrw#ErrorMsg(s:ERROR,"can't obtain files with protocol from<".a:tgt.">",63)
                               endif
                              endif
                            
                            "  call Dret("s:NetrwUpload")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwPreview: {{{2
    1              0.000005 fun! s:NetrwPreview(path) range
                            "  call Dfunc("NetrwPreview(path<".a:path.">)")
                              let ykeep= @@
                              keepj call s:NetrwOptionSave("s:")
                              keepj call s:NetrwSafeOptions()
                              if has("quickfix")
                               if !isdirectory(a:path)
                                if g:netrw_preview && !g:netrw_alto
                                 let pvhkeep = &pvh
                                 let winsz   = (g:netrw_winsize > 0)? (g:netrw_winsize*winwidth(0))/100 : -g:netrw_winsize
                                 let &pvh    = winwidth(0) - winsz
                                endif
                                exe (g:netrw_alto? "top " : "bot ").(g:netrw_preview? "vert " : "")."pedit ".fnameescape(a:path)
                                if exists("pvhkeep")
                                 let &pvh= pvhkeep
                                endif
                               elseif !exists("g:netrw_quiet")
                                keepj call netrw#ErrorMsg(s:WARNING,"sorry, cannot preview a directory such as <".a:path.">",38)
                               endif
                              elseif !exists("g:netrw_quiet")
                               keepj call netrw#ErrorMsg(s:WARNING,"sorry, to preview your vim needs the quickfix feature compiled in",39)
                              endif
                              keepj call s:NetrwOptionRestore("s:")
                              let @@= ykeep
                            "  call Dret("NetrwPreview")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwRefresh: {{{2
    1              0.000004 fun! s:NetrwRefresh(islocal,dirname)
                            "  call Dfunc("NetrwRefresh(islocal<".a:islocal.">,dirname=".a:dirname.") hide=".g:netrw_hide." sortdir=".g:netrw_sort_direction)
                              " at the current time (Mar 19, 2007) all calls to NetrwRefresh() call NetrwBrowseChgDir() first.
                              " (defunct) NetrwBrowseChgDir() may clear the display; hence a NetrwSavePosn() may not work if its placed here.
                              " (defunct) Also, NetrwBrowseChgDir() now does a NetrwSavePosn() itself.
                              setl ma noro
                            "  call Decho("setl ma noro")
                            "  call Decho("clear buffer<".expand("%")."> with :%d")
                              let ykeep      = @@
                              let screenposn = netrw#NetrwSavePosn()
                            "  call Decho("clearing buffer prior to refresh")
                              sil! keepj %d
                              if a:islocal
                               keepj call netrw#LocalBrowseCheck(a:dirname)
                              else
                               keepj call s:NetrwBrowse(a:islocal,a:dirname)
                              endif
                              keepj call netrw#NetrwRestorePosn(screenposn)
                            
                              " restore file marks
                              if exists("s:netrwmarkfilemtch_{bufnr('%')}") && s:netrwmarkfilemtch_{bufnr("%")} != ""
                            "   call Decho("exe 2match netrwMarkFile /".s:netrwmarkfilemtch_{bufnr("%")}."/")
                               exe "2match netrwMarkFile /".s:netrwmarkfilemtch_{bufnr("%")}."/"
                              else
                            "   call Decho("2match none")
                               2match none
                              endif
                            
                            "  restore
                              let @@= ykeep
                            "  call Dret("NetrwRefresh")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwRefreshDir: refreshes a directory by name {{{2
                            "                    Called by NetrwMarkFileCopy()
                            "                    Interfaces to s:NetrwRefresh() and s:LocalBrowseShellCmdRefresh()
    1              0.000011 fun! s:NetrwRefreshDir(islocal,dirname)
                            "  call Dfunc("s:NetrwRefreshDir(islocal=".a:islocal." dirname<".a:dirname.">) g:netrw_fastbrowse=".g:netrw_fastbrowse)
                              if g:netrw_fastbrowse == 0
                               " slowest mode (keep buffers refreshed, local or remote)
                            "   call Decho("slowest mode: keep buffers refreshed, local or remote")
                               let tgtwin= bufwinnr(a:dirname)
                            "   call Decho("tgtwin= bufwinnr(".a:dirname.")=".tgtwin)
                            
                               if tgtwin > 0
                                " tgtwin is being displayed, so refresh it
                                let curwin= winnr()
                            "    call Decho("refresh tgtwin#".tgtwin." (curwin#".curwin.")")
                                exe tgtwin."wincmd w"
                                keepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./')) 
                                exe curwin."wincmd w"
                            
                               elseif bufnr(a:dirname) > 0
                                let bn= bufnr(a:dirname)
                            "    call Decho("bd bufnr(".a:dirname.")=".bn)
                                exe "sil bd ".bn
                               endif
                            
                              elseif g:netrw_fastbrowse <= 1
                            "   call Decho("medium-speed mode: refresh local buffers only")
                               keepj call s:LocalBrowseShellCmdRefresh()
                              endif
                            "  call Dret("s:NetrwRefreshDir")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwSetSort: sets up the sort based on the g:netrw_sort_sequence {{{2
                            "          What this function does is to compute a priority for the patterns
                            "          in the g:netrw_sort_sequence.  It applies a substitute to any
                            "          "files" that satisfy each pattern, putting the priority / in
                            "          front.  An "*" pattern handles the default priority.
    1              0.000005 fun! s:NetrwSetSort()
                            "  call Dfunc("SetSort() bannercnt=".w:netrw_bannercnt)
                              let ykeep= @@
                              if w:netrw_liststyle == s:LONGLIST
                               let seqlist  = substitute(g:netrw_sort_sequence,'\$','\\%(\t\\|\$\\)','ge')
                              else
                               let seqlist  = g:netrw_sort_sequence
                              endif
                              " sanity check -- insure that * appears somewhere
                              if seqlist == ""
                               let seqlist= '*'
                              elseif seqlist !~ '\*'
                               let seqlist= seqlist.',*'
                              endif
                              let priority = 1
                              while seqlist != ""
                               if seqlist =~ ','
                                let seq     = substitute(seqlist,',.*$','','e')
                                let seqlist = substitute(seqlist,'^.\{-},\(.*\)$','\1','e')
                               else
                                let seq     = seqlist
                                let seqlist = ""
                               endif
                               if priority < 10
                                let spriority= "00".priority.g:netrw_sepchr
                               elseif priority < 100
                                let spriority= "0".priority.g:netrw_sepchr
                               else
                                let spriority= priority.g:netrw_sepchr
                               endif
                            "   call Decho("priority=".priority." spriority<".spriority."> seq<".seq."> seqlist<".seqlist.">")
                            
                               " sanity check
                               if w:netrw_bannercnt > line("$")
                                " apparently no files were left after a Hiding pattern was used
                            "    call Dret("SetSort : no files left after hiding")
                                return
                               endif
                               if seq == '*'
                                let starpriority= spriority
                               else
                                exe 'sil keepj '.w:netrw_bannercnt.',$g/'.seq.'/s/^/'.spriority.'/'
                                call histdel("/",-1)
                                " sometimes multiple sorting patterns will match the same file or directory.
                                " The following substitute is intended to remove the excess matches.
                                exe 'sil keepj '.w:netrw_bannercnt.',$g/^\d\{3}'.g:netrw_sepchr.'\d\{3}\//s/^\d\{3}'.g:netrw_sepchr.'\(\d\{3}\/\).\@=/\1/e'
                                keepj call histdel("/",-1)
                               endif
                               let priority = priority + 1
                              endwhile
                              if exists("starpriority")
                               exe 'sil keepj '.w:netrw_bannercnt.',$v/^\d\{3}'.g:netrw_sepchr.'/s/^/'.starpriority.'/'
                               keepj call histdel("/",-1)
                              endif
                            
                              " Following line associated with priority -- items that satisfy a priority
                              " pattern get prefixed by ###/ which permits easy sorting by priority.
                              " Sometimes files can satisfy multiple priority patterns -- only the latest
                              " priority pattern needs to be retained.  So, at this point, these excess
                              " priority prefixes need to be removed, but not directories that happen to
                              " be just digits themselves.
                              exe 'sil keepj '.w:netrw_bannercnt.',$s/^\(\d\{3}'.g:netrw_sepchr.'\)\%(\d\{3}'.g:netrw_sepchr.'\)\+\ze./\1/e'
                              keepj call histdel("/",-1)
                              let @@= ykeep
                            
                            "  call Dret("SetSort")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwSetTgt: sets the target to the specified choice index {{{2
                            "    Implements [count]Tb  (bookhist<b>)
                            "               [count]Th  (bookhist<h>)
                            "               See :help netrw-qb for how to make the choice.
    1              0.000004 fun! s:NetrwSetTgt(bookhist,choice)
                            "  call Dfunc("s:NetrwSetTgt(bookhist<".a:bookhist."> choice#".a:choice.")")
                            
                              if     a:bookhist == 'b'
                               " supports choosing a bookmark as a target using a qb-generated list
                               let choice= a:choice - 1
                               if exists("g:netrw_bookmarklist[".choice."]")
                                call netrw#NetrwMakeTgt(g:netrw_bookmarklist[choice])
                               else
                                echomsg "Sorry, bookmark#".a:choice." doesn't exist!"
                               endif
                            
                              elseif a:bookhist == 'h'
                               " supports choosing a history stack entry as a target using a qb-generated list
                               let choice= (a:choice % g:netrw_dirhistmax) + 1
                               if exists("g:netrw_dirhist_".choice)
                                let histentry = g:netrw_dirhist_{choice}
                                call netrw#NetrwMakeTgt(histentry)
                               else
                                echomsg "Sorry, history#".a:choice." not available!"
                               endif
                              endif
                            
                            "  call Dret("s:NetrwSetTgt")
                            endfun
                            
                            " =====================================================================
                            " s:NetrwSortStyle: change sorting style (name - time - size) and refresh display {{{2
    1              0.000004 fun! s:NetrwSortStyle(islocal)
                            "  call Dfunc("s:NetrwSortStyle(islocal=".a:islocal.") netrw_sort_by<".g:netrw_sort_by.">")
                              keepj call s:NetrwSaveWordPosn()
                              let svpos= netrw#NetrwSavePosn()
                            
                              let g:netrw_sort_by= (g:netrw_sort_by =~ 'n')? 'time' : (g:netrw_sort_by =~ 't')? 'size' : 'name'
                              keepj norm! 0
                              keepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
                              keepj call netrw#NetrwRestorePosn(svpos)
                            
                            "  call Dret("s:NetrwSortStyle : netrw_sort_by<".g:netrw_sort_by.">")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwSplit: mode {{{2
                            "           =0 : net   and o
                            "           =1 : net   and t
                            "           =2 : net   and v
                            "           =3 : local and o
                            "           =4 : local and t
                            "           =5 : local and v
    1              0.000003 fun! s:NetrwSplit(mode)
                            "  call Dfunc("s:NetrwSplit(mode=".a:mode.") alto=".g:netrw_alto." altv=".g:netrw_altv)
                            
                              let ykeep= @@
                              call s:SaveWinVars()
                            
                              if a:mode == 0
                               " remote and o
                               let winsz= (g:netrw_winsize > 0)? (g:netrw_winsize*winheight(0))/100 : -g:netrw_winsize
                            "   call Decho("exe ".(g:netrw_alto? "bel " : "abo ").winsz."wincmd s")
                               exe (g:netrw_alto? "bel " : "abo ").winsz."wincmd s"
                               let s:didsplit= 1
                               keepj call s:RestoreWinVars()
                               keepj call s:NetrwBrowse(0,s:NetrwBrowseChgDir(0,s:NetrwGetWord()))
                               unlet s:didsplit
                            
                              elseif a:mode == 1
                               " remote and t
                               let newdir  = s:NetrwBrowseChgDir(0,s:NetrwGetWord())
                            "   call Decho("tabnew")
                               tabnew
                               let s:didsplit= 1
                               keepj call s:RestoreWinVars()
                               keepj call s:NetrwBrowse(0,newdir)
                               unlet s:didsplit
                            
                              elseif a:mode == 2
                               " remote and v
                               let winsz= (g:netrw_winsize > 0)? (g:netrw_winsize*winwidth(0))/100 : -g:netrw_winsize
                            "   call Decho("exe ".(g:netrw_altv? "rightb " : "lefta ").winsz."wincmd v")
                               exe (g:netrw_altv? "rightb " : "lefta ").winsz."wincmd v"
                               let s:didsplit= 1
                               keepj call s:RestoreWinVars()
                               keepj call s:NetrwBrowse(0,s:NetrwBrowseChgDir(0,s:NetrwGetWord()))
                               unlet s:didsplit
                            
                              elseif a:mode == 3
                               " local and o
                               let winsz= (g:netrw_winsize > 0)? (g:netrw_winsize*winheight(0))/100 : -g:netrw_winsize
                            "   call Decho("exe ".(g:netrw_alto? "bel " : "abo ").winsz."wincmd s")
                               exe (g:netrw_alto? "bel " : "abo ").winsz."wincmd s"
                               let s:didsplit= 1
                               keepj call s:RestoreWinVars()
                               keepj call netrw#LocalBrowseCheck(s:NetrwBrowseChgDir(1,s:NetrwGetWord()))
                               unlet s:didsplit
                            
                              elseif a:mode == 4
                               " local and t
                               let cursorword  = s:NetrwGetWord()
                               let netrw_curdir= s:NetrwTreeDir()
                            "   call Decho("tabnew")
                               tabnew
                               let b:netrw_curdir= netrw_curdir
                               let s:didsplit= 1
                               keepj call s:RestoreWinVars()
                               keepj call netrw#LocalBrowseCheck(s:NetrwBrowseChgDir(1,cursorword))
                               unlet s:didsplit
                            
                              elseif a:mode == 5
                               " local and v
                               let winsz= (g:netrw_winsize > 0)? (g:netrw_winsize*winwidth(0))/100 : -g:netrw_winsize
                            "   call Decho("exe ".(g:netrw_altv? "rightb " : "lefta ").winsz."wincmd v")
                               exe (g:netrw_altv? "rightb " : "lefta ").winsz."wincmd v"
                               let s:didsplit= 1
                               keepj call s:RestoreWinVars()
                               keepj call netrw#LocalBrowseCheck(s:NetrwBrowseChgDir(1,s:NetrwGetWord()))
                               unlet s:didsplit
                            
                              else
                               keepj call netrw#ErrorMsg(s:ERROR,"(NetrwSplit) unsupported mode=".a:mode,45)
                              endif
                            
                              let @@= ykeep
                            "  call Dret("s:NetrwSplit")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwTgtMenu: {{{2
    1              0.000005 fun! s:NetrwTgtMenu()
                              if !exists("s:netrw_menucnt")
                               return
                              endif
                            "  call Dfunc("s:NetrwTgtMenu()")
                            
                              " the following test assures that gvim is running, has menus available, and has menus enabled.
                              if has("gui") && has("menu") && has("gui_running") && &go =~# 'm' && g:netrw_menu
                               if exists("g:NetrwTopLvlMenu")
                            "    call Decho("removing ".g:NetrwTopLvlMenu."Bookmarks menu item(s)")
                                exe 'sil! unmenu '.g:NetrwTopLvlMenu.'Targets'
                               endif
                               if !exists("s:netrw_initbookhist")
                                call s:NetrwBookHistRead()
                               endif
                            
                               " target bookmarked places
                               if exists("g:netrw_bookmarklist") && g:netrw_bookmarklist != [] && g:netrw_dirhistmax > 0
                            "    call Decho("installing bookmarks as easy targets")
                                let cnt= 1
                                for bmd in g:netrw_bookmarklist
                                 let ebmd= escape(bmd,g:netrw_menu_escape)
                                 " show bookmarks for goto menu
                            "     call Decho("menu: Targets: ".bmd)
                                 exe 'sil! menu <silent> '.g:NetrwMenuPriority.".19.1.".cnt." ".g:NetrwTopLvlMenu.'Targets.'.ebmd."	:call netrw#NetrwMakeTgt('".bmd."')\<cr>"
                                 let cnt= cnt + 1
                                endfor
                               endif
                            
                               " target directory browsing history
                               if exists("g:netrw_dirhistmax") && g:netrw_dirhistmax > 0
                            "    call Decho("installing history as easy targets (histmax=".g:netrw_dirhistmax.")")
                                let histcnt = 1
                                while histcnt <= g:netrw_dirhistmax
                                 let priority = g:netrw_dirhist_cnt + histcnt
                                 if exists("g:netrw_dirhist_{histcnt}")
                                  let histentry  = g:netrw_dirhist_{histcnt}
                                  let ehistentry = escape(histentry,g:netrw_menu_escape)
                            "      call Decho("menu: Targets: ".histentry)
                                  exe 'sil! menu <silent> '.g:NetrwMenuPriority.".19.2.".priority." ".g:NetrwTopLvlMenu.'Targets.'.ehistentry."	:call netrw#NetrwMakeTgt('".histentry."')\<cr>"
                                 endif
                                 let histcnt = histcnt + 1
                                endwhile
                               endif
                              endif
                            "  call Dret("s:NetrwTgtMenu")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwTreeDir: determine tree directory given current cursor position {{{2
                            " (full path directory with trailing slash returned)
    1              0.000004 fun! s:NetrwTreeDir()
                            "  call Dfunc("NetrwTreeDir() curline#".line(".")."<".getline('.')."> b:netrw_curdir<".b:netrw_curdir."> tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%").">")
                            
                              let treedir= b:netrw_curdir
                            "  call Decho("(NetrwTreeDir) set initial treedir<".treedir.">")
                              let s:treecurpos= netrw#NetrwSavePosn()
                            
                              if w:netrw_liststyle == s:TREELIST
                            "   call Decho("(NetrwTreeDir) w:netrw_liststyle is TREELIST:")
                            "   call Decho("(NetrwTreeDir) line#".line(".")." getline(.)<".getline('.')."> treecurpos<".string(s:treecurpos).">")
                            
                               " extract tree directory if on a line specifying a subdirectory (ie. ends with "/")
                               if getline('.') =~ '/$'
                                let treedir= substitute(getline('.'),'^\%(| \)*\([^|].\{-}\)$','\1','e')
                               else
                                let treedir= ""
                               endif
                            "   call Decho("(NetrwTreeDir) treedir<".treedir.">")
                            
                               " detect user attempting to close treeroot
                               if getline('.') !~ '|' && getline('.') != '..'
                            "    call Decho("user attempted to close treeroot")
                                " now force a refresh
                            "    call Decho("(NetrwTreeDir) clear buffer<".expand("%")."> with :%d")
                                sil! keepj %d
                            "    call Dret("NetrwTreeDir <".treedir."> : (side effect) s:treecurpos<".string(s:treecurpos).">")
                                return b:netrw_curdir
                               endif
                            
                               " elide all non-depth information
                               let depth = substitute(getline('.'),'^\(\%(| \)*\)[^|].\{-}$','\1','e')
                            "   call Decho("(NetrwTreeDir) depth<".depth."> 1st subst (non-depth info removed)")
                            
                               " elide first depth
                               let depth = substitute(depth,'^| ','','')
                            "   call Decho("(NetrwTreeDir) depth<".depth."> 2nd subst (first depth removed)")
                            
                               " construct treedir by searching backwards at correct depth
                            "   call Decho("(NetrwTreeDir) constructing treedir<".treedir."> depth<".depth.">")
                               while depth != "" && search('^'.depth.'[^|].\{-}/$','bW')
                                let dirname= substitute(getline('.'),'^\(| \)*','','e')
                                let treedir= dirname.treedir
                                let depth  = substitute(depth,'^| ','','')
                            "    call Decho("(NetrwTreeDir) constructing treedir<".treedir.">: dirname<".dirname."> while depth<".depth.">")
                               endwhile
                               if w:netrw_treetop =~ '/$'
                                let treedir= w:netrw_treetop.treedir
                               else
                                let treedir= w:netrw_treetop.'/'.treedir
                               endif
                            "   call Decho("(NetrwTreeDir) bufnr(.)=".bufnr("%")." line($)=".line("$")." line(.)=".line("."))
                              endif
                              let treedir= substitute(treedir,'//$','/','')
                            
                            "  call Dret("NetrwTreeDir <".treedir."> : (side effect) s:treecurpos<".string(s:treecurpos).">")
                              return treedir
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwTreeDisplay: recursive tree display {{{2
    1              0.000005 fun! s:NetrwTreeDisplay(dir,depth)
                            "  call Dfunc("NetrwTreeDisplay(dir<".a:dir."> depth<".a:depth.">)")
                            
                              " insure that there are no folds
                              setl nofen
                            
                              " install ../ and shortdir
                              if a:depth == ""
                               call setline(line("$")+1,'../')
                            "   call Decho("setline#".line("$")." ../ (depth is zero)")
                              endif
                              if a:dir =~ '^\a\+://'
                               if a:dir == w:netrw_treetop
                                let shortdir= a:dir
                               else
                                let shortdir= substitute(a:dir,'^.*/\([^/]\+\)/$','\1/','e')
                               endif
                               call setline(line("$")+1,a:depth.shortdir)
                              else
                               let shortdir= substitute(a:dir,'^.*/','','e')
                               call setline(line("$")+1,a:depth.shortdir.'/')
                              endif
                            "  call Decho("setline#".line("$")." shortdir<".a:depth.shortdir.">")
                            
                              " append a / to dir if its missing one
                              let dir= a:dir
                              if dir !~ '/$'
                               let dir= dir.'/'
                              endif
                            
                              " display subtrees (if any)
                              let depth= "| ".a:depth
                            
                            "  call Decho("display subtrees with depth<".depth."> and current leaves")
                              for entry in w:netrw_treedict[a:dir]
                               let direntry= substitute(dir.entry,'/$','','e')
                            "   call Decho("dir<".dir."> entry<".entry."> direntry<".direntry.">")
                               if entry =~ '/$' && has_key(w:netrw_treedict,direntry)
                            "    call Decho("<".direntry."> is a key in treedict - display subtree for it")
                                keepj call s:NetrwTreeDisplay(direntry,depth)
                               elseif entry =~ '/$' && has_key(w:netrw_treedict,direntry.'/')
                            "    call Decho("<".direntry."/> is a key in treedict - display subtree for it")
                                keepj call s:NetrwTreeDisplay(direntry.'/',depth)
                               else
                            "    call Decho("<".entry."> is not a key in treedict (no subtree)")
                                sil! keepj call setline(line("$")+1,depth.entry)
                               endif
                              endfor
                            "  call Dret("NetrwTreeDisplay")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwTreeListing: displays tree listing from treetop on down, using NetrwTreeDisplay() {{{2
    1              0.000004 fun! s:NetrwTreeListing(dirname)
                              if w:netrw_liststyle == s:TREELIST
                            "   call Dfunc("NetrwTreeListing() bufname<".expand("%").">")
                            "   call Decho("curdir<".a:dirname.">")
                            "   call Decho("win#".winnr().": w:netrw_treetop ".(exists("w:netrw_treetop")? "exists" : "doesn't exit")." w:netrw_treedict ".(exists("w:netrw_treedict")? "exists" : "doesn't exit"))
                            
                               " update the treetop
                            "   call Decho("update the treetop")
                               if !exists("w:netrw_treetop")
                                let w:netrw_treetop= a:dirname
                            "    call Decho("w:netrw_treetop<".w:netrw_treetop."> (reusing)")
                               elseif (w:netrw_treetop =~ ('^'.a:dirname) && s:Strlen(a:dirname) < s:Strlen(w:netrw_treetop)) || a:dirname !~ ('^'.w:netrw_treetop)
                                let w:netrw_treetop= a:dirname
                            "    call Decho("w:netrw_treetop<".w:netrw_treetop."> (went up)")
                               endif
                            
                               " insure that we have at least an empty treedict
                               if !exists("w:netrw_treedict")
                                let w:netrw_treedict= {}
                               endif
                            
                               " update the directory listing for the current directory
                            "   call Decho("updating dictionary with ".a:dirname.":[..directory listing..]")
                            "   call Decho("bannercnt=".w:netrw_bannercnt." line($)=".line("$"))
                               exe "sil! keepj ".w:netrw_bannercnt.',$g@^\.\.\=/$@d'
                               let w:netrw_treedict[a:dirname]= getline(w:netrw_bannercnt,line("$"))
                            "   call Decho("w:treedict[".a:dirname."]= ".string(w:netrw_treedict[a:dirname]))
                               exe "sil! keepj ".w:netrw_bannercnt.",$d"
                            
                               " if past banner, record word
                               if exists("w:netrw_bannercnt") && line(".") > w:netrw_bannercnt
                                let fname= expand("<cword>")
                               else
                                let fname= ""
                               endif
                            "   call Decho("fname<".fname.">")
                            
                               " display from treetop on down
                               keepj call s:NetrwTreeDisplay(w:netrw_treetop,"")
                            
                            "   call Dret("NetrwTreeListing : bufname<".expand("%").">")
                               return
                              endif
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwWideListing: {{{2
    1              0.000004 fun! s:NetrwWideListing()
                            
                              if w:netrw_liststyle == s:WIDELIST
                            "   call Dfunc("NetrwWideListing() w:netrw_liststyle=".w:netrw_liststyle.' fo='.&fo.' l:fo='.&l:fo)
                               " look for longest filename (cpf=characters per filename)
                               " cpf: characters per filename
                               " fpl: filenames per line
                               " fpc: filenames per column
                               setl ma noro
                            "   call Decho("setl ma noro")
                               let b:netrw_cpf= 0
                               if line("$") >= w:netrw_bannercnt
                                exe 'sil keepj '.w:netrw_bannercnt.',$g/^./if virtcol("$") > b:netrw_cpf|let b:netrw_cpf= virtcol("$")|endif'
                                keepj call histdel("/",-1)
                               else
                            "    call Dret("NetrwWideListing")
                                return
                               endif
                               let b:netrw_cpf= b:netrw_cpf + 2
                            "   call Decho("b:netrw_cpf=max_filename_length+2=".b:netrw_cpf)
                            
                               " determine qty files per line (fpl)
                               let w:netrw_fpl= winwidth(0)/b:netrw_cpf
                               if w:netrw_fpl <= 0
                                let w:netrw_fpl= 1
                               endif
                            "   call Decho("fpl= [winwidth=".winwidth(0)."]/[b:netrw_cpf=".b:netrw_cpf.']='.w:netrw_fpl)
                            
                               " make wide display
                               exe 'sil keepj '.w:netrw_bannercnt.',$s/^.*$/\=escape(printf("%-'.b:netrw_cpf.'s",submatch(0)),"\\")/'
                               keepj call histdel("/",-1)
                               let fpc         = (line("$") - w:netrw_bannercnt + w:netrw_fpl)/w:netrw_fpl
                               let newcolstart = w:netrw_bannercnt + fpc
                               let newcolend   = newcolstart + fpc - 1
                            "   call Decho("bannercnt=".w:netrw_bannercnt." fpl=".w:netrw_fpl." fpc=".fpc." newcol[".newcolstart.",".newcolend."]")
                               sil! let keepregstar = @*
                               while line("$") >= newcolstart
                                if newcolend > line("$") | let newcolend= line("$") | endif
                                let newcolqty= newcolend - newcolstart
                                exe newcolstart
                                if newcolqty == 0
                                 exe "sil! keepj norm! 0\<c-v>$hx".w:netrw_bannercnt."G$p"
                                else
                                 exe "sil! keepj norm! 0\<c-v>".newcolqty.'j$hx'.w:netrw_bannercnt.'G$p'
                                endif
                                exe "sil! keepj ".newcolstart.','.newcolend.'d'
                                exe 'sil! keepj '.w:netrw_bannercnt
                               endwhile
                               sil! let @*= keepregstar
                               exe "sil! keepj ".w:netrw_bannercnt.',$s/\s\+$//e'
                               keepj call histdel("/",-1)
                               exe "nmap <buffer> <silent> w	/^\\\\|\\s\\s\\zs\\S/\<cr>"
                               exe "nmap <buffer> <silent> b	?^\\\\|\\s\\s\\zs\\S?\<cr>"
                            "   call Decho("NetrwWideListing) setl noma nomod ro")
                               setl noma nomod ro
                            "   call Decho("(NetrwWideListing) ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
                            "   call Dret("NetrwWideListing")
                               return
                              else
                               if hasmapto("w","n")
                                sil! nunmap <buffer> w
                               endif
                               if hasmapto("b","n")
                                sil! nunmap <buffer> b
                               endif
                              endif
                            
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:PerformListing: {{{2
    1              0.000004 fun! s:PerformListing(islocal)
                            "  call Dfunc("s:PerformListing(islocal=".a:islocal.") bufnr(%)=".bufnr("%")."<".bufname("%").">")
                            
                              " set up syntax highlighting {{{3
                            "  call Decho("(PerformListing) set up syntax highlighting")
                              if has("syntax")
                               if !exists("g:syntax_on") || !g:syntax_on
                            "    call Decho("(PerformListing) but g:syntax_on".(exists("g:syntax_on")? "=".g:syntax_on : "<doesn't exist>"))
                                setl ft=
                               elseif &ft != "netrw"
                                setl ft=netrw
                               endif
                              endif
                            
                              keepj call s:NetrwSafeOptions()
                              set noro ma
                            "  call Decho("(PerformListing) setl noro ma bh=".&bh)
                            
                            "  if exists("g:netrw_silent") && g:netrw_silent == 0 && &ch >= 1	" Decho
                            "   call Decho("(PerformListing) (netrw) Processing your browsing request...")
                            "  endif								" Decho
                            
                            "  call Decho('w:netrw_liststyle='.(exists("w:netrw_liststyle")? w:netrw_liststyle : 'n/a'))
                              if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST && exists("w:netrw_treedict")
                               " force a refresh for tree listings
                            "   call Decho("(PerformListing) force refresh for treelisting: clear buffer<".expand("%")."> with :%d")
                               sil! keepj %d
                              endif
                            
                              " save current directory on directory history list
                              keepj call s:NetrwBookHistHandler(3,b:netrw_curdir)
                            
                              " Set up the banner {{{3
                              if g:netrw_banner
                            "   call Decho("(PerformListing) set up banner")
                               keepj call setline(1,'" ============================================================================')
                               keepj call setline(2,'" Netrw Directory Listing                                        (netrw '.g:loaded_netrw.')')
                               if exists("g:netrw_bannerbackslash") && g:netrw_bannerbackslash
                                keepj call setline(3,'"   '.substitute(b:netrw_curdir,'/','\\','g'))
                               else
                                keepj call setline(3,'"   '.b:netrw_curdir)
                               endif
                               let w:netrw_bannercnt= 3
                               keepj exe "sil! keepj ".w:netrw_bannercnt
                              else
                               keepj 1
                               let w:netrw_bannercnt= 1
                              endif
                            
                              let sortby= g:netrw_sort_by
                              if g:netrw_sort_direction =~ "^r"
                               let sortby= sortby." reversed"
                              endif
                            
                              " Sorted by... {{{3
                              if g:netrw_banner
                            "   call Decho("(PerformListing) handle specified sorting: g:netrw_sort_by<".g:netrw_sort_by.">")
                               if g:netrw_sort_by =~ "^n"
                            "   call Decho("(PerformListing) directories will be sorted by name")
                                " sorted by name
                                keepj put ='\"   Sorted by      '.sortby
                                keepj put ='\"   Sort sequence: '.g:netrw_sort_sequence
                                let w:netrw_bannercnt= w:netrw_bannercnt + 2
                               else
                            "   call Decho("(PerformListing) directories will be sorted by size or time")
                                " sorted by size or date
                                keepj put ='\"   Sorted by '.sortby
                                let w:netrw_bannercnt= w:netrw_bannercnt + 1
                               endif
                               exe "sil! keepj ".w:netrw_bannercnt
                              endif
                            
                              " show copy/move target, if any
                              if g:netrw_banner
                               if exists("s:netrwmftgt") && exists("s:netrwmftgt_islocal")
                            "    call Decho("(PerformListing) show copy/move target<".s:netrwmftgt.">")
                                keepj put =''
                                if s:netrwmftgt_islocal
                                 sil! keepj call setline(line("."),'"   Copy/Move Tgt: '.s:netrwmftgt.' (local)')
                                else
                                 sil! keepj call setline(line("."),'"   Copy/Move Tgt: '.s:netrwmftgt.' (remote)')
                                endif
                                let w:netrw_bannercnt= w:netrw_bannercnt + 1
                               else
                            "    call Decho("(PerformListing) s:netrwmftgt does not exist, don't make Copy/Move Tgt")
                               endif
                               exe "sil! keepj ".w:netrw_bannercnt
                              endif
                            
                              " Hiding...  -or-  Showing... {{{3
                              if g:netrw_banner
                            "   call Decho("(PerformListing) handle hiding/showing (g:netrw_hide=".g:netrw_list_hide." g:netrw_list_hide<".g:netrw_list_hide.">)")
                               if g:netrw_list_hide != "" && g:netrw_hide
                                if g:netrw_hide == 1
                                 keepj put ='\"   Hiding:        '.g:netrw_list_hide
                                else
                                 keepj put ='\"   Showing:       '.g:netrw_list_hide
                                endif
                                let w:netrw_bannercnt= w:netrw_bannercnt + 1
                               endif
                               exe "keepjumps ".w:netrw_bannercnt
                               keepj put ='\"   Quick Help: <F1>:help  -:go up dir  D:delete  R:rename  s:sort-by  x:exec'
                               keepj put ='\" ============================================================================'
                               let w:netrw_bannercnt= w:netrw_bannercnt + 2
                              endif
                            
                              " bannercnt should index the line just after the banner
                              if g:netrw_banner
                               let w:netrw_bannercnt= w:netrw_bannercnt + 1
                               exe "sil! keepj ".w:netrw_bannercnt
                            "   call Decho("(PerformListing) w:netrw_bannercnt=".w:netrw_bannercnt." (should index line just after banner) line($)=".line("$"))
                              endif
                            
                              " get list of files
                            "  call Decho("(PerformListing) Get list of files - islocal=".a:islocal)
                              if a:islocal
                               keepj call s:LocalListing()
                              else " remote
                               keepj call s:NetrwRemoteListing()
                              endif
                            
                              " manipulate the directory listing (hide, sort) {{{3
                              if !exists("w:netrw_bannercnt")
                               let w:netrw_bannercnt= 0
                              endif
                            "  call Decho("(PerformListing) g:netrw_banner=".g:netrw_banner." w:netrw_bannercnt=".w:netrw_bannercnt." (banner complete)")
                            
                              if !g:netrw_banner || line("$") >= w:netrw_bannercnt
                            "   call Decho("(PerformListing) manipulate directory listing (hide)")
                            "   call Decho("(PerformListing) g:netrw_hide=".g:netrw_hide." g:netrw_list_hide<".g:netrw_list_hide.">")
                               if g:netrw_hide && g:netrw_list_hide != ""
                                keepj call s:NetrwListHide()
                               endif
                               if !g:netrw_banner || line("$") >= w:netrw_bannercnt
                            "    call Decho("(PerformListing) manipulate directory listing (sort) : g:netrw_sort_by<".g:netrw_sort_by.">")
                            
                                if g:netrw_sort_by =~ "^n"
                                 " sort by name
                                 keepj call s:NetrwSetSort()
                            
                                 if !g:netrw_banner || w:netrw_bannercnt < line("$")
                            "      call Decho("(PerformListing) g:netrw_sort_direction=".g:netrw_sort_direction." (bannercnt=".w:netrw_bannercnt.")")
                                  if g:netrw_sort_direction =~ 'n'
                                   " normal direction sorting
                                   exe 'sil keepj '.w:netrw_bannercnt.',$sort'.' '.g:netrw_sort_options
                                  else
                                   " reverse direction sorting
                                   exe 'sil keepj '.w:netrw_bannercnt.',$sort!'.' '.g:netrw_sort_options
                                  endif
                                 endif
                                 " remove priority pattern prefix
                            "     call Decho("(PerformListing) remove priority pattern prefix")
                                 exe 'sil! keepj '.w:netrw_bannercnt.',$s/^\d\{3}'.g:netrw_sepchr.'//e'
                                 keepj call histdel("/",-1)
                            
                                elseif a:islocal
                                 if !g:netrw_banner || w:netrw_bannercnt < line("$")
                            "      call Decho("(PerformListing) g:netrw_sort_direction=".g:netrw_sort_direction)
                                  if g:netrw_sort_direction =~ 'n'
                            "       call Decho('exe sil keepjumps '.w:netrw_bannercnt.',$sort')
                                   exe 'sil! keepj '.w:netrw_bannercnt.',$sort'.' '.g:netrw_sort_options
                                  else
                            "       call Decho('exe sil keepjumps '.w:netrw_bannercnt.',$sort!')
                                   exe 'sil! keepj '.w:netrw_bannercnt.',$sort!'.' '.g:netrw_sort_options
                                  endif
                                 exe 'sil! keepj '.w:netrw_bannercnt.',$s/^\d\{-}\///e'
                                 keepj call histdel("/",-1)
                                 endif
                                endif
                            
                               elseif g:netrw_sort_direction =~ 'r'
                            "    call Decho('reverse the sorted listing')
                                if !g:netrw_banner || w:netrw_bannercnt < line('$')
                                 exe 'sil! keepj '.w:netrw_bannercnt.',$g/^/m '.w:netrw_bannercnt
                                 call histdel("/",-1)
                                endif
                               endif
                              endif
                            
                              " convert to wide/tree listing {{{3
                            "  call Decho("(PerformListing) modify display if wide/tree listing style")
                              keepj call s:NetrwWideListing()
                              keepj call s:NetrwTreeListing(b:netrw_curdir)
                            
                              if exists("w:netrw_bannercnt") && (line("$") > w:netrw_bannercnt || !g:netrw_banner)
                               " place cursor on the top-left corner of the file listing
                            "   call Decho("(PerformListing) place cursor on top-left corner of file listing")
                               exe 'sil! keepj '.w:netrw_bannercnt
                               sil! keepj norm! 0
                              endif
                            
                              " record previous current directory
                              let w:netrw_prvdir= b:netrw_curdir
                            "  call Decho("(PerformListing) record netrw_prvdir<".w:netrw_prvdir.">")
                            
                              " save certain window-oriented variables into buffer-oriented variables {{{3
                              keepj call s:SetBufWinVars()
                              keepj call s:NetrwOptionRestore("w:")
                            
                              " set display to netrw display settings
                            "  call Decho("(PerformListing) set display to netrw display settings (".g:netrw_bufsettings.")")
                              exe "setl ".g:netrw_bufsettings
                              if g:netrw_liststyle == s:LONGLIST
                            "   call Decho("(PerformListing) exe setl ts=".(g:netrw_maxfilenamelen+1))
                               exe "setl ts=".(g:netrw_maxfilenamelen+1)
                              endif
                              if exists("s:treecurpos")
                            
                               keepj call netrw#NetrwRestorePosn(s:treecurpos)
                               unlet s:treecurpos
                              endif
                            
                            "  call Dret("s:PerformListing : curpos<".string(getpos(".")).">")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:SetupNetrwStatusLine: {{{2
    1              0.000004 fun! s:SetupNetrwStatusLine(statline)
                            "  call Dfunc("SetupNetrwStatusLine(statline<".a:statline.">)")
                            
                              if !exists("s:netrw_setup_statline")
                               let s:netrw_setup_statline= 1
                            "   call Decho("do first-time status line setup")
                            
                               if !exists("s:netrw_users_stl")
                                let s:netrw_users_stl= &stl
                               endif
                               if !exists("s:netrw_users_ls")
                                let s:netrw_users_ls= &laststatus
                               endif
                            
                               " set up User9 highlighting as needed
                               let keepa= @a
                               redir @a
                               try
                                hi User9
                               catch /^Vim\%((\a\+)\)\=:E411/
                                if &bg == "dark"
                                 hi User9 ctermfg=yellow ctermbg=blue guifg=yellow guibg=blue
                                else
                                 hi User9 ctermbg=yellow ctermfg=blue guibg=yellow guifg=blue
                                endif
                               endtry
                               redir END
                               let @a= keepa
                              endif
                            
                              " set up status line (may use User9 highlighting)
                              " insure that windows have a statusline
                              " make sure statusline is displayed
                              let &stl=a:statline
                              setl laststatus=2
                            "  call Decho("stl=".&stl)
                              redraw
                            
                            "  call Dret("SetupNetrwStatusLine : stl=".&stl)
                            endfun
                            
                            " ---------------------------------------------------------------------
                            "  Remote Directory Browsing Support:    {{{1
                            " ===========================================
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwRemoteListing: {{{2
    1              0.000002 fun! s:NetrwRemoteListing()
                            "  call Dfunc("s:NetrwRemoteListing() b:netrw_curdir<".b:netrw_curdir.">)")
                            
                              call s:RemotePathAnalysis(b:netrw_curdir)
                            "  call Decho("b:netrw_method#".(exists("b:netrw_method")? b:netrw_method : 'n/a'))
                            "  call Decho("g:netrw_list_cmd<".(exists("g:netrw_list_cmd")? g:netrw_list_cmd : 'n/a').">")
                            "  call Decho("ssh  is ".(executable("ssh")?  "" : "not ")."executable")
                            "  call Decho("ftp  is ".(executable("ftp")?  "" : "not ")."executable")
                            "  call Decho("sftp is ".(executable("sftp")? "" : "not ")."executable")
                            
                              " sanity check:
                              if exists("b:netrw_method") && b:netrw_method =~ '[235]'
                               " b:netrw_method = 2: ftp+.netrc
                               " b:netrw_method = 3: ftp+machine,id,p/w,filename (ie. no .netrc)
                               " b:netrw_method = 5: wget (http)
                            "   call Decho("b:netrw_method=".b:netrw_method." (for ".s:method.")")
                               if !executable("ftp")
                                if !exists("g:netrw_quiet")
                                 call netrw#ErrorMsg(s:ERROR,"this system doesn't support remote directory listing via ftp",18)
                                endif
                                call s:NetrwOptionRestore("w:")
                            "    call Dret("s:NetrwRemoteListing")
                                return
                               endif
                            
                              elseif s:method == "scp" && (!exists("g:netrw_list_cmd") || g:netrw_list_cmd == '')
                            "   call Decho("g:netrw_list_cmd<".(exists("g:netrw_list_cmd")? g:netrw_list_cmd : 'n/a').">")
                               if !exists("g:netrw_quiet")
                                if !exists("g:netrw_list_cmd") || g:netrw_list_cmd == ""
                                 keepj call netrw#ErrorMsg(s:ERROR,"neither ssh nor ftp"." is executable on your system",47)
                                else
                                 keepj call netrw#ErrorMsg(s:ERROR,"this system doesn't support remote directory listing via ".g:netrw_list_cmd,19)
                                endif
                               endif
                            
                               keepj call s:NetrwOptionRestore("w:")
                            "   call Dret("s:NetrwRemoteListing")
                               return
                              endif  " (remote handling sanity check)
                            
                              if exists("b:netrw_method")
                            "   call Decho("setting w:netrw_method to b:netrw_method<".b:netrw_method.">")
                               let w:netrw_method= b:netrw_method
                              endif
                            
                              if s:method == "ftp"
                               " use ftp to get remote file listing {{{3
                            "   call Decho("use ftp to get remote file listing")
                               let s:method = "ftp"
                               let listcmd  = g:netrw_ftp_list_cmd
                               if g:netrw_sort_by =~ '^t'
                                let listcmd= g:netrw_ftp_timelist_cmd
                               elseif g:netrw_sort_by =~ '^s'
                                let listcmd= g:netrw_ftp_sizelist_cmd
                               endif
                            "   call Decho("listcmd<".listcmd."> (using g:netrw_ftp_list_cmd)")
                               call s:NetrwRemoteFtpCmd(s:path,listcmd)
                            "   exe "sil! keepalt keepj ".w:netrw_bannercnt.',$g/^./call Decho("raw listing: ".getline("."))'
                            
                               if w:netrw_liststyle == s:THINLIST || w:netrw_liststyle == s:WIDELIST || w:netrw_liststyle == s:TREELIST
                                " shorten the listing
                            "    call Decho("generate short listing")
                                exe "sil! keepalt keepj ".w:netrw_bannercnt
                            
                                " cleanup
                                if g:netrw_ftp_browse_reject != ""
                                 exe "sil! keepalt keepj g/".g:netrw_ftp_browse_reject."/keepj d"
                                 keepj call histdel("/",-1)
                                endif
                                sil! keepj %s/\r$//e
                                keepj call histdel("/",-1)
                            
                                " if there's no ../ listed, then put ../ in
                                let line1= line(".")
                                exe "sil! keepj ".w:netrw_bannercnt
                                let line2= search('\.\.\/\%(\s\|$\)','cnW')
                            "    call Decho("search(".'\.\.\/\%(\s\|$\)'."','cnW')=".line2."  w:netrw_bannercnt=".w:netrw_bannercnt)
                                if line2 == 0
                            "     call Decho("netrw is putting ../ into listing")
                                 sil! keepj put='../'
                                endif
                                exe "sil! keepj ".line1
                                sil! keepj norm! 0
                            
                            "    call Decho("line1=".line1." line2=".line2." line(.)=".line("."))
                                if search('^\d\{2}-\d\{2}-\d\{2}\s','n') " M$ ftp site cleanup
                            "     call Decho("M$ ftp cleanup")
                                 exe 'sil! keepj '.w:netrw_bannercnt.',$s/^\d\{2}-\d\{2}-\d\{2}\s\+\d\+:\d\+[AaPp][Mm]\s\+\%(<DIR>\|\d\+\)\s\+//'
                                 keepj call histdel("/",-1)
                                else " normal ftp cleanup
                            "     call Decho("normal ftp cleanup")
                                 exe 'sil! keepj '.w:netrw_bannercnt.',$s/^\(\%(\S\+\s\+\)\{7}\S\+\)\s\+\(\S.*\)$/\2/e'
                                 exe "sil! keepj ".w:netrw_bannercnt.',$g/ -> /s# -> .*/$#/#e'
                                 exe "sil! keepj ".w:netrw_bannercnt.',$g/ -> /s# -> .*$#/#e'
                                 keepj call histdel("/",-1)
                                 keepj call histdel("/",-1)
                                 keepj call histdel("/",-1)
                                endif
                               endif
                            
                              else
                               " use ssh to get remote file listing {{{3
                            "   call Decho("use ssh to get remote file listing: s:path<".s:path.">")
                               let listcmd= s:MakeSshCmd(g:netrw_list_cmd)
                            "   call Decho("listcmd<".listcmd."> (using g:netrw_list_cmd)")
                               if g:netrw_scp_cmd =~ '^pscp'
                            "    call Decho("1: exe sil r! ".shellescape(listcmd.s:path, 1))
                                exe "sil! keepj r! ".listcmd.shellescape(s:path, 1)
                                " remove rubbish and adjust listing format of 'pscp' to 'ssh ls -FLa' like
                                sil! keepj g/^Listing directory/keepj d
                                sil! keepj g/^d[-rwx][-rwx][-rwx]/keepj s+$+/+e
                                sil! keepj g/^l[-rwx][-rwx][-rwx]/keepj s+$+@+e
                                keepj call histdel("/",-1)
                                keepj call histdel("/",-1)
                                keepj call histdel("/",-1)
                                if g:netrw_liststyle != s:LONGLIST
                                 sil! keepj g/^[dlsp-][-rwx][-rwx][-rwx]/keepj s/^.*\s\(\S\+\)$/\1/e
                                 keepj call histdel("/",-1)
                                endif
                               else
                                if s:path == ""
                            "     call Decho("2: exe sil r! ".listcmd)
                                 exe "sil! keepj keepalt r! ".listcmd
                                else
                            "     call Decho("3: exe sil r! ".listcmd.' '.shellescape(fnameescape(s:path),1))
                                 exe "sil! keepj keepalt r! ".listcmd.' '.shellescape(fnameescape(s:path),1)
                            "     call Decho("listcmd<".listcmd."> path<".s:path.">")
                                endif
                               endif
                            
                               " cleanup
                               if g:netrw_ftp_browse_reject != ""
                            "    call Decho("(cleanup) exe sil! g/".g:netrw_ssh_browse_reject."/keepjumps d")
                                exe "sil! g/".g:netrw_ssh_browse_reject."/keepj d"
                                keepj call histdel("/",-1)
                               endif
                              endif
                            
                              if w:netrw_liststyle == s:LONGLIST
                               " do a long listing; these substitutions need to be done prior to sorting {{{3
                            "   call Decho("fix long listing:")
                            
                               if s:method == "ftp"
                                " cleanup
                                exe "sil! keepj ".w:netrw_bannercnt
                                while getline('.') =~ g:netrw_ftp_browse_reject
                                 sil! keepj d
                                endwhile
                                " if there's no ../ listed, then put ../ in
                                let line1= line(".")
                                sil! keepj 1
                                sil! keepj call search('^\.\.\/\%(\s\|$\)','W')
                                let line2= line(".")
                                if line2 == 0
                                 if b:netrw_curdir != '/'
                                  exe 'sil! keepj '.w:netrw_bannercnt."put='../'"
                                 endif
                                endif
                                exe "sil! keepj ".line1
                                sil! keepj norm! 0
                               endif
                            
                               if search('^\d\{2}-\d\{2}-\d\{2}\s','n') " M$ ftp site cleanup
                            "    call Decho("M$ ftp site listing cleanup")
                                exe 'sil! keepj '.w:netrw_bannercnt.',$s/^\(\d\{2}-\d\{2}-\d\{2}\s\+\d\+:\d\+[AaPp][Mm]\s\+\%(<DIR>\|\d\+\)\s\+\)\(\w.*\)$/\2\t\1/'
                               elseif exists("w:netrw_bannercnt") && w:netrw_bannercnt <= line("$")
                            "    call Decho("normal ftp site listing cleanup: bannercnt=".w:netrw_bannercnt." line($)=".line("$"))
                                exe 'sil keepj '.w:netrw_bannercnt.',$s/ -> .*$//e'
                                exe 'sil keepj '.w:netrw_bannercnt.',$s/^\(\%(\S\+\s\+\)\{7}\S\+\)\s\+\(\S.*\)$/\2\t\1/e'
                                exe 'sil keepj '.w:netrw_bannercnt
                                keepj call histdel("/",-1)
                                keepj call histdel("/",-1)
                                keepj call histdel("/",-1)
                               endif
                              endif
                            
                            "  if exists("w:netrw_bannercnt") && w:netrw_bannercnt <= line("$") " Decho
                            "   exe "keepj ".w:netrw_bannercnt.',$g/^./call Decho("listing: ".getline("."))'
                            "  endif " Decho
                            "  call Dret("s:NetrwRemoteListing")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwRemoteRm: remove/delete a remote file or directory {{{2
    1              0.000005 fun! s:NetrwRemoteRm(usrhost,path) range
                            "  call Dfunc("s:NetrwRemoteRm(usrhost<".a:usrhost."> path<".a:path.">) virtcol=".virtcol("."))
                            "  call Decho("firstline=".a:firstline." lastline=".a:lastline)
                              let svpos= netrw#NetrwSavePosn()
                            
                              let all= 0
                              if exists("s:netrwmarkfilelist_{bufnr('%')}")
                               " remove all marked files
                            "   call Decho("remove all marked files with bufnr#".bufnr("%"))
                               for fname in s:netrwmarkfilelist_{bufnr("%")}
                                let ok= s:NetrwRemoteRmFile(a:path,fname,all)
                                if ok =~ 'q\%[uit]'
                                 break
                                elseif ok =~ 'a\%[ll]'
                                 let all= 1
                                endif
                               endfor
                               call s:NetrwUnmarkList(bufnr("%"),b:netrw_curdir)
                            
                              else
                               " remove files specified by range
                            "   call Decho("remove files specified by range")
                            
                               " preparation for removing multiple files/directories
                               let ctr= a:firstline
                            
                               " remove multiple files and directories
                               while ctr <= a:lastline
                                exe "keepj ".ctr
                                let ok= s:NetrwRemoteRmFile(a:path,s:NetrwGetWord(),all)
                                if ok =~ 'q\%[uit]'
                                 break
                                elseif ok =~ 'a\%[ll]'
                                 let all= 1
                                endif
                                let ctr= ctr + 1
                               endwhile
                              endif
                            
                              " refresh the (remote) directory listing
                            "  call Decho("refresh remote directory listing")
                              keepj call s:NetrwRefresh(0,s:NetrwBrowseChgDir(0,'./'))
                              keepj call netrw#NetrwRestorePosn(svpos)
                            
                            "  call Dret("s:NetrwRemoteRm")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwRemoteRmFile: {{{2
    1              0.000004 fun! s:NetrwRemoteRmFile(path,rmfile,all)
                            "  call Dfunc("s:NetrwRemoteRmFile(path<".a:path."> rmfile<".a:rmfile.">) all=".a:all)
                            
                              let all= a:all
                              let ok = ""
                            
                              if a:rmfile !~ '^"' && (a:rmfile =~ '@$' || a:rmfile !~ '[\/]$')
                               " attempt to remove file
                            "    call Decho("attempt to remove file (all=".all.")")
                               if !all
                                echohl Statement
                            "    call Decho("case all=0:")
                                call inputsave()
                                let ok= input("Confirm deletion of file<".a:rmfile."> ","[{y(es)},n(o),a(ll),q(uit)] ")
                                call inputrestore()
                                echohl NONE
                                if ok == ""
                                 let ok="no"
                                endif
                                let ok= substitute(ok,'\[{y(es)},n(o),a(ll),q(uit)]\s*','','e')
                                if ok =~ 'a\%[ll]'
                                 let all= 1
                                endif
                               endif
                            
                               if all || ok =~ 'y\%[es]' || ok == ""
                            "    call Decho("case all=".all." or ok<".ok.">".(exists("w:netrw_method")? ': netrw_method='.w:netrw_method : ""))
                                if exists("w:netrw_method") && (w:netrw_method == 2 || w:netrw_method == 3)
                            "     call Decho("case ftp:")
                                 let path= a:path
                                 if path =~ '^\a\+://'
                                  let path= substitute(path,'^\a\+://[^/]\+/','','')
                                 endif
                                 sil! keepj .,$d
                                 call s:NetrwRemoteFtpCmd(path,"delete ".'"'.a:rmfile.'"')
                                else
                            "     call Decho("case ssh: g:netrw_rm_cmd<".g:netrw_rm_cmd.">")
                                 let netrw_rm_cmd= s:MakeSshCmd(g:netrw_rm_cmd)
                            "     call Decho("netrw_rm_cmd<".netrw_rm_cmd.">")
                                 if !exists("b:netrw_curdir")
                                  keepj call netrw#ErrorMsg(s:ERROR,"for some reason b:netrw_curdir doesn't exist!",53)
                                  let ok="q"
                                 else
                                  let remotedir= substitute(b:netrw_curdir,'^.*//[^/]\+/\(.*\)$','\1','')
                            "      call Decho("netrw_rm_cmd<".netrw_rm_cmd.">")
                            "      call Decho("remotedir<".remotedir.">")
                            "      call Decho("rmfile<".a:rmfile.">")
                                  if remotedir != ""
                                   let netrw_rm_cmd= netrw_rm_cmd." ".shellescape(fnameescape(remotedir.a:rmfile))
                                  else
                                   let netrw_rm_cmd= netrw_rm_cmd." ".shellescape(fnameescape(a:rmfile))
                                  endif
                            "      call Decho("call system(".netrw_rm_cmd.")")
                                  let ret= system(netrw_rm_cmd)
                                  if ret != 0
                                   keepj call netrw#ErrorMsg(s:WARNING,"cmd<".netrw_rm_cmd."> failed",60)
                                  endif
                            "      call Decho("returned=".ret." errcode=".v:shell_error)
                                 endif
                                endif
                               elseif ok =~ 'q\%[uit]'
                            "    call Decho("ok==".ok)
                               endif
                            
                              else
                               " attempt to remove directory
                            "    call Decho("attempt to remove directory")
                               if !all
                                call inputsave()
                                let ok= input("Confirm deletion of directory<".a:rmfile."> ","[{y(es)},n(o),a(ll),q(uit)] ")
                                call inputrestore()
                                if ok == ""
                                 let ok="no"
                                endif
                                let ok= substitute(ok,'\[{y(es)},n(o),a(ll),q(uit)]\s*','','e')
                                if ok =~ 'a\%[ll]'
                                 let all= 1
                                endif
                               endif
                            
                               if all || ok =~ 'y\%[es]' || ok == ""
                                if exists("w:netrw_method") && (w:netrw_method == 2 || w:netrw_method == 3)
                                 keepj call s:NetrwRemoteFtpCmd(a:path,"rmdir ".a:rmfile)
                                else
                                 let rmfile          = substitute(a:path.a:rmfile,'/$','','')
                                 let netrw_rmdir_cmd = s:MakeSshCmd(netrw#WinPath(g:netrw_rmdir_cmd)).' '.shellescape(netrw#WinPath(rmfile))
                            "      call Decho("attempt to remove dir: system(".netrw_rmdir_cmd.")")
                                 let ret= system(netrw_rmdir_cmd)
                            "      call Decho("returned=".ret." errcode=".v:shell_error)
                            
                                 if v:shell_error != 0
                            "      call Decho("v:shell_error not 0")
                                  let netrw_rmf_cmd= s:MakeSshCmd(netrw#WinPath(g:netrw_rmf_cmd)).' '.shellescape(netrw#WinPath(substitute(rmfile,'[\/]$','','e')))
                            "      call Decho("2nd attempt to remove dir: system(".netrw_rmf_cmd.")")
                                  let ret= system(netrw_rmf_cmd)
                            "      call Decho("returned=".ret." errcode=".v:shell_error)
                            
                                  if v:shell_error != 0 && !exists("g:netrw_quiet")
                                  	keepj call netrw#ErrorMsg(s:ERROR,"unable to remove directory<".rmfile."> -- is it empty?",22)
                                  endif
                                 endif
                                endif
                            
                               elseif ok =~ 'q\%[uit]'
                            "    call Decho("ok==".ok)
                               endif
                              endif
                            
                            "  call Dret("s:NetrwRemoteRmFile ".ok)
                              return ok
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwRemoteFtpCmd: unfortunately, not all ftp servers honor options for ls {{{2
                            "  This function assumes that a long listing will be received.  Size, time,
                            "  and reverse sorts will be requested of the server but not otherwise
                            "  enforced here.
    1              0.000004 fun! s:NetrwRemoteFtpCmd(path,listcmd)
                            "  call Dfunc("NetrwRemoteFtpCmd(path<".a:path."> listcmd<".a:listcmd.">) w:netrw_method=".(exists("w:netrw_method")? w:netrw_method : (exists("b:netrw_method")? b:netrw_method : "???")))
                            "  call Decho("line($)=".line("$")." w:netrw_bannercnt=".w:netrw_bannercnt)
                              if !exists("w:netrw_method")
                               if exists("b:netrw_method")
                                let w:netrw_method= b:netrw_method
                               else
                                call netrw#ErrorMsg(2,"(s:NetrwRemoteFtpCmd) internal netrw error",93)
                            "    call Dret("NetrwRemoteFtpCmd")
                                return
                               endif
                              endif
                            
                              " because WinXX ftp uses unix style input
                              let ffkeep= &ff
                              setl ma ff=unix noro
                            "  call Decho("setl ma ff=unix noro")
                            
                              " clear off any older non-banner lines
                              " note that w:netrw_bannercnt indexes the line after the banner
                            "  call Decho('exe sil! keepjumps '.w:netrw_bannercnt.",$d  (clear off old non-banner lines)")
                              exe "sil! keepjumps ".w:netrw_bannercnt.",$d"
                            
                              ".........................................
                              if w:netrw_method == 2 || w:netrw_method == 5
                               " ftp + <.netrc>:  Method #2
                               if a:path != ""
                                keepj put ='cd \"'.a:path.'\"'
                               endif
                               if exists("g:netrw_ftpextracmd")
                                keepj put =g:netrw_ftpextracmd
                            "    call Decho("filter input: ".getline('.'))
                               endif
                               keepj call setline(line("$")+1,a:listcmd)
                            "   exe "keepjumps ".w:netrw_bannercnt.',$g/^./call Decho("ftp#".line(".").": ".getline("."))'
                               if exists("g:netrw_port") && g:netrw_port != ""
                            "    call Decho("exe ".s:netrw_silentxfer.w:netrw_bannercnt.",$!".s:netrw_ftp_cmd." -i ".shellescape(g:netrw_machine,1)." ".shellescape(g:netrw_port,1))
                                exe s:netrw_silentxfer." keepj ".w:netrw_bannercnt.",$!".s:netrw_ftp_cmd." -i ".shellescape(g:netrw_machine,1)." ".shellescape(g:netrw_port,1)
                               else
                            "    call Decho("exe ".s:netrw_silentxfer.w:netrw_bannercnt.",$!".s:netrw_ftp_cmd." -i ".shellescape(g:netrw_machine,1))
                                exe s:netrw_silentxfer." keepj ".w:netrw_bannercnt.",$!".s:netrw_ftp_cmd." -i ".shellescape(g:netrw_machine,1)
                               endif
                            
                               ".........................................
                              elseif w:netrw_method == 3
                               " ftp + machine,id,passwd,filename:  Method #3
                                setl ff=unix
                                if exists("g:netrw_port") && g:netrw_port != ""
                                 keepj put ='open '.g:netrw_machine.' '.g:netrw_port
                                else
                                 keepj put ='open '.g:netrw_machine
                                endif
                            
                                " handle userid and password
                                let host= substitute(g:netrw_machine,'\..*$','','')
                            "    call Decho("host<".host.">")
                                if exists("s:netrw_hup") && exists("s:netrw_hup[host]")
                                 call NetUserPass("ftp:".host)
                                endif
                                if exists("g:netrw_uid") && g:netrw_uid != ""
                                 if exists("g:netrw_ftp") && g:netrw_ftp == 1
                                  keepj put =g:netrw_uid
                                  if exists("s:netrw_passwd") && s:netrw_passwd != ""
                                   keepj put ='\"'.s:netrw_passwd.'\"'
                                  endif
                                 elseif exists("s:netrw_passwd")
                                  keepj put ='user \"'.g:netrw_uid.'\" \"'.s:netrw_passwd.'\"'
                                 endif
                                endif
                            
                               if a:path != ""
                                keepj put ='cd \"'.a:path.'\"'
                               endif
                               if exists("g:netrw_ftpextracmd")
                                keepj put =g:netrw_ftpextracmd
                            "    call Decho("filter input: ".getline('.'))
                               endif
                               keepj call setline(line("$")+1,a:listcmd)
                            
                                " perform ftp:
                                " -i       : turns off interactive prompting from ftp
                                " -n  unix : DON'T use <.netrc>, even though it exists
                                " -n  win32: quit being obnoxious about password
                            "    exe w:netrw_bannercnt.',$g/^./call Decho("ftp#".line(".").": ".getline("."))'
                            "    call Decho("exe ".s:netrw_silentxfer.w:netrw_bannercnt.",$!".s:netrw_ftp_cmd." ".g:netrw_ftp_options)
                                exe s:netrw_silentxfer.w:netrw_bannercnt.",$!".s:netrw_ftp_cmd." ".g:netrw_ftp_options
                            
                               ".........................................
                              else
                               keepj call netrw#ErrorMsg(s:WARNING,"unable to comply with your request<" . choice . ">",23)
                              endif
                            
                              " cleanup for Windows
                              if has("win32") || has("win95") || has("win64") || has("win16")
                               sil! keepj %s/\r$//e
                               keepj call histdel("/",-1)
                              endif
                              if a:listcmd == "dir"
                               " infer directory/link based on the file permission string
                               sil! keepj g/d\%([-r][-w][-x]\)\{3}/keepj s@$@/@
                               sil! keepj g/l\%([-r][-w][-x]\)\{3}/keepj s/$/@/
                               keepj call histdel("/",-1)
                               keepj call histdel("/",-1)
                               if w:netrw_liststyle == s:THINLIST || w:netrw_liststyle == s:WIDELIST || w:netrw_liststyle == s:TREELIST
                                exe "sil! keepj ".w:netrw_bannercnt.',$s/^\%(\S\+\s\+\)\{8}//e'
                                keepj call histdel("/",-1)
                               endif
                              endif
                            
                              " ftp's listing doesn't seem to include ./ or ../
                              if !search('^\.\/$\|\s\.\/$','wn')
                               exe 'keepj '.w:netrw_bannercnt
                               keepj put ='./'
                              endif
                              if !search('^\.\.\/$\|\s\.\.\/$','wn')
                               exe 'keepj '.w:netrw_bannercnt
                               keepj put ='../'
                              endif
                            
                              " restore settings
                              let &ff= ffkeep
                            "  call Dret("NetrwRemoteFtpCmd")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwRemoteRename: rename a remote file or directory {{{2
    1              0.000007 fun! s:NetrwRemoteRename(usrhost,path) range
                            "  call Dfunc("NetrwRemoteRename(usrhost<".a:usrhost."> path<".a:path.">)")
                            
                              " preparation for removing multiple files/directories
                              let svpos      = netrw#NetrwSavePosn()
                              let ctr        = a:firstline
                              let rename_cmd = s:MakeSshCmd(g:netrw_rename_cmd)
                            
                              " rename files given by the markfilelist
                              if exists("s:netrwmarkfilelist_{bufnr('%')}")
                               for oldname in s:netrwmarkfilelist_{bufnr("%")}
                            "    call Decho("oldname<".oldname.">")
                                if exists("subfrom")
                                 let newname= substitute(oldname,subfrom,subto,'')
                            "     call Decho("subfrom<".subfrom."> subto<".subto."> newname<".newname.">")
                                else
                                 call inputsave()
                                 let newname= input("Moving ".oldname." to : ",oldname)
                                 call inputrestore()
                                 if newname =~ '^s/'
                                  let subfrom = substitute(newname,'^s/\([^/]*\)/.*/$','\1','')
                                  let subto   = substitute(newname,'^s/[^/]*/\(.*\)/$','\1','')
                                  let newname = substitute(oldname,subfrom,subto,'')
                            "      call Decho("subfrom<".subfrom."> subto<".subto."> newname<".newname.">")
                                 endif
                                endif
                               
                                if exists("w:netrw_method") && (w:netrw_method == 2 || w:netrw_method == 3)
                                 keepj call s:NetrwRemoteFtpCmd(a:path,"rename ".oldname." ".newname)
                                else
                                 let oldname= shellescape(a:path.oldname)
                                 let newname= shellescape(a:path.newname)
                            "     call Decho("system(netrw#WinPath(".rename_cmd.") ".oldname.' '.newname.")")
                                 let ret    = system(netrw#WinPath(rename_cmd).' '.oldname.' '.newname)
                                endif
                            
                               endfor
                               call s:NetrwUnMarkFile(1)
                            
                              else
                            
                              " attempt to rename files/directories
                               while ctr <= a:lastline
                                exe "keepj ".ctr
                            
                                let oldname= s:NetrwGetWord()
                            "   call Decho("oldname<".oldname.">")
                            
                                call inputsave()
                                let newname= input("Moving ".oldname." to : ",oldname)
                                call inputrestore()
                            
                                if exists("w:netrw_method") && (w:netrw_method == 2 || w:netrw_method == 3)
                                 call s:NetrwRemoteFtpCmd(a:path,"rename ".oldname." ".newname)
                                else
                                 let oldname= shellescape(a:path.oldname)
                                 let newname= shellescape(a:path.newname)
                            "     call Decho("system(netrw#WinPath(".rename_cmd.") ".oldname.' '.newname.")")
                                 let ret    = system(netrw#WinPath(rename_cmd).' '.oldname.' '.newname)
                                endif
                            
                                let ctr= ctr + 1
                               endwhile
                              endif
                            
                              " refresh the directory
                              keepj call s:NetrwRefresh(0,s:NetrwBrowseChgDir(0,'./'))
                              keepj call netrw#NetrwRestorePosn(svpos)
                            
                            "  call Dret("NetrwRemoteRename")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            "  Local Directory Browsing Support:    {{{1
                            " ==========================================
                            
                            " ---------------------------------------------------------------------
                            " netrw#FileUrlRead: handles reading file://* files {{{2
                            "   Should accept:   file://localhost/etc/fstab
                            "                    file:///etc/fstab
                            "                    file:///c:/WINDOWS/clock.avi
                            "                    file:///c|/WINDOWS/clock.avi
                            "                    file://localhost/c:/WINDOWS/clock.avi
                            "                    file://localhost/c|/WINDOWS/clock.avi
                            "                    file://c:/foo.txt
                            "                    file:///c:/foo.txt
                            " and %XX (where X is [0-9a-fA-F] is converted into a character with the given hexadecimal value
    1              0.000007 fun! netrw#FileUrlRead(fname)
                            "  call Dfunc("netrw#FileUrlRead(fname<".a:fname.">)")
                              let fname = a:fname
                              if fname =~ '^file://localhost/'
                            "   call Decho('converting file://localhost/   -to-  file:///')
                               let fname= substitute(fname,'^file://localhost/','file:///','')
                            "   call Decho("fname<".fname.">")
                              endif
                              if (has("win32") || has("win95") || has("win64") || has("win16"))
                               if fname  =~ '^file:///\=\a[|:]/'
                            "    call Decho('converting file:///\a|/   -to-  file://\a:/')
                                let fname = substitute(fname,'^file:///\=\(\a\)[|:]/','file://\1:/','')
                            "    call Decho("fname<".fname.">")
                               endif
                              endif
                              let fname2396 = netrw#RFC2396(fname)
                              let fname2396e= fnameescape(fname2396)
                              let plainfname= substitute(fname2396,'file://\(.*\)','\1',"")
                              if (has("win32") || has("win95") || has("win64") || has("win16"))
                            "   call Decho("windows exception for plainfname")
                               if plainfname =~ '^/\+\a:'
                            "    call Decho('removing leading "/"s')
                                let plainfname= substitute(plainfname,'^/\+\(\a:\)','\1','')
                               endif
                              endif
                            "  call Decho("fname2396<".fname2396.">")
                            "  call Decho("plainfname<".plainfname.">")
                              exe "sil doau BufReadPre ".fname2396e
                              exe 'keepj r '.plainfname
                              exe 'sil! bdelete '.plainfname
                              exe 'keepalt file! '.plainfname
                              keepj 1d
                            "  call Decho("(FileUrlRead) setl nomod")
                              setl nomod
                            "  call Decho("(FileUrlRead) ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
                            "  call Dret("netrw#FileUrlRead")
                              exe "sil doau BufReadPost ".fname2396e
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " netrw#LocalBrowseCheck: {{{2
    1              0.000004 fun! netrw#LocalBrowseCheck(dirname)
                              " unfortunate interaction -- split window debugging can't be
                              " used here, must use D-echoRemOn or D-echoTabOn -- the BufEnter
                              " event triggers another call to LocalBrowseCheck() when attempts
                              " to write to the DBG buffer are made.
                              " The &ft == "netrw" test was installed because the BufEnter event
                              " would hit when re-entering netrw windows, creating unexpected
                              " refreshes (and would do so in the middle of NetrwSaveOptions(), too)
                            "  call Decho("(LocalBrowseCheck) isdir<".a:dirname.">=".isdirectory(a:dirname).((exists("s:treeforceredraw")? " treeforceredraw" : "")))
                            "  call Dredir("LocalBrowseCheck","ls!")|redraw!|sleep 3
                              let ykeep= @@
                              if isdirectory(a:dirname)
                            "   call Decho("(LocalBrowseCheck) is-directory ft<".&ft."> b:netrw_curdir<".(exists("b:netrw_curdir")? b:netrw_curdir : " doesn't exist")."> dirname<".a:dirname.">"." line($)=".line("$")." ft<".&ft."> g:netrw_fastbrowse=".g:netrw_fastbrowse)
                               let svposn= netrw#NetrwSavePosn()
                               if &ft != "netrw" || (exists("b:netrw_curdir") && b:netrw_curdir != a:dirname) || g:netrw_fastbrowse <= 1
                                sil! keepj keepalt call s:NetrwBrowse(1,a:dirname)
                                keepalt call netrw#NetrwRestorePosn(svposn)
                               elseif &ft == "netrw" && line("$") == 1
                                sil! keepj keepalt call s:NetrwBrowse(1,a:dirname)
                                keepalt call netrw#NetrwRestorePosn(svposn)
                               elseif exists("s:treeforceredraw")
                                unlet s:treeforceredraw
                                sil! keepj keepalt call s:NetrwBrowse(1,a:dirname)
                                keepalt call netrw#NetrwRestorePosn(svposn)
                               endif
                              endif
                              " following code wipes out currently unused netrw buffers
                              "       IF g:netrw_fastbrowse is zero (ie. slow browsing selected)
                              "   AND IF the listing style is not a tree listing
                              if exists("g:netrw_fastbrowse") && g:netrw_fastbrowse == 0 && g:netrw_liststyle != s:TREELIST
                               let ibuf    = 1
                               let buflast = bufnr("$")
                               while ibuf <= buflast
                                if bufwinnr(ibuf) == -1 && isdirectory(bufname(ibuf))
                                 exe "sil! keepalt ".ibuf."bw!"
                                endif
                                let ibuf= ibuf + 1
                               endwhile
                              endif
                              let @@= ykeep
                              " not a directory, ignore it
                            endfun
                            
                            " ---------------------------------------------------------------------
                            "  s:LocalListing: does the job of "ls" for local directories {{{2
    1              0.000003 fun! s:LocalListing()
                            "  call Dfunc("s:LocalListing()")
                            "  call Decho("(LocalListing) ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
                            "  call Decho("(LocalListing) tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> modified=".&modified." modifiable=".&modifiable." readonly=".&readonly)
                            
                            "  if exists("b:netrw_curdir") |call Decho('(LocalListing) b:netrw_curdir<'.b:netrw_curdir.">")  |else|call Decho("(LocalListing) b:netrw_curdir doesn't exist") |endif
                            "  if exists("g:netrw_sort_by")|call Decho('(LocalListing) g:netrw_sort_by<'.g:netrw_sort_by.">")|else|call Decho("(LocalListing) g:netrw_sort_by doesn't exist")|endif
                            
                              " get the list of files contained in the current directory
                              let dirname    = b:netrw_curdir
                              let dirnamelen = s:Strlen(b:netrw_curdir)
                              let filelist   = glob(s:ComposePath(dirname,"*"),0,1)
                              let filelist   = filelist + glob(s:ComposePath(dirname,".*"),0,1)
                            "  call Decho("(LocalListing) filelist=".filelist)
                            
                              if g:netrw_cygwin == 0 && (has("win32") || has("win95") || has("win64") || has("win16"))
                            "   call Decho("(LocalListing) filelist=".string(filelist))
                              elseif index(filelist,'..') == -1 && b:netrw_curdir !~ '/'
                                " include ../ in the glob() entry if its missing
                            "   call Decho("(LocalListing) forcibly including on \"..\"")
                               let filelist= filelist+[s:ComposePath(b:netrw_curdir,"../")]
                            "   call Decho("(LocalListing) filelist=".string(filelist))
                              endif
                            
                            "  call Decho("(LocalListing) (before while) dirname<".dirname.">")
                            "  call Decho("(LocalListing) (before while) dirnamelen<".dirnamelen.">")
                            "  call Decho("(LocalListing) (before while) filelist=".string(filelist))
                            
                              if get(g:, 'netrw_dynamic_maxfilenamelen', 0)
                               let filelistcopy           = map(deepcopy(filelist),'fnamemodify(v:val, ":t")')
                               let g:netrw_maxfilenamelen = max(map(filelistcopy,'len(v:val)')) + 1
                            "   call Decho("(LocalListing) dynamic_maxfilenamelen: filenames             =".string(filelistcopy))
                            "   call Decho("(LocalListing) dynamic_maxfilenamelen: g:netrw_maxfilenamelen=".g:netrw_maxfilenamelen)
                              endif
                            
                              for filename in filelist
                            "   call Decho("(LocalListing)  ")
                            "   call Decho("(LocalListing) (while) filename<".filename.">")
                            
                               if getftype(filename) == "link"
                                " indicate a symbolic link
                            "    call Decho("(LocalListing) indicate <".filename."> is a symbolic link with trailing @")
                                let pfile= filename."@"
                            
                               elseif getftype(filename) == "socket"
                                " indicate a socket
                            "    call Decho("(LocalListing) indicate <".filename."> is a socket with trailing =")
                                let pfile= filename."="
                            
                               elseif getftype(filename) == "fifo"
                                " indicate a fifo
                            "    call Decho("(LocalListing) indicate <".filename."> is a fifo with trailing |")
                                let pfile= filename."|"
                            
                               elseif isdirectory(filename)
                                " indicate a directory
                            "    call Decho("(LocalListing) indicate <".filename."> is a directory with trailing /")
                                let pfile= filename."/"
                            
                               elseif exists("b:netrw_curdir") && b:netrw_curdir !~ '^.*://' && !isdirectory(filename)
                                if (has("win32") || has("win95") || has("win64") || has("win16"))
                                 if filename =~ '\.[eE][xX][eE]$' || filename =~ '\.[cC][oO][mM]$' || filename =~ '\.[bB][aA][tT]$'
                                  " indicate an executable
                            "      call Decho("(LocalListing) indicate <".filename."> is executable with trailing *")
                                  let pfile= filename."*"
                                 else
                                  " normal file
                                  let pfile= filename
                                 endif
                                elseif executable(filename)
                                 " indicate an executable
                            "     call Decho("(LocalListing) indicate <".filename."> is executable with trailing *")
                                 let pfile= filename."*"
                                else
                                 " normal file
                                 let pfile= filename
                                endif
                            
                               else
                                " normal file
                                let pfile= filename
                               endif
                            "   call Decho("(LocalListing) pfile<".pfile."> (after *@/ appending)")
                            
                               if pfile =~ '//$'
                                let pfile= substitute(pfile,'//$','/','e')
                            "    call Decho("(LocalListing) change // to /: pfile<".pfile.">")
                               endif
                               let pfile= strpart(pfile,dirnamelen)
                               let pfile= substitute(pfile,'^[/\\]','','e')
                            "   call Decho("(LocalListing) filename<".filename.">")
                            "   call Decho("(LocalListing) pfile   <".pfile.">")
                            
                               if w:netrw_liststyle == s:LONGLIST
                                let sz   = getfsize(filename)
                                let fsz  = strpart("               ",1,15-strlen(sz)).sz
                                let pfile= pfile."\t".fsz." ".strftime(g:netrw_timefmt,getftime(filename))
                            "    call Decho("(LocalListing) sz=".sz." fsz=".fsz)
                               endif
                            
                               if     g:netrw_sort_by =~ "^t"
                                " sort by time (handles time up to 1 quintillion seconds, US)
                            "    call Decho("(LocalListing) getftime(".filename.")=".getftime(filename))
                                let t  = getftime(filename)
                                let ft = strpart("000000000000000000",1,18-strlen(t)).t
                            "    call Decho("(LocalListing) exe keepjumps put ='".ft.'/'.filename."'")
                                let ftpfile= ft.'/'.pfile
                                sil! keepj put=ftpfile
                            
                               elseif g:netrw_sort_by =~ "^s"
                                " sort by size (handles file sizes up to 1 quintillion bytes, US)
                            "    call Decho("(LocalListing) getfsize(".filename.")=".getfsize(filename))
                                let sz   = getfsize(filename)
                                let fsz  = strpart("000000000000000000",1,18-strlen(sz)).sz
                            "    call Decho("(LocalListing) exe keepj put ='".fsz.'/'.filename."'")
                                let fszpfile= fsz.'/'.pfile
                                sil! keepj put =fszpfile
                            
                               else
                                " sort by name
                            "    call Decho("(LocalListing) exe keepjumps put ='".pfile."'")
                                sil! keepj put=pfile
                               endif
                              endfor
                            
                              " cleanup any windows mess at end-of-line
                              sil! keepj g/^$/d
                              sil! keepj %s/\r$//e
                              call histdel("/",-1)
                            "  call Decho("(LocalListing) exe setl ts=".(g:netrw_maxfilenamelen+1))
                              exe "setl ts=".(g:netrw_maxfilenamelen+1)
                            
                            "  call Dret("s:LocalListing")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:LocalBrowseShellCmdRefresh: this function is called after a user has {{{2
                            " performed any shell command.  The idea is to cause all local-browsing
                            " buffers to be refreshed after a user has executed some shell command,
                            " on the chance that s/he removed/created a file/directory with it.
    1              0.000004 fun! s:LocalBrowseShellCmdRefresh()
                            "  call Dfunc("LocalBrowseShellCmdRefresh() browselist=".(exists("s:netrw_browselist")? string(s:netrw_browselist) : "empty")." ".tabpagenr("$")." tabs")
                              " determine which buffers currently reside in a tab
                              if !exists("s:netrw_browselist")
                            "   call Dret("LocalBrowseShellCmdRefresh : browselist is empty")
                               return
                              endif
                              if !exists("w:netrw_bannercnt")
                            "   call Dret("LocalBrowseShellCmdRefresh : don't refresh when focus not on netrw window")
                               return
                              endif
                              if exists("s:locbrowseshellcmd")
                               if s:locbrowseshellcmd
                                let s:locbrowseshellcmd= 0
                            "    call Dret("LocalBrowseShellCmdRefresh : NetrwBrowse itself caused the refresh")
                                return
                               endif
                               let s:locbrowseshellcmd= 0
                              endif
                              let itab       = 1
                              let buftablist = []
                              let ykeep      = @@
                              while itab <= tabpagenr("$")
                               let buftablist = buftablist + tabpagebuflist()
                               let itab       = itab + 1
                               tabn
                              endwhile
                            "  call Decho("(LocalBrowseShellCmdRefresh) buftablist".string(buftablist))
                            "  call Decho("(LocalBrowseShellCmdRefresh) s:netrw_browselist<".(exists("s:netrw_browselist")? string(s:netrw_browselist) : "").">")
                              "  GO through all buffers on netrw_browselist (ie. just local-netrw buffers):
                              "   | refresh any netrw window
                              "   | wipe out any non-displaying netrw buffer
                              let curwin = winnr()
                              let ibl    = 0
                              for ibuf in s:netrw_browselist
                            "   call Decho("(LocalBrowseShellCmdRefresh) bufwinnr(".ibuf.") index(buftablist,".ibuf.")=".index(buftablist,ibuf))
                               if bufwinnr(ibuf) == -1 && index(buftablist,ibuf) == -1
                                " wipe out any non-displaying netrw buffer
                            "    call Decho("(LocalBrowseShellCmdRefresh) wiping  buf#".ibuf,"<".bufname(ibuf).">")
                                exe "sil! bd ".fnameescape(ibuf)
                                call remove(s:netrw_browselist,ibl)
                            "    call Decho("(LocalBrowseShellCmdRefresh) browselist=".string(s:netrw_browselist))
                                continue
                               elseif index(tabpagebuflist(),ibuf) != -1
                                " refresh any netrw buffer
                            "    call Decho("(LocalBrowseShellCmdRefresh) refresh buf#".ibuf.'-> win#'.bufwinnr(ibuf))
                                exe bufwinnr(ibuf)."wincmd w"
                                keepj call s:NetrwRefresh(1,s:NetrwBrowseChgDir(1,'./'))
                               endif
                               let ibl= ibl + 1
                              endfor
                              exe curwin."wincmd w"
                              let @@= ykeep
                            
                            "  call Dret("LocalBrowseShellCmdRefresh")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:LocalFastBrowser: handles setting up/taking down fast browsing for the local browser {{{2
                            "
                            "     g:netrw_    Directory Is
                            "     fastbrowse  Local  Remote   
                            "  slow   0         D      D      D=Deleting a buffer implies it will not be re-used (slow)
                            "  med    1         D      H      H=Hiding a buffer implies it may be re-used        (fast)
                            "  fast   2         H      H      
                            "
                            "  Deleting a buffer means that it will be re-loaded when examined, hence "slow".
                            "  Hiding   a buffer means that it will be re-used   when examined, hence "fast".
                            "           (re-using a buffer may not be as accurate)
    1              0.000003 fun! s:LocalFastBrowser()
                            "    call Dfunc("LocalFastBrowser() g:netrw_fastbrowse=".g:netrw_fastbrowse."  s:netrw_browser_shellcmd ".(exists("s:netrw_browser_shellcmd")? "exists" : "does not exist"))
                            
                              " initialize browselist, a list of buffer numbers that the local browser has used
                              if !exists("s:netrw_browselist")
                            "   call Decho("(LocalFastBrowser) initialize s:netrw_browselist")
                               let s:netrw_browselist= []
                              endif
                            
                              " append current buffer to fastbrowse list
                              if empty(s:netrw_browselist) || bufnr("%") > s:netrw_browselist[-1]
                            "   call Decho("(LocalFastBrowser) appendng current buffer to browselist")
                               call add(s:netrw_browselist,bufnr("%"))
                            "   call Decho("(LocalFastBrowser) browselist=".string(s:netrw_browselist))
                              endif
                            
                              " enable autocmd events to handle refreshing/removing local browser buffers
                              "    If local browse buffer is currently showing: refresh it
                              "    If local browse buffer is currently hidden : wipe it
                              "    g:netrw_fastbrowse=0 : slow   speed, never re-use directory listing
                              "                      =1 : medium speed, re-use directory listing for remote only
                              "                      =2 : fast   speed, always re-use directory listing when possible
                              if !exists("s:netrw_browser_shellcmd") && g:netrw_fastbrowse <= 1
                            "   call Decho("(LocalFastBrowser) setting up local-browser shell command refresh")
                               let s:netrw_browser_shellcmd= 1
                               augroup AuNetrwShellCmd
                                au!
                                if (has("win32") || has("win95") || has("win64") || has("win16"))
                            "     call Decho("(LocalFastBrowser) autocmd: ShellCmdPost * call s:LocalBrowseShellCmdRefresh()")
                                 au ShellCmdPost			*	call s:LocalBrowseShellCmdRefresh()
                                else
                                 au ShellCmdPost,FocusGained	*	call s:LocalBrowseShellCmdRefresh()
                            "     call Decho("(LocalFastBrowser) autocmd: ShellCmdPost,FocusGained * call s:LocalBrowseShellCmdRefresh()")
                                endif
                               augroup END
                              endif
                            
                              " user must have changed fastbrowse to its fast setting, so remove
                              " the associated autocmd events
                              if g:netrw_fastbrowse > 1 && exists("s:netrw_browser_shellcmd")
                            "   call Decho("(LocalFastBrowser) remove AuNetrwShellCmd autcmd group")
                               unlet s:netrw_browser_shellcmd
                               augroup AuNetrwShellCmd
                                au!
                               augroup END
                               augroup! AuNetrwShellCmd
                              endif
                            
                            "  call Dret("LocalFastBrowser : browselist<".string(s:netrw_browselist).">")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwLocalExecute: uses system() to execute command under cursor ("X" command support) {{{2
    1              0.000003 fun! s:NetrwLocalExecute(cmd)
                            "  call Dfunc("s:NetrwLocalExecute(cmd<".a:cmd.">)")
                              let ykeep= @@
                              " sanity check
                              if !executable(a:cmd)
                               call netrw#ErrorMsg(s:ERROR,"the file<".a:cmd."> is not executable!",89)
                               let @@= ykeep
                            "   call Dret("s:NetrwLocalExecute")
                               return
                              endif
                            
                              let optargs= input(":!".a:cmd,"","file")
                            "  call Decho("optargs<".optargs.">")
                              let result= system(a:cmd.optargs)
                            "  call Decho(result)
                            
                              " strip any ansi escape sequences off
                              let result = substitute(result,"\e\\[[0-9;]*m","","g")
                            
                              " show user the result(s)
                              echomsg result
                              let @@= ykeep
                            
                            "  call Dret("s:NetrwLocalExecute")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwLocalRename: rename a remote file or directory {{{2
    1              0.000004 fun! s:NetrwLocalRename(path) range
                            "  call Dfunc("NetrwLocalRename(path<".a:path.">)")
                            
                              " preparation for removing multiple files/directories
                              let ykeep = @@
                              let ctr   = a:firstline
                              let svpos = netrw#NetrwSavePosn()
                            
                              " rename files given by the markfilelist
                              if exists("s:netrwmarkfilelist_{bufnr('%')}")
                               for oldname in s:netrwmarkfilelist_{bufnr("%")}
                            "    call Decho("oldname<".oldname.">")
                                if exists("subfrom")
                                 let newname= substitute(oldname,subfrom,subto,'')
                            "     call Decho("subfrom<".subfrom."> subto<".subto."> newname<".newname.">")
                                else
                                 call inputsave()
                                 let newname= input("Moving ".oldname." to : ",oldname)
                                 call inputrestore()
                                 if newname =~ '^s/'
                                  let subfrom = substitute(newname,'^s/\([^/]*\)/.*/$','\1','')
                                  let subto   = substitute(newname,'^s/[^/]*/\(.*\)/$','\1','')
                            "      call Decho("subfrom<".subfrom."> subto<".subto."> newname<".newname.">")
                                  let newname = substitute(oldname,subfrom,subto,'')
                                 endif
                                endif
                                call rename(oldname,newname)
                               endfor
                               call s:NetrwUnmarkList(bufnr("%"),b:netrw_curdir)
                              
                              else
                            
                               " attempt to rename files/directories
                               while ctr <= a:lastline
                                exe "keepj ".ctr
                            
                                " sanity checks
                                if line(".") < w:netrw_bannercnt
                                 let ctr= ctr + 1
                                 continue
                                endif
                                let curword= s:NetrwGetWord()
                                if curword == "./" || curword == "../"
                                 let ctr= ctr + 1
                                 continue
                                endif
                            
                                keepj norm! 0
                                let oldname= s:ComposePath(a:path,curword)
                            "   call Decho("oldname<".oldname.">")
                            
                                call inputsave()
                                let newname= input("Moving ".oldname." to : ",substitute(oldname,'/*$','','e'))
                                call inputrestore()
                            
                                call rename(oldname,newname)
                            "   call Decho("renaming <".oldname."> to <".newname.">")
                            
                                let ctr= ctr + 1
                               endwhile
                              endif
                            
                              " refresh the directory
                            "  call Decho("refresh the directory listing")
                              keepj call s:NetrwRefresh(1,s:NetrwBrowseChgDir(1,'./'))
                              keepj call netrw#NetrwRestorePosn(svpos)
                              let @@= ykeep
                            
                            "  call Dret("NetrwLocalRename")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwLocalRm: {{{2
    1              0.000003 fun! s:NetrwLocalRm(path) range
                            "  call Dfunc("s:NetrwLocalRm(path<".a:path.">)")
                            "  call Decho("firstline=".a:firstline." lastline=".a:lastline)
                            
                              " preparation for removing multiple files/directories
                              let ykeep = @@
                              let ret   = 0
                              let all   = 0
                              let svpos = netrw#NetrwSavePosn()
                            
                              if exists("s:netrwmarkfilelist_{bufnr('%')}")
                               " remove all marked files
                            "   call Decho("remove all marked files")
                               for fname in s:netrwmarkfilelist_{bufnr("%")}
                                let ok= s:NetrwLocalRmFile(a:path,fname,all)
                                if ok =~ 'q\%[uit]' || ok == "no"
                                 break
                                elseif ok =~ 'a\%[ll]'
                                 let all= 1
                                endif
                               endfor
                               call s:NetrwUnMarkFile(1)
                            
                              else
                              " remove (multiple) files and directories
                            "   call Decho("remove files in range [".a:firstline.",".a:lastline."]")
                            
                               let ctr = a:firstline
                               while ctr <= a:lastline
                                exe "keepj ".ctr
                            
                                " sanity checks
                                if line(".") < w:netrw_bannercnt
                                 let ctr= ctr + 1
                                 continue
                                endif
                                let curword= s:NetrwGetWord()
                                if curword == "./" || curword == "../"
                                 let ctr= ctr + 1
                                 continue
                                endif
                                let ok= s:NetrwLocalRmFile(a:path,curword,all)
                                if ok =~ 'q\%[uit]' || ok == "no"
                                 break
                                elseif ok =~ 'a\%[ll]'
                                 let all= 1
                                endif
                                let ctr= ctr + 1
                               endwhile
                              endif
                            
                              " refresh the directory
                            "  call Decho("bufname<".bufname("%").">")
                              if bufname("%") != "NetrwMessage"
                               keepj call s:NetrwRefresh(1,s:NetrwBrowseChgDir(1,'./'))
                               keepj call netrw#NetrwRestorePosn(svpos)
                              endif
                              let @@= ykeep
                            
                            "  call Dret("s:NetrwLocalRm")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwLocalRmFile: remove file fname given the path {{{2
                            "                     Give confirmation prompt unless all==1
    1              0.000003 fun! s:NetrwLocalRmFile(path,fname,all)
                            "  call Dfunc("s:NetrwLocalRmFile(path<".a:path."> fname<".a:fname."> all=".a:all)
                              
                              let all= a:all
                              let ok = ""
                              keepj norm! 0
                              let rmfile= s:ComposePath(a:path,a:fname)
                            "  call Decho("rmfile<".rmfile.">")
                            
                              if rmfile !~ '^"' && (rmfile =~ '@$' || rmfile !~ '[\/]$')
                               " attempt to remove file
                            "   call Decho("attempt to remove file<".rmfile.">")
                               if !all
                                echohl Statement
                                call inputsave()
                                let ok= input("Confirm deletion of file<".rmfile."> ","[{y(es)},n(o),a(ll),q(uit)] ")
                                call inputrestore()
                                echohl NONE
                                if ok == ""
                                 let ok="no"
                                endif
                            "    call Decho("response: ok<".ok.">")
                                let ok= substitute(ok,'\[{y(es)},n(o),a(ll),q(uit)]\s*','','e')
                            "    call Decho("response: ok<".ok."> (after sub)")
                                if ok =~ 'a\%[ll]'
                                 let all= 1
                                endif
                               endif
                            
                               if all || ok =~ 'y\%[es]' || ok == ""
                                let ret= s:NetrwDelete(rmfile)
                            "    call Decho("errcode=".v:shell_error." ret=".ret)
                               endif
                            
                              else
                               " attempt to remove directory
                               if !all
                                echohl Statement
                                call inputsave()
                                let ok= input("Confirm deletion of directory<".rmfile."> ","[{y(es)},n(o),a(ll),q(uit)] ")
                                call inputrestore()
                                let ok= substitute(ok,'\[{y(es)},n(o),a(ll),q(uit)]\s*','','e')
                                if ok == ""
                                 let ok="no"
                                endif
                                if ok =~ 'a\%[ll]'
                                 let all= 1
                                endif
                               endif
                               let rmfile= substitute(rmfile,'[\/]$','','e')
                            
                               if all || ok =~ 'y\%[es]' || ok == ""
                            "    call Decho("1st attempt: system(netrw#WinPath(".g:netrw_localrmdir.') '.shellescape(rmfile).')')
                                call system(netrw#WinPath(g:netrw_localrmdir).' '.shellescape(rmfile))
                            "    call Decho("v:shell_error=".v:shell_error)
                            
                                if v:shell_error != 0
                            "     call Decho("2nd attempt to remove directory<".rmfile.">")
                                 let errcode= s:NetrwDelete(rmfile)
                            "     call Decho("errcode=".errcode)
                            
                                 if errcode != 0
                                  if has("unix")
                            "       call Decho("3rd attempt to remove directory<".rmfile.">")
                                   call system("rm ".shellescape(rmfile))
                                   if v:shell_error != 0 && !exists("g:netrw_quiet")
                                    call netrw#ErrorMsg(s:ERROR,"unable to remove directory<".rmfile."> -- is it empty?",34)
                            	let ok="no"
                                   endif
                                  elseif !exists("g:netrw_quiet")
                                   call netrw#ErrorMsg(s:ERROR,"unable to remove directory<".rmfile."> -- is it empty?",35)
                                   let ok="no"
                                  endif
                                 endif
                                endif
                               endif
                              endif
                            
                            "  call Dret("s:NetrwLocalRmFile ".ok)
                              return ok
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " Support Functions: {{{1
                            
                            " ---------------------------------------------------------------------
                            " netrw#WinPath: tries to insure that the path is windows-acceptable, whether cygwin is used or not {{{2
    1              0.000004 fun! netrw#WinPath(path)
                            "  call Dfunc("netrw#WinPath(path<".a:path.">)")
                              if (!g:netrw_cygwin || &shell !~ '\%(\<bash\>\|\<zsh\>\)\%(\.exe\)\=$') && (has("win32") || has("win95") || has("win64") || has("win16"))
                               " remove cygdrive prefix, if present
                               let path = substitute(a:path,'/cygdrive/\(.\)','\1:','')
                               " remove trailing slash (Win95)
                               let path = substitute(path, '\(\\\|/\)$', '', 'g')
                               " remove escaped spaces
                               let path = substitute(path, '\ ', ' ', 'g')
                               " convert slashes to backslashes
                               let path = substitute(path, '/', '\', 'g')
                              else
                               let path= a:path
                              endif
                            "  call Dret("netrw#WinPath <".path.">")
                              return path
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " netrw#NetrwRestorePosn: restores the cursor and file position as saved by NetrwSavePosn() {{{2
    1              0.000004 fun! netrw#NetrwRestorePosn(...)
                            "  call Dfunc("netrw#NetrwRestorePosn() a:0=".a:0." winnr=".(exists("w:netrw_winnr")? w:netrw_winnr : -1)." line=".(exists("w:netrw_line")? w:netrw_line : -1)." col=".(exists("w:netrw_col")? w:netrw_col : -1)." hline=".(exists("w:netrw_hline")? w:netrw_hline : -1))
                              let eikeep= &ei
                              set ei=all
                              if expand("%") == "NetrwMessage"
                               if exists("s:winBeforeErr")
                                exe s:winBeforeErr."wincmd w"
                               endif
                              endif
                            
                              if a:0 > 0
                               exe "keepj ".a:1
                              endif
                            
                              " restore window
                              if exists("w:netrw_winnr")
                            "   call Decho("(NetrwRestorePosn) restore window: exe sil! ".w:netrw_winnr."wincmd w")
                               exe "sil! ".w:netrw_winnr."wincmd w"
                              endif
                              if v:shell_error == 0
                               " as suggested by Bram M: redraw on no error
                               " allows protocol error messages to remain visible
                            "   redraw!
                              endif
                            
                              " restore top-of-screen line
                              if exists("w:netrw_hline")
                            "   call Decho("(NetrwRestorePosn) restore topofscreen: exe keepj norm! ".w:netrw_hline."G0z")
                               exe "keepj norm! ".w:netrw_hline."G0z\<CR>"
                              endif
                            
                              " restore position
                              if exists("w:netrw_line") && exists("w:netrw_col")
                            "   call Decho("(NetrwRestorePosn) restore posn: exe keepj norm! ".w:netrw_line."G0".w:netrw_col."|")
                               exe "keepj norm! ".w:netrw_line."G0".w:netrw_col."\<bar>"
                              endif
                            
                              let &ei= eikeep
                            "  call Dret("netrw#NetrwRestorePosn : line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol())
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " netrw#NetrwSavePosn: saves position of cursor on screen {{{2
    1              0.000003 fun! netrw#NetrwSavePosn()
                            "  call Dfunc("netrw#NetrwSavePosn() line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol())
                              " Save current line and column
                              let w:netrw_winnr= winnr()
                              let w:netrw_line = line(".")
                              let w:netrw_col  = virtcol(".")
                            "  call Decho("(NetrwSavePosn) currently, win#".w:netrw_winnr." line#".w:netrw_line." col#".w:netrw_col)
                            
                              " Save top-of-screen line
                              keepj norm! H0
                              let w:netrw_hline= line(".")
                            
                              " set up string holding position parameters
                              let ret          = "let w:netrw_winnr=".w:netrw_winnr."|let w:netrw_line=".w:netrw_line."|let w:netrw_col=".w:netrw_col."|let w:netrw_hline=".w:netrw_hline
                            
                              keepj call netrw#NetrwRestorePosn()
                            "  call Dret("netrw#NetrwSavePosn : winnr=".w:netrw_winnr." line=".w:netrw_line." col=".w:netrw_col." hline=".w:netrw_hline)
                              return ret
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " netrw#NetrwAccess: intended to provide access to variable values for netrw's test suite {{{2
                            "   0: marked file list of current buffer
                            "   1: marked file target
    1              0.000004 fun! netrw#NetrwAccess(ilist)
                              if     a:ilist == 0
                               if exists("s:netrwmarkfilelist_".bufnr('%'))
                                return s:netrwmarkfilelist_{bufnr('%')}
                               else
                                return "no-list-buf#".bufnr('%')
                               endif
                              elseif a:ilist == 1
                               return s:netrwmftgt
                            endfun
                            
                            " ------------------------------------------------------------------------
                            "  netrw#RFC2396: converts %xx into characters {{{2
    1              0.000003 fun! netrw#RFC2396(fname)
                            "  call Dfunc("netrw#RFC2396(fname<".a:fname.">)")
                              let fname = escape(substitute(a:fname,'%\(\x\x\)','\=nr2char("0x".submatch(1))','ge')," \t")
                            "  call Dret("netrw#RFC2396 ".fname)
                              return fname
                            endfun
                            
                            " ---------------------------------------------------------------------
                            "  s:ComposePath: Appends a new part to a path taking different systems into consideration {{{2
    1              0.000003 fun! s:ComposePath(base,subdir)
                            "  call Dfunc("s:ComposePath(base<".a:base."> subdir<".a:subdir.">)")
                            
                              if has("amiga")
                            "   call Decho("amiga")
                               let ec = a:base[s:Strlen(a:base)-1]
                               if ec != '/' && ec != ':'
                                let ret = a:base . "/" . a:subdir
                               else
                                let ret = a:base . a:subdir
                               endif
                            
                              elseif a:subdir =~ '^\a:[/\\][^/\\]' && (has("win32") || has("win95") || has("win64") || has("win16"))
                            "   call Decho("windows")
                               let ret= a:subdir
                            
                              elseif a:base =~ '^\a:[/\\][^/\\]' && (has("win32") || has("win95") || has("win64") || has("win16"))
                            "   call Decho("windows")
                               if a:base =~ '[/\\]$'
                                let ret= a:base.a:subdir
                               else
                                let ret= a:base."/".a:subdir
                               endif
                            
                              elseif a:base =~ '^\a\+://'
                            "   call Decho("remote linux/macos")
                               let urlbase = substitute(a:base,'^\(\a\+://.\{-}/\)\(.*\)$','\1','')
                               let curpath = substitute(a:base,'^\(\a\+://.\{-}/\)\(.*\)$','\2','')
                               if a:subdir == '../'
                                if curpath =~ '[^/]/[^/]\+/$'
                                 let curpath= substitute(curpath,'[^/]\+/$','','')
                                else
                                 let curpath=""
                                endif
                                let ret= urlbase.curpath
                               else
                                let ret= urlbase.curpath.a:subdir
                               endif
                            "   call Decho("urlbase<".urlbase.">")
                            "   call Decho("curpath<".curpath.">")
                            "   call Decho("ret<".ret.">")
                            
                              else
                            "   call Decho("local linux/macos")
                               let ret = substitute(a:base."/".a:subdir,"//","/","g")
                               if a:base =~ '^//'
                                " keeping initial '//' for the benefit of network share listing support
                                let ret= '/'.ret
                               endif
                               let ret= simplify(ret)
                              endif
                            
                            "  call Dret("s:ComposePath ".ret)
                              return ret
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:FileReadable: o/s independent filereadable {{{2
    1              0.000003 fun! s:FileReadable(fname)
                            "  call Dfunc("s:FileReadable(fname<".a:fname.">)")
                            
                              if g:netrw_cygwin
                               let ret= filereadable(substitute(a:fname,'/cygdrive/\(.\)','\1:/',''))
                              else
                               let ret= filereadable(a:fname)
                              endif
                            
                            "  call Dret("s:FileReadable ".ret)
                              return ret
                            endfun
                            
                            " ---------------------------------------------------------------------
                            "  s:GetTempfile: gets a tempname that'll work for various o/s's {{{2
                            "                 Places correct suffix on end of temporary filename,
                            "                 using the suffix provided with fname
    1              0.000002 fun! s:GetTempfile(fname)
                            "  call Dfunc("s:GetTempfile(fname<".a:fname.">)")
                            
                              if !exists("b:netrw_tmpfile")
                               " get a brand new temporary filename
                               let tmpfile= tempname()
                            "   call Decho("tmpfile<".tmpfile."> : from tempname()")
                            
                               let tmpfile= substitute(tmpfile,'\','/','ge')
                            "   call Decho("tmpfile<".tmpfile."> : chgd any \\ -> /")
                            
                               " sanity check -- does the temporary file's directory exist?
                               if !isdirectory(substitute(tmpfile,'[^/]\+$','','e'))
                            "    call Decho("(GetTempfile) ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
                                keepj call netrw#ErrorMsg(s:ERROR,"your <".substitute(tmpfile,'[^/]\+$','','e')."> directory is missing!",2)
                            "    call Dret("s:GetTempfile getcwd<".getcwd().">")
                                return ""
                               endif
                            
                               " let netrw#NetSource() know about the tmpfile
                               let s:netrw_tmpfile= tmpfile " used by netrw#NetSource() and netrw#NetrwBrowseX()
                            "   call Decho("tmpfile<".tmpfile."> s:netrw_tmpfile<".s:netrw_tmpfile.">")
                            
                               " o/s dependencies
                               if g:netrw_cygwin != 0
                                let tmpfile = substitute(tmpfile,'^\(\a\):','/cygdrive/\1','e')
                               elseif has("win32") || has("win95") || has("win64") || has("win16")
                                if !exists("+shellslash") || !&ssl
                                 let tmpfile = substitute(tmpfile,'/','\','g')
                                endif
                               else
                                let tmpfile = tmpfile
                               endif
                               let b:netrw_tmpfile= tmpfile
                            "   call Decho("o/s dependent fixed tempname<".tmpfile.">")
                              else
                               " re-use temporary filename
                               let tmpfile= b:netrw_tmpfile
                            "   call Decho("tmpfile<".tmpfile."> re-using")
                              endif
                            
                              " use fname's suffix for the temporary file
                              if a:fname != ""
                               if a:fname =~ '\.[^./]\+$'
                            "    call Decho("using fname<".a:fname.">'s suffix")
                                if a:fname =~ '\.tar\.gz$' || a:fname =~ '\.tar\.bz2$' || a:fname =~ '\.tar\.xz$'
                                 let suffix = ".tar".substitute(a:fname,'^.*\(\.[^./]\+\)$','\1','e')
                                elseif a:fname =~ '.txz$'
                                 let suffix = ".txz".substitute(a:fname,'^.*\(\.[^./]\+\)$','\1','e')
                                else
                                 let suffix = substitute(a:fname,'^.*\(\.[^./]\+\)$','\1','e')
                                endif
                            "    call Decho("suffix<".suffix.">")
                                let tmpfile= substitute(tmpfile,'\.tmp$','','e')
                            "    call Decho("chgd tmpfile<".tmpfile."> (removed any .tmp suffix)")
                                let tmpfile .= suffix
                            "    call Decho("chgd tmpfile<".tmpfile."> (added ".suffix." suffix) netrw_fname<".b:netrw_fname.">")
                                let s:netrw_tmpfile= tmpfile " supports netrw#NetSource()
                               endif
                              endif
                            
                            "  call Decho("(GetTempFile) ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
                            "  call Dret("s:GetTempfile <".tmpfile.">")
                              return tmpfile
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:MakeSshCmd: transforms input command using USEPORT HOSTNAME into {{{2
                            "               a correct command for use with a system() call
    1              0.000003 fun! s:MakeSshCmd(sshcmd)
                            "  call Dfunc("s:MakeSshCmd(sshcmd<".a:sshcmd.">) user<".s:user."> machine<".s:machine.">")
                              let sshcmd = substitute(a:sshcmd,'\<HOSTNAME\>',s:user.s:machine,'')
                              if exists("g:netrw_port") && g:netrw_port != ""
                               let sshcmd= substitute(sshcmd,"USEPORT",g:netrw_sshport.' '.g:netrw_port,'')
                              elseif exists("s:port") && s:port != ""
                               let sshcmd= substitute(sshcmd,"USEPORT",g:netrw_sshport.' '.s:port,'')
                              else
                               let sshcmd= substitute(sshcmd,"USEPORT ",'','')
                              endif
                            "  call Dret("s:MakeSshCmd <".sshcmd.">")
                              return sshcmd
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwBMShow: {{{2
    1              0.000002 fun! s:NetrwBMShow()
                            "  call Dfunc("s:NetrwBMShow()")
                              redir => bmshowraw
                               menu
                              redir END
                              let bmshowlist = split(bmshowraw,'\n')
                              if bmshowlist != []
                               let bmshowfuncs= filter(bmshowlist,'v:val =~ "<SNR>\\d\\+_BMShow()"')
                               if bmshowfuncs != []
                                let bmshowfunc = substitute(bmshowfuncs[0],'^.*:\(call.*BMShow()\).*$','\1','')
                                if bmshowfunc =~ '^call.*BMShow()'
                                 exe "sil! keepj ".bmshowfunc
                                endif
                               endif
                              endif
                            "  call Dret("s:NetrwBMShow : bmshowfunc<".(exists("bmshowfunc")? bmshowfunc : 'n/a').">")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwCursor: responsible for setting cursorline/cursorcolumn based upon g:netrw_cursor {{{2
    1              0.000002 fun! s:NetrwCursor()
                              if !exists("w:netrw_liststyle")
                               let w:netrw_liststyle= g:netrw_liststyle
                              endif
                            "  call Dfunc("s:NetrwCursor() ft<".&ft."> liststyle=".w:netrw_liststyle." g:netrw_cursor=".g:netrw_cursor." s:netrw_usercuc=".s:netrw_usercuc." s:netrw_usercul=".s:netrw_usercul)
                            
                              if &ft != "netrw"
                               " if the current window isn't a netrw directory listing window, then use user cursorline/column
                               " settings.  Affects when netrw is used to read/write a file using scp/ftp/etc.
                            "   call Decho("case ft!=netrw: use user cul,cuc")
                               let &l:cursorline   = s:netrw_usercul
                               let &l:cursorcolumn = s:netrw_usercuc
                            
                              elseif g:netrw_cursor == 4
                               " all styles: cursorline, cursorcolumn
                            "   call Decho("case g:netrw_cursor==4: setl cul cuc")
                               setl cursorline
                               setl cursorcolumn
                            
                              elseif g:netrw_cursor == 3
                               " thin-long-tree: cursorline, user's cursorcolumn
                               " wide          : cursorline, cursorcolumn
                               if w:netrw_liststyle == s:WIDELIST
                            "    call Decho("case g:netrw_cursor==3 and wide: setl cul cuc")
                                setl cursorline
                                setl cursorcolumn
                               else
                            "    call Decho("case g:netrw_cursor==3 and not wide: setl cul (use user's cuc)")
                                setl cursorline
                                let &l:cursorcolumn   = s:netrw_usercuc
                               endif
                            
                              elseif g:netrw_cursor == 2
                               " thin-long-tree: cursorline, user's cursorcolumn
                               " wide          : cursorline, user's cursorcolumn
                            "   call Decho("case g:netrw_cursor==2: setl cuc (use user's cul)")
                               let &l:cursorcolumn = s:netrw_usercuc
                               setl cursorline
                            
                              elseif g:netrw_cursor == 1
                               " thin-long-tree: user's cursorline, user's cursorcolumn
                               " wide          : cursorline,        user's cursorcolumn
                               let &l:cursorcolumn = s:netrw_usercuc
                               if w:netrw_liststyle == s:WIDELIST
                            "    call Decho("case g:netrw_cursor==2 and wide: setl cul (use user's cuc)")
                                set cursorline
                               else
                            "    call Decho("case g:netrw_cursor==2 and not wide: (use user's cul,cuc)")
                                let &l:cursorline   = s:netrw_usercul
                               endif
                            
                              else
                               " all styles: user's cursorline, user's cursorcolumn
                            "   call Decho("default: (use user's cul,cuc)")
                               let &l:cursorline   = s:netrw_usercul
                               let &l:cursorcolumn = s:netrw_usercuc
                              endif
                            
                            "  call Dret("s:NetrwCursor : l:cursorline=".&l:cursorline." l:cursorcolumn=".&l:cursorcolumn)
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:RestoreCursorline: restores cursorline/cursorcolumn to original user settings {{{2
    1              0.000005 fun! s:RestoreCursorline()
                            "  call Dfunc("s:RestoreCursorline() currently, cul=".&l:cursorline." cuc=".&l:cursorcolumn." win#".winnr()." buf#".bufnr("%")." mod=".&mod)
                              if exists("s:netrw_usercul")
                               let &l:cursorline   = s:netrw_usercul
                              endif
                              if exists("s:netrw_usercuc")
                               let &l:cursorcolumn = s:netrw_usercuc
                              endif
                            "  call Dret("s:RestoreCursorline : restored cul=".&l:cursorline." cuc=".&l:cursorcolumn)
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwDelete: Deletes a file. {{{2
                            "           Uses Steve Hall's idea to insure that Windows paths stay
                            "           acceptable.  No effect on Unix paths.
                            "  Examples of use:  let result= s:NetrwDelete(path)
    1              0.000006 fun! s:NetrwDelete(path)
                            "  call Dfunc("s:NetrwDelete(path<".a:path.">)")
                            
                              let path = netrw#WinPath(a:path)
                              if !g:netrw_cygwin && (has("win32") || has("win95") || has("win64") || has("win16"))
                               if exists("+shellslash")
                                let sskeep= &shellslash
                                setl noshellslash
                                let result      = delete(path)
                                let &shellslash = sskeep
                               else
                            "    call Decho("exe let result= ".a:cmd."('".path."')")
                                let result= delete(path)
                               endif
                              else
                            "   call Decho("let result= delete(".path.")")
                               let result= delete(path)
                              endif
                              if result < 0
                               keepj call netrw#ErrorMsg(s:WARNING,"delete(".path.") failed!",71)
                              endif
                            
                            "  call Dret("s:NetrwDelete ".result)
                              return result
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwEnew: opens a new buffer, passes netrw buffer variables through {{{2
    1              0.000003 fun! s:NetrwEnew(...)
                            "  call Dfunc("s:NetrwEnew() a:0=".a:0." bufnr($)=".bufnr("$"))
                            "  call Decho("curdir<".((a:0>0)? a:1 : "")."> buf#".bufnr("%")."<".bufname("%").">")
                            
                              " grab a function-local-variable copy of buffer variables
                            "  call Decho("make function-local copy of netrw variables")
                              if exists("b:netrw_bannercnt")      |let netrw_bannercnt       = b:netrw_bannercnt      |endif
                              if exists("b:netrw_browser_active") |let netrw_browser_active  = b:netrw_browser_active |endif
                              if exists("b:netrw_cpf")            |let netrw_cpf             = b:netrw_cpf            |endif
                              if exists("b:netrw_curdir")         |let netrw_curdir          = b:netrw_curdir         |endif
                              if exists("b:netrw_explore_bufnr")  |let netrw_explore_bufnr   = b:netrw_explore_bufnr  |endif
                              if exists("b:netrw_explore_indx")   |let netrw_explore_indx    = b:netrw_explore_indx   |endif
                              if exists("b:netrw_explore_line")   |let netrw_explore_line    = b:netrw_explore_line   |endif
                              if exists("b:netrw_explore_list")   |let netrw_explore_list    = b:netrw_explore_list   |endif
                              if exists("b:netrw_explore_listlen")|let netrw_explore_listlen = b:netrw_explore_listlen|endif
                              if exists("b:netrw_explore_mtchcnt")|let netrw_explore_mtchcnt = b:netrw_explore_mtchcnt|endif
                              if exists("b:netrw_fname")          |let netrw_fname           = b:netrw_fname          |endif
                              if exists("b:netrw_lastfile")       |let netrw_lastfile        = b:netrw_lastfile       |endif
                              if exists("b:netrw_liststyle")      |let netrw_liststyle       = b:netrw_liststyle      |endif
                              if exists("b:netrw_method")         |let netrw_method          = b:netrw_method         |endif
                              if exists("b:netrw_option")         |let netrw_option          = b:netrw_option         |endif
                              if exists("b:netrw_prvdir")         |let netrw_prvdir          = b:netrw_prvdir         |endif
                            
                              keepj call s:NetrwOptionRestore("w:")
                            "  call Decho("generate a buffer with keepjumps keepalt enew!")
                              let netrw_keepdiff= &l:diff
                              keepj keepalt enew!
                              let &l:diff= netrw_keepdiff
                            "  call Decho("bufnr($)=".bufnr("$"))
                              keepj call s:NetrwOptionSave("w:")
                            
                              " copy function-local-variables to buffer variable equivalents
                            "  call Decho("copy function-local variables back to buffer netrw variables")
                              if exists("netrw_bannercnt")      |let b:netrw_bannercnt       = netrw_bannercnt      |endif
                              if exists("netrw_browser_active") |let b:netrw_browser_active  = netrw_browser_active |endif
                              if exists("netrw_cpf")            |let b:netrw_cpf             = netrw_cpf            |endif
                              if exists("netrw_curdir")         |let b:netrw_curdir          = netrw_curdir         |endif
                              if exists("netrw_explore_bufnr")  |let b:netrw_explore_bufnr   = netrw_explore_bufnr  |endif
                              if exists("netrw_explore_indx")   |let b:netrw_explore_indx    = netrw_explore_indx   |endif
                              if exists("netrw_explore_line")   |let b:netrw_explore_line    = netrw_explore_line   |endif
                              if exists("netrw_explore_list")   |let b:netrw_explore_list    = netrw_explore_list   |endif
                              if exists("netrw_explore_listlen")|let b:netrw_explore_listlen = netrw_explore_listlen|endif
                              if exists("netrw_explore_mtchcnt")|let b:netrw_explore_mtchcnt = netrw_explore_mtchcnt|endif
                              if exists("netrw_fname")          |let b:netrw_fname           = netrw_fname          |endif
                              if exists("netrw_lastfile")       |let b:netrw_lastfile        = netrw_lastfile       |endif
                              if exists("netrw_liststyle")      |let b:netrw_liststyle       = netrw_liststyle      |endif
                              if exists("netrw_method")         |let b:netrw_method          = netrw_method         |endif
                              if exists("netrw_option")         |let b:netrw_option          = netrw_option         |endif
                              if exists("netrw_prvdir")         |let b:netrw_prvdir          = netrw_prvdir         |endif
                            
                              if a:0 > 0
                               let b:netrw_curdir= a:1
                               if b:netrw_curdir =~ '/$'
                                if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST
                                 file NetrwTreeListing
                                 set bt=nowrite noswf bh=hide
                                 nno <silent> <buffer> [	:sil call <SID>TreeListMove('[')<cr>
                                 nno <silent> <buffer> ]	:sil call <SID>TreeListMove(']')<cr>
                                else
                                 exe "sil! keepalt file ".fnameescape(b:netrw_curdir)
                                endif
                               endif
                              endif
                            
                            "  call Dret("s:NetrwEnew : buf#".bufnr("%")."<".bufname("%")."> expand(%)<".expand("%")."> expand(#)<".expand("#")."> bh=".&bh)
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwInsureWinVars: insure that a netrw buffer has its w: variables in spite of a wincmd v or s {{{2
    1              0.000005 fun! s:NetrwInsureWinVars()
                            "  call Dfunc("s:NetrwInsureWinVars() win#".winnr())
                              if !exists("w:netrw_liststyle")
                               let curbuf = bufnr("%")
                               let curwin = winnr()
                               let iwin   = 1
                               while iwin <= winnr("$")
                                exe iwin."wincmd w"
                                if winnr() != curwin && bufnr("%") == curbuf && exists("w:netrw_liststyle")
                                 " looks like ctrl-w_s or ctrl-w_v was used to split a netrw buffer
                                 let winvars= w:
                                 break
                                endif
                                let iwin= iwin + 1
                               endwhile
                               exe "keepalt ".curwin."wincmd w"
                               if exists("winvars")
                            "    call Decho("copying w#".iwin." window variables to w#".curwin)
                                for k in keys(winvars)
                                 let w:{k}= winvars[k]
                                endfor
                               endif
                              endif
                            "  call Dret("s:NetrwInsureWinVars win#".winnr())
                            endfun
                            
                            " ------------------------------------------------------------------------
                            " s:NetrwSaveWordPosn: used to keep cursor on same word after refresh, {{{2
                            " changed sorting, etc.  Also see s:NetrwRestoreWordPosn().
    1              0.000004 fun! s:NetrwSaveWordPosn()
                            "  call Dfunc("NetrwSaveWordPosn()")
                              let s:netrw_saveword= '^'.fnameescape(getline('.')).'$'
                            "  call Dret("NetrwSaveWordPosn : saveword<".s:netrw_saveword.">")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:NetrwRestoreWordPosn: used to keep cursor on same word after refresh, {{{2
                            "  changed sorting, etc.  Also see s:NetrwSaveWordPosn().
    1              0.000003 fun! s:NetrwRestoreWordPosn()
                            "  call Dfunc("NetrwRestoreWordPosn()")
                              sil! call search(s:netrw_saveword,'w')
                            "  call Dret("NetrwRestoreWordPosn")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:RestoreBufVars: {{{2
    1              0.000004 fun! s:RestoreBufVars()
                            "  call Dfunc("s:RestoreBufVars()")
                            
                              if exists("s:netrw_curdir")        |let b:netrw_curdir         = s:netrw_curdir        |endif
                              if exists("s:netrw_lastfile")      |let b:netrw_lastfile       = s:netrw_lastfile      |endif
                              if exists("s:netrw_method")        |let b:netrw_method         = s:netrw_method        |endif
                              if exists("s:netrw_fname")         |let b:netrw_fname          = s:netrw_fname         |endif
                              if exists("s:netrw_machine")       |let b:netrw_machine        = s:netrw_machine       |endif
                              if exists("s:netrw_browser_active")|let b:netrw_browser_active = s:netrw_browser_active|endif
                            
                            "  call Dret("s:RestoreBufVars")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:RemotePathAnalysis: {{{2
    1              0.000005 fun! s:RemotePathAnalysis(dirname)
                            "  call Dfunc("s:RemotePathAnalysis(a:dirname<".a:dirname.">)")
                            
                              let dirpat  = '^\(\w\{-}\)://\(\w\+@\)\=\([^/:#]\+\)\%([:#]\(\d\+\)\)\=/\(.*\)$'
                              let s:method  = substitute(a:dirname,dirpat,'\1','')
                              let s:user    = substitute(a:dirname,dirpat,'\2','')
                              let s:machine = substitute(a:dirname,dirpat,'\3','')
                              let s:port    = substitute(a:dirname,dirpat,'\4','')
                              let s:path    = substitute(a:dirname,dirpat,'\5','')
                              let s:fname   = substitute(a:dirname,'^.*/\ze.','','')
                            
                            "  call Decho("set up s:method <".s:method .">")
                            "  call Decho("set up s:user   <".s:user   .">")
                            "  call Decho("set up s:machine<".s:machine.">")
                            "  call Decho("set up s:port   <".s:port.">")
                            "  call Decho("set up s:path   <".s:path   .">")
                            "  call Decho("set up s:fname  <".s:fname  .">")
                            
                            "  call Dret("s:RemotePathAnalysis")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:RemoteSystem: runs a command on a remote host using ssh {{{2
                            "                 Returns status
                            " Runs system() on
                            "    [cd REMOTEDIRPATH;] a:cmd
                            " Note that it doesn't do shellescape(a:cmd)!
    1              0.000003 fun! s:RemoteSystem(cmd)
                            "  call Dfunc("s:RemoteSystem(cmd<".a:cmd.">)")
                              if !executable(g:netrw_ssh_cmd)
                               keepj call netrw#ErrorMsg(s:ERROR,"g:netrw_ssh_cmd<".g:netrw_ssh_cmd."> is not executable!",52)
                              elseif !exists("b:netrw_curdir")
                               keepj call netrw#ErrorMsg(s:ERROR,"for some reason b:netrw_curdir doesn't exist!",53)
                              else
                               let cmd      = s:MakeSshCmd(g:netrw_ssh_cmd." USEPORT HOSTNAME")
                               let remotedir= substitute(b:netrw_curdir,'^.*//[^/]\+/\(.*\)$','\1','')
                               if remotedir != ""
                                let cmd= cmd.' cd '.shellescape(remotedir).";"
                               else
                                let cmd= cmd.' '
                               endif
                               let cmd= cmd.a:cmd
                            "   call Decho("call system(".cmd.")")
                               let ret= system(cmd)
                              endif
                            "  call Dret("s:RemoteSystem ".ret)
                              return ret
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:RestoreWinVars: (used by Explore() and NetrwSplit()) {{{2
    1              0.000002 fun! s:RestoreWinVars()
                            "  call Dfunc("s:RestoreWinVars()")
                              if exists("s:bannercnt")      |let w:netrw_bannercnt       = s:bannercnt      |unlet s:bannercnt      |endif
                              if exists("s:col")            |let w:netrw_col             = s:col            |unlet s:col            |endif
                              if exists("s:curdir")         |let w:netrw_curdir          = s:curdir         |unlet s:curdir         |endif
                              if exists("s:explore_bufnr")  |let w:netrw_explore_bufnr   = s:explore_bufnr  |unlet s:explore_bufnr  |endif
                              if exists("s:explore_indx")   |let w:netrw_explore_indx    = s:explore_indx   |unlet s:explore_indx   |endif
                              if exists("s:explore_line")   |let w:netrw_explore_line    = s:explore_line   |unlet s:explore_line   |endif
                              if exists("s:explore_listlen")|let w:netrw_explore_listlen = s:explore_listlen|unlet s:explore_listlen|endif
                              if exists("s:explore_list")   |let w:netrw_explore_list    = s:explore_list   |unlet s:explore_list   |endif
                              if exists("s:explore_mtchcnt")|let w:netrw_explore_mtchcnt = s:explore_mtchcnt|unlet s:explore_mtchcnt|endif
                              if exists("s:fpl")            |let w:netrw_fpl             = s:fpl            |unlet s:fpl            |endif
                              if exists("s:hline")          |let w:netrw_hline           = s:hline          |unlet s:hline          |endif
                              if exists("s:line")           |let w:netrw_line            = s:line           |unlet s:line           |endif
                              if exists("s:liststyle")      |let w:netrw_liststyle       = s:liststyle      |unlet s:liststyle      |endif
                              if exists("s:method")         |let w:netrw_method          = s:method         |unlet s:method         |endif
                              if exists("s:prvdir")         |let w:netrw_prvdir          = s:prvdir         |unlet s:prvdir         |endif
                              if exists("s:treedict")       |let w:netrw_treedict        = s:treedict       |unlet s:treedict       |endif
                              if exists("s:treetop")        |let w:netrw_treetop         = s:treetop        |unlet s:treetop        |endif
                              if exists("s:winnr")          |let w:netrw_winnr           = s:winnr          |unlet s:winnr          |endif
                            "  call Dret("s:RestoreWinVars")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:Rexplore: implements returning from a buffer to a netrw directory {{{2
                            "
                            "             s:SetRexDir() sets up <2-leftmouse> maps (if g:netrw_retmap
                            "             is true) and a command, :Rexplore, which call this function.
                            "
                            "             s:nbcd_curpos_{bufnr('%')} is set up by s:NetrwBrowseChgDir()
    1              0.000004 fun! s:NetrwRexplore(islocal,dirname)
                              if exists("s:netrwdrag")
                               return
                              endif
                            "  call Dfunc("s:NetrwRexplore() w:netrw_rexlocal=".w:netrw_rexlocal." w:netrw_rexdir<".w:netrw_rexdir.">")
                              if !exists("w:netrw_rexlocal")
                            "   "   call Dret("s:NetrwRexplore() w:netrw_rexlocal doesn't exist")
                               return
                              endif
                              if w:netrw_rexlocal
                               keepj call netrw#LocalBrowseCheck(w:netrw_rexdir)
                              else
                               keepj call s:NetrwBrowse(0,w:netrw_rexdir)
                              endif
                              if exists("s:initbeval")
                               set beval
                              endif
                              if exists("s:rexposn_".bufnr("%"))
                            "   call Decho("(NetrwRexplore) restore posn, then unlet s:rexposn_".bufnr('%'))
                               keepj call netrw#NetrwRestorePosn(s:rexposn_{bufnr('%')})
                               unlet s:rexposn_{bufnr('%')}
                              else
                            "   call Decho("(NetrwRexplore) s:rexposn_".bufnr('%')." doesn't exist")
                              endif
                              if exists("s:explore_match")
                               exe "2match netrwMarkFile /".s:explore_match."/"
                              endif
                            "  call Dret("s:NetrwRexplore")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:SaveBufVars: {{{2
    1              0.000003 fun! s:SaveBufVars()
                            "  call Dfunc("s:SaveBufVars() buf#".bufnr("%"))
                            
                              if exists("b:netrw_curdir")        |let s:netrw_curdir         = b:netrw_curdir        |endif
                              if exists("b:netrw_lastfile")      |let s:netrw_lastfile       = b:netrw_lastfile      |endif
                              if exists("b:netrw_method")        |let s:netrw_method         = b:netrw_method        |endif
                              if exists("b:netrw_fname")         |let s:netrw_fname          = b:netrw_fname         |endif
                              if exists("b:netrw_machine")       |let s:netrw_machine        = b:netrw_machine       |endif
                              if exists("b:netrw_browser_active")|let s:netrw_browser_active = b:netrw_browser_active|endif
                            
                            "  call Dret("s:SaveBufVars")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:SaveWinVars: (used by Explore() and NetrwSplit()) {{{2
    1              0.000002 fun! s:SaveWinVars()
                            "  call Dfunc("s:SaveWinVars() win#".winnr())
                              if exists("w:netrw_bannercnt")      |let s:bannercnt       = w:netrw_bannercnt      |endif
                              if exists("w:netrw_col")            |let s:col             = w:netrw_col            |endif
                              if exists("w:netrw_curdir")         |let s:curdir          = w:netrw_curdir         |endif
                              if exists("w:netrw_explore_bufnr")  |let s:explore_bufnr   = w:netrw_explore_bufnr  |endif
                              if exists("w:netrw_explore_indx")   |let s:explore_indx    = w:netrw_explore_indx   |endif
                              if exists("w:netrw_explore_line")   |let s:explore_line    = w:netrw_explore_line   |endif
                              if exists("w:netrw_explore_listlen")|let s:explore_listlen = w:netrw_explore_listlen|endif
                              if exists("w:netrw_explore_list")   |let s:explore_list    = w:netrw_explore_list   |endif
                              if exists("w:netrw_explore_mtchcnt")|let s:explore_mtchcnt = w:netrw_explore_mtchcnt|endif
                              if exists("w:netrw_fpl")            |let s:fpl             = w:netrw_fpl            |endif
                              if exists("w:netrw_hline")          |let s:hline           = w:netrw_hline          |endif
                              if exists("w:netrw_line")           |let s:line            = w:netrw_line           |endif
                              if exists("w:netrw_liststyle")      |let s:liststyle       = w:netrw_liststyle      |endif
                              if exists("w:netrw_method")         |let s:method          = w:netrw_method         |endif
                              if exists("w:netrw_prvdir")         |let s:prvdir          = w:netrw_prvdir         |endif
                              if exists("w:netrw_treedict")       |let s:treedict        = w:netrw_treedict       |endif
                              if exists("w:netrw_treetop")        |let s:treetop         = w:netrw_treetop        |endif
                              if exists("w:netrw_winnr")          |let s:winnr           = w:netrw_winnr          |endif
                            "  call Dret("s:SaveWinVars")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:SetBufWinVars: (used by NetrwBrowse() and LocalBrowseCheck()) {{{2
                            "   To allow separate windows to have their own activities, such as
                            "   Explore **/pattern, several variables have been made window-oriented.
                            "   However, when the user splits a browser window (ex: ctrl-w s), these
                            "   variables are not inherited by the new window.  SetBufWinVars() and
                            "   UseBufWinVars() get around that.
    1              0.000002 fun! s:SetBufWinVars()
                            "  call Dfunc("s:SetBufWinVars() win#".winnr())
                              if exists("w:netrw_liststyle")      |let b:netrw_liststyle      = w:netrw_liststyle      |endif
                              if exists("w:netrw_bannercnt")      |let b:netrw_bannercnt      = w:netrw_bannercnt      |endif
                              if exists("w:netrw_method")         |let b:netrw_method         = w:netrw_method         |endif
                              if exists("w:netrw_prvdir")         |let b:netrw_prvdir         = w:netrw_prvdir         |endif
                              if exists("w:netrw_explore_indx")   |let b:netrw_explore_indx   = w:netrw_explore_indx   |endif
                              if exists("w:netrw_explore_listlen")|let b:netrw_explore_listlen= w:netrw_explore_listlen|endif
                              if exists("w:netrw_explore_mtchcnt")|let b:netrw_explore_mtchcnt= w:netrw_explore_mtchcnt|endif
                              if exists("w:netrw_explore_bufnr")  |let b:netrw_explore_bufnr  = w:netrw_explore_bufnr  |endif
                              if exists("w:netrw_explore_line")   |let b:netrw_explore_line   = w:netrw_explore_line   |endif
                              if exists("w:netrw_explore_list")   |let b:netrw_explore_list   = w:netrw_explore_list   |endif
                            "  call Dret("s:SetBufWinVars")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:SetRexDir: set directory for :Rexplore {{{2
    1              0.000003 fun! s:SetRexDir(islocal,dirname)
                            "  call Dfunc("s:SetRexDir(islocal=".a:islocal." dirname<".a:dirname.">)")
                              let w:netrw_rexdir   = a:dirname
                              let w:netrw_rexlocal = a:islocal
                            "  call Dret("s:SetRexDir : win#".winnr()." ".(a:islocal? "local" : "remote")." dir: ".a:dirname)
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:Strlen: this function returns the length of a string, even if its {{{2
                            "           using multiple-byte characters.
                            "           Solution from Nicolai Weibull, vim docs (:help strlen()), Tony Mechelynck,
                            "           and a bit from me.
                            "           if g:netrw_xstrlen is zero (default), then the builtin strlen() function is used.
    1              0.000002 fun! s:Strlen(x)
                            "  call Dfunc("s:Strlen(x<".a:x.">")
                              if g:netrw_xstrlen == 1
                               " number of codepoints (Latin a + combining circumflex is two codepoints)
                               " (comment from TM, solution from NW)
                               let ret= strlen(substitute(a:x,'.','c','g'))
                            
                              elseif g:netrw_xstrlen == 2
                               " number of spacing codepoints (Latin a + combining circumflex is one spacing 
                               " codepoint; a hard tab is one; wide and narrow CJK are one each; etc.)
                               " (comment from TM, solution from TM)
                               let ret=strlen(substitute(a:x, '.\Z', 'x', 'g')) 
                            
                              elseif g:netrw_xstrlen == 3
                               " virtual length (counting, for instance, tabs as anything between 1 and 
                               " 'tabstop', wide CJK as 2 rather than 1, Arabic alif as zero when immediately 
                               " preceded by lam, one otherwise, etc.)
                               " (comment from TM, solution from me)
                               let modkeep= &mod
                               exe "keepj norm! o\<esc>"
                               call setline(line("."),a:x)
                               let ret= virtcol("$") - 1
                               keepj d
                               keepj norm! k
                               let &mod= modkeep
                            
                              else
                               " at least give a decent default
                               let ret= strlen(a:x)
                              endif
                            "  call Dret("s:Strlen ".ret)
                              return ret
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:TreeListMove: {{{2
    1              0.000003 fun! s:TreeListMove(dir)
                            "  call Dfunc("s:TreeListMove(dir<".a:dir.">)")
                              let curline  = getline('.')
                              let prvline  = (line(".") > 1)?         getline(line(".")-1) : ''
                              let nxtline  = (line(".") < line("$"))? getline(line(".")+1) : ''
                              let curindent= substitute(curline,'^\([| ]*\).\{-}$','\1','')
                              let indentm1 = substitute(curindent,'^| ','','')
                            "  call Decho("prvline  <".prvline."> #".line(".")-1)
                            "  call Decho("curline  <".curline."> #".line("."))
                            "  call Decho("nxtline  <".nxtline."> #".line(".")+1)
                            "  call Decho("curindent<".curindent.">")
                            "  call Decho("indentm1 <".indentm1.">")
                            
                              if curline !~ '/$'
                            "   call Decho('regfile')
                               if     a:dir == '[' && prvline != ''
                                keepj norm! 0
                                let nl = search('^'.indentm1.'[^|]','bWe')    " search backwards from regular file
                            "    call Decho("regfile srch back: ".nl)
                               elseif a:dir == ']' && nxtline != ''
                                keepj norm! $
                                let nl = search('^'.indentm1.'[^|]','We')     " search forwards from regular file
                            "    call Decho("regfile srch fwd: ".nl)
                               endif
                            
                              elseif a:dir == '[' && prvline != ''
                               keepj norm! 0
                               let curline= line(".")
                               let nl     = search('^'.curindent.'[^|]','bWe') " search backwards From directory, same indentation
                            "   call Decho("dir srch back ind: ".nl)
                               if nl != 0
                                if line(".") == curline-1
                                 let nl= search('^'.indentm1.'[^|]','bWe')     " search backwards from directory, indentation - 1
                            "     call Decho("dir srch back ind-1: ".nl)
                                endif
                               endif
                            
                              elseif a:dir == ']' && nxtline != ''
                               keepj norm! $
                               let curline = line(".")
                               let nl      = search('^'.curindent.'[^|]','We') " search forwards from directory, same indentation
                            "   call Decho("dir srch fwd ind: ".nl)
                               if nl != 0
                                if line(".") == curline+1
                                 let nl= search('^'.indentm1.'[^|]','We')         " search forwards from directory, indentation - 1
                            "     call Decho("dir srch fwd ind-1: ".nl)
                                endif
                               endif
                            
                              endif
                            
                            "  call Dret("s:TreeListMove")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:UpdateBuffersMenu: does emenu Buffers.Refresh (but due to locale, the menu item may not be called that) {{{2
                            "                      The Buffers.Refresh menu calls s:BMShow(); unfortunately, that means that that function
                            "                      can't be called except via emenu.  But due to locale, that menu line may not be called
                            "                      Buffers.Refresh; hence, s:NetrwBMShow() utilizes a "cheat" to call that function anyway.
    1              0.000003 fun! s:UpdateBuffersMenu()
                            "  call Dfunc("s:UpdateBuffersMenu()")
                              if has("gui") && has("menu") && has("gui_running") && &go =~# 'm' && g:netrw_menu
                               try
                                sil emenu Buffers.Refresh\ menu
                               catch /^Vim\%((\a\+)\)\=:E/
                                let v:errmsg= ""
                                sil keepj call s:NetrwBMShow()
                               endtry
                              endif
                            "  call Dret("s:UpdateBuffersMenu")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:UseBufWinVars: (used by NetrwBrowse() and LocalBrowseCheck() {{{2
                            "              Matching function to s:SetBufWinVars()
    1              0.000002 fun! s:UseBufWinVars()
                            "  call Dfunc("s:UseBufWinVars()")
                              if exists("b:netrw_liststyle")       && !exists("w:netrw_liststyle")      |let w:netrw_liststyle       = b:netrw_liststyle      |endif
                              if exists("b:netrw_bannercnt")       && !exists("w:netrw_bannercnt")      |let w:netrw_bannercnt       = b:netrw_bannercnt      |endif
                              if exists("b:netrw_method")          && !exists("w:netrw_method")         |let w:netrw_method          = b:netrw_method         |endif
                              if exists("b:netrw_prvdir")          && !exists("w:netrw_prvdir")         |let w:netrw_prvdir          = b:netrw_prvdir         |endif
                              if exists("b:netrw_explore_indx")    && !exists("w:netrw_explore_indx")   |let w:netrw_explore_indx    = b:netrw_explore_indx   |endif
                              if exists("b:netrw_explore_listlen") && !exists("w:netrw_explore_listlen")|let w:netrw_explore_listlen = b:netrw_explore_listlen|endif
                              if exists("b:netrw_explore_mtchcnt") && !exists("w:netrw_explore_mtchcnt")|let w:netrw_explore_mtchcnt = b:netrw_explore_mtchcnt|endif
                              if exists("b:netrw_explore_bufnr")   && !exists("w:netrw_explore_bufnr")  |let w:netrw_explore_bufnr   = b:netrw_explore_bufnr  |endif
                              if exists("b:netrw_explore_line")    && !exists("w:netrw_explore_line")   |let w:netrw_explore_line    = b:netrw_explore_line   |endif
                              if exists("b:netrw_explore_list")    && !exists("w:netrw_explore_list")   |let w:netrw_explore_list    = b:netrw_explore_list   |endif
                            "  call Dret("s:UseBufWinVars")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " Settings Restoration: {{{1
    1              0.000018 let &cpo= s:keepcpo
    1              0.000003 unlet s:keepcpo
                            
                            " ------------------------------------------------------------------------
                            " Modelines: {{{1
                            " vim:ts=8 fdm=marker

SCRIPT  /Users/admin/.vim/bundle/tagbar/.netrwhist
Sourced 1 time
Total time:   0.000034
 Self time:   0.000034

count  total (s)   self (s)
                            let g:netrw_dirhistmax  =10
    1              0.000004 let g:netrw_dirhist_cnt =2
    1              0.000004 let g:netrw_dirhist_1='/Users/admin'
    1              0.000007 let g:netrw_dirhist_2='/Users/admin/.vim'

SCRIPT  /Applications/MacVim.app/Contents/Resources/vim/runtime/syntax/netrw.vim
Sourced 32 times
Total time:   0.017457
 Self time:   0.017457

count  total (s)   self (s)
                            " Language   : Netrw Remote-Directory Listing Syntax
                            " Maintainer : Charles E. Campbell, Jr.
                            " Last change: Dec 18, 2012
                            " Version    : 17
                            " ---------------------------------------------------------------------
                            
                            " Syntax Clearing: {{{1
   32              0.000126 if version < 600
                             syntax clear
                            elseif exists("b:current_syntax")
                             finish
                            endif
                            
                            " ---------------------------------------------------------------------
                            " Directory List Syntax Highlighting: {{{1
   32              0.000772 syn cluster NetrwGroup		contains=netrwHide,netrwSortBy,netrwSortSeq,netrwQuickHelp,netrwVersion,netrwCopyTgt
   32              0.000336 syn cluster NetrwTreeGroup	contains=netrwDir,netrwSymLink,netrwExe
                            
   32              0.000362 syn match  netrwPlain		"\(\S\+ \)*\S\+"					contains=@NoSpell
   32              0.000468 syn match  netrwSpecial		"\%(\S\+ \)*\S\+[*|=]\ze\%(\s\{2,}\|$\)"		contains=netrwClassify,@NoSpell
   32              0.000298 syn match  netrwDir		"\.\{1,2}/"						contains=netrwClassify,@NoSpell
   32              0.000316 syn match  netrwDir		"\%(\S\+ \)*\S\+/"					contains=netrwClassify,@NoSpell
   32              0.000464 syn match  netrwSizeDate	"\<\d\+\s\d\{1,2}/\d\{1,2}/\d\{4}\s"	skipwhite	contains=netrwDateSep,@NoSpell	nextgroup=netrwTime
   32              0.000342 syn match  netrwSymLink		"\%(\S\+ \)*\S\+@\ze\%(\s\{2,}\|$\)"  			contains=netrwClassify,@NoSpell
   32              0.000349 syn match  netrwExe		"\%(\S\+ \)*\S*[^~]\*\ze\%(\s\{2,}\|$\)" 		contains=netrwClassify,@NoSpell
   32              0.000369 syn match  netrwTreeBar		"^\%([-+|] \)\+"					contains=netrwTreeBarSpace	nextgroup=@netrwTreeGroup
   32              0.000168 syn match  netrwTreeBarSpace	" "					contained
                            
   32              0.000211 syn match  netrwClassify	"[*=|@/]\ze\%(\s\{2,}\|$\)"		contained
   32              0.000191 syn match  netrwDateSep		"/"					contained
   32              0.000302 syn match  netrwTime		"\d\{1,2}:\d\{2}:\d\{2}"		contained	contains=netrwTimeSep
   32              0.000139 syn match  netrwTimeSep		":"
                            
   32              0.000250 syn match  netrwComment		'".*\%(\t\|$\)'						contains=@NetrwGroup,@NoSpell
   32              0.000330 syn match  netrwHide		'^"\s*\(Hid\|Show\)ing:'	skipwhite		contains=@NoSpell		nextgroup=netrwHidePat
   32              0.000153 syn match  netrwSlash		"/"				contained
   32              0.000293 syn match  netrwHidePat		"[^,]\+"			contained skipwhite	contains=@NoSpell		nextgroup=netrwHideSep
   32              0.000217 syn match  netrwHideSep		","				contained skipwhite					nextgroup=netrwHidePat
   32              0.000261 syn match  netrwSortBy		"Sorted by"			contained transparent skipwhite				nextgroup=netrwList
   32              0.000267 syn match  netrwSortSeq		"Sort sequence:"		contained transparent skipwhite			 	nextgroup=netrwList
   32              0.000270 syn match  netrwCopyTgt		"Copy/Move Tgt:"		contained transparent skipwhite				nextgroup=netrwList
   32              0.000288 syn match  netrwList		".*$"				contained		contains=netrwComma,@NoSpell
   32              0.000134 syn match  netrwComma		","				contained
   32              0.000913 syn region netrwQuickHelp	matchgroup=Comment start="Quick Help:\s\+" end="$"	contains=netrwHelpCmd,@NoSpell	keepend contained
   32              0.000299 syn match  netrwHelpCmd		"\S\ze:"			contained skipwhite	contains=@NoSpell		nextgroup=netrwCmdSep
   32              0.000224 syn match  netrwCmdSep		":"				contained nextgroup=netrwCmdNote
   32              0.000211 syn match  netrwCmdNote		".\{-}\ze  "			contained		contains=@NoSpell
   32              0.000202 syn match  netrwVersion		"(netrw.*)"			contained		contains=@NoSpell
                            
                            " -----------------------------
                            " Special filetype highlighting {{{1
                            " -----------------------------
   32              0.000166 if exists("g:netrw_special_syntax") && netrw_special_syntax
                             syn match netrwBak		"\(\S\+ \)*\S\+\.bak\>"				contains=netrwTreeBar,@NoSpell
                             syn match netrwCompress	"\(\S\+ \)*\S\+\.\%(gz\|bz2\|Z\|zip\)\>"	contains=netrwTreeBar,@NoSpell
                             if has("unix")
                              syn match netrwCoreDump	"\<core\%(\.\d\+\)\=\>"				contains=netrwTreeBar,@NoSpell
                             endif
                             syn match netrwLex		"\(\S\+ \)*\S\+\.\%(l\|lex\)\>"			contains=netrwTreeBar,@NoSpell
                             syn match netrwYacc		"\(\S\+ \)*\S\+\.y\>"				contains=netrwTreeBar,@NoSpell
                             syn match netrwData		"\(\S\+ \)*\S\+\.dat\>"				contains=netrwTreeBar,@NoSpell
                             syn match netrwDoc		"\(\S\+ \)*\S\+\.\%(doc\|txt\|pdf\|ps\)"	contains=netrwTreeBar,@NoSpell
                             syn match netrwHdr		"\(\S\+ \)*\S\+\.\%(h\|hpp\)\>"			contains=netrwTreeBar,@NoSpell
                             syn match netrwLib		"\(\S\+ \)*\S*\.\%(a\|so\|lib\|dll\)\>"		contains=netrwTreeBar,@NoSpell
                             syn match netrwMakeFile	"\<[mM]akefile\>\|\(\S\+ \)*\S\+\.mak\>"	contains=netrwTreeBar,@NoSpell
                             syn match netrwObj		"\(\S\+ \)*\S*\.\%(o\|obj\)\>"			contains=netrwTreeBar,@NoSpell
                             syn match netrwTags		"\<\(ANmenu\|ANtags\)\>"			contains=netrwTreeBar,@NoSpell
                             syn match netrwTags    	"\<tags\>"					contains=netrwTreeBar,@NoSpell
                             syn match netrwTilde		"\(\S\+ \)*\S\+\~\*\=\>"			contains=netrwTreeBar,@NoSpell
                             syn match netrwTmp		"\<tmp\(\S\+ \)*\S\+\>\|\(\S\+ \)*\S*tmp\>"	contains=netrwTreeBar,@NoSpell
                            endif
                            
                            " ---------------------------------------------------------------------
                            " Highlighting Links: {{{1
   32              0.000148 if !exists("did_drchip_netrwlist_syntax")
    1              0.000004  let did_drchip_netrwlist_syntax= 1
    1              0.000008  hi default link netrwClassify	Function
    1              0.000005  hi default link netrwCmdSep	Delimiter
    1              0.000005  hi default link netrwComment	Comment
    1              0.000005  hi default link netrwDir	Directory
    1              0.000005  hi default link netrwHelpCmd	Function
    1              0.000005  hi default link netrwHidePat	Statement
    1              0.000001  hi default link netrwHideSep	netrwComment
    1              0.000005  hi default link netrwList	Statement
    1              0.000005  hi default link netrwVersion	Identifier
    1              0.000006  hi default link netrwSymLink	Question
    1              0.000005  hi default link netrwExe	PreProc
    1              0.000005  hi default link netrwDateSep	Delimiter
                            
    1              0.000005  hi default link netrwTreeBar	Special
    1              0.000002  hi default link netrwTimeSep	netrwDateSep
    1              0.000002  hi default link netrwComma	netrwComment
    1              0.000001  hi default link netrwHide	netrwComment
    1              0.000010  hi default link netrwMarkFile	TabLineSel
                            
                             " special syntax highlighting (see :he g:netrw_special_syntax)
    1              0.000009  hi default link netrwBak	NonText
    1              0.000010  hi default link netrwCompress	Folded
    1              0.000010  hi default link netrwCoreDump	WarningMsg
    1              0.000010  hi default link netrwData	DiffChange
    1              0.000006  hi default link netrwHdr	netrwPlain
    1              0.000006  hi default link netrwLex	netrwPlain
    1              0.000009  hi default link netrwLib	DiffChange
    1              0.000009  hi default link netrwMakefile	DiffChange
    1              0.000018  hi default link netrwObj	Folded
    1              0.000008  hi default link netrwTilde	Folded
    1              0.000008  hi default link netrwTmp	Folded
    1              0.000009  hi default link netrwTags	Folded
    1              0.000006  hi default link netrwYacc	netrwPlain
    1              0.000001 endif
                            
                            " Current Syntax: {{{1
   32              0.000113 let   b:current_syntax = "netrwlist"
                            " ---------------------------------------------------------------------
                            " vim: ts=8 fdm=marker

SCRIPT  /Users/admin/.vim/bundle/vim-jsbeautify/plugin/beautifier.vim
Sourced 1 time
Total time:   0.002497
 Self time:   0.001346

count  total (s)   self (s)
                            "% Preliminary validation of global variables
                            "  and version of the editor.
                            
    1              0.000003 if v:version < 700
                              finish
                            endif
                            
                            " check whether this script is already loaded
    1              0.000003 if exists('g:loaded_Beautifier')
                              finish
                            endif
                            
    1              0.000002 let g:loaded_Beautifier = 1
                            
    1              0.000003 if !exists('g:config_Beautifier')
    1              0.000002   let g:config_Beautifier = {}
    1              0.000001 endif
                            
    1              0.000002 if !exists('g:editorconfig_Beautifier')
    1              0.000002   let g:editorconfig_Beautifier = ''
    1              0.000000 endif
                            
                            " temporary file for content
    1              0.000003 if !exists('g:tmp_file_Beautifier')
    1              0.000015   let g:tmp_file_Beautifier = fnameescape(tempname())
    1              0.000001 endif
                            
                            
                            
                            "% Helper functions and variables
    1              0.000008 let s:plugin_Root_direcoty = fnamemodify(expand("<sfile>"), ":h")
    1              0.000087 let s:paths_Editorconfig = map(['~/.editorconfig', '~/.vim/.editorconfig', s:plugin_Root_direcoty.'/.editorconfig'], 'expand(v:val)')
                            
                            " Function for debugging
                            " @param {Any} content Any type which will be converted
                            " to string and write to tmp file
    1              0.000003 func! s:console(content)
                              let log_dir = fnameescape('/tmp/vimlog')
                              call writefile([string(a:content)], log_dir)
                              return 1
                            endfun
                            
                            " Output warning message
                            " @param {Any} message The warning message
    1              0.000002 fun! WarningMsg(message)
                              echohl WarningMsg
                              echo string(a:message)
                            endfun
                            
                            " Output error message
                            " @param {Any} message The error message
    1              0.000002 fun! ErrorMsg(message)
                              echoerr string(a:message)
                            endfun
                            
                            " Check type of files
                            " @param {String} type The verified type
                            " @param {[List]} The list of allowed types
                            "
                            " @return {Boolean} Is the type in list of allowed types
    1              0.000003 func! s:isAllowedType(type, ...)
                              let haz = 1
                              let type = a:type
                              let allowedTypes = get(a:000, 1, ['js', 'css', 'html'])
                            
                              return index(allowedTypes, type) != -1
                            endfun
                            
                            " Quoting string
                            " @param {String} str Any string
                            " @return {String} The quoted string
    1              0.000002 func! s:quote(str)
                              return '"'.escape(a:str,'"').'"'
                            endfun
                            
                            " convert string to JSON
                            " @param {String} str Any string
                            " @return {String} The JSON string
    1              0.000001 func! s:toJSON(str)
                              let json = substitute(a:str, "'[", '[', 'g')
                              let json = substitute(json, "]'", ']', 'g')
                            
                              let json = substitute(json, "'false'", 'false', 'g')
                              let json = substitute(json, "'true'", 'true', 'g')
                            
                              let json = substitute(json, "'", '"', 'g')
                              let json = s:quote(json)
                              return json
                            endfun
                            
                            " @param {String} The content of .editorconfig file
                            " @return {Dict} The configuration object based
                            " on content the file.
    1              0.000002 func! s:processingEditconfigFile(content)
                              let opts = {}
                              let content = a:content
                            
                              for type in ['js', 'css', 'html']
                                " Get settings for javascript files
                                " collect all data after [**.js] to
                                " empty string
                                let index = index(content, '[**.'.type.']')
                                let l:value = {}
                            
                                if index == -1
                                  " If section doesn't define then set it how
                                  " empty object
                                  " @fix issue-25
                                  let opts[type] = l:value
                                  continue
                                endif
                            
                                " line with declaration [**.type]
                                " we shoul skip.
                                let index = index + 1
                                let line = get(content, index)
                            
                                " if string start with bracket
                                " then we assumes that it's
                                " start new logical section
                                " and break processing
                                while (strpart(line, 0, 1) != '[' && index <= len(content))
                            
                                  if (!empty(matchstr(line, ';\(vim:\)\@!')) || empty(line))
                                    " if we meet comment which is don't
                                    " special comment or empty string
                                    " then stop processing this line
                                    let index = index + 1
                                    let line = get(content, index)
                                    continue
                                  endif
                            
                                  " special comment should look like
                                  " ';vim:key=value:second=value'
                                  if strpart(line, 0, 1) == ';'
                                    " if it's special comment then procesisng
                                    " it separate and continue processing
                                    let l:copts = split(strpart(line, 5), ':')
                            
                                    for part in l:copts
                                      let data = split(part, '\s*=\s*')
                                      let l:value[get(data, 0)] = get(data, 1)
                                    endfor
                                  else
                                    " else we assumes that it is
                                    " .editorconfig setting
                                    let data = split(line, '\s*=\s*')
                                    let l:value[get(data, 0)] = get(data, 1)
                                  endif
                            
                                  let index = index + 1
                                  let line = get(content, index)
                                endwhile
                            
                                let opts[type] = l:value
                              endfor
                            
                              return opts
                            endfun
                            
                            " Convert some property from editorconfig
                            " to js-beautifier. For example `tab`.
                            "
                            " param {Dict} value The configuration object.
                            " return {Dict} Return the same configuration object.
    1              0.000002 function s:treatConfig(config)
                              let config = a:config
                            
                              if has_key(config, 'indent_style')
                                if config["indent_style"] == 'space'
                                  let config["indent_char"] = ' '
                                elseif config["indent_style"] == 'tab'
                                  let config["indent_char"] = '\t'
                                  " When the indent_char is tab, we always want to use 1 tab
                                  let config["indent_size"] = 1
                                endif
                              endif
                            
                              return config
                            endfunction
                            
                            " Метод которые обновляет
                            " скриптовой 'приватный' объект
                            " конфигурации
                            "
                            " param {Dict} value The configuration object.
                            " return {Dict} Return copy of configuration obect with link on
                            " old config or empty object.
    1              0.000002 function s:updateConfig(value)
                              if empty(a:value)
                                return a:value
                              endif
                            
                              let config = deepcopy(a:value)
                            
                              for type in ['js', 'css', 'html']
                                if has_key(config, type)
                                  call s:treatConfig(config[type])
                                endif
                              endfor
                            
                              " Делаем копию объекта
                              let b:config_Beautifier = config
                            
                              return b:config_Beautifier
                            endfunction
                            
                            " Get default path
                            " @param {String} type Some of the types js, html or css
    1              0.000002 func s:getPathByType(type)
                              let path = ''
                              let type = a:type
                              let rootPtah = s:plugin_Root_direcoty."/lib/js/lib/"
                            
                              if type == 'js'
                                let path = rootPtah."beautify.js"
                              elseif type == 'html'
                                let path = rootPtah."beautify-html.js"
                              elseif type == 'css'
                                let path = rootPtah."beautify-css.js"
                              endif
                            
                              return path
                            endfunc
                            
                            
                            
                            " Helper functions for restoring mark and cursor position
    1              0.000003 function! s:getNumberOfNonSpaceCharactersFromTheStartOfFile(position)
                              let cursorRow = a:position.line
                              let cursorColumn = a:position.column
                              let lineNumber = 1
                              let nonBlankCount = 0
                              while lineNumber <= cursorRow
                                let lineContent = getline(lineNumber)
                                if lineNumber == cursorRow
                                  let lineContent = strpart(lineContent,0,cursorColumn)
                                endif
                                let charIndex = 0
                                while charIndex < len(lineContent)
                                  let char = strpart(lineContent,charIndex,1)
                                  if match(char,'\s\|\n\|\r') == -1
                                    let nonBlankCount = nonBlankCount + 1
                                  endif
                                  let charIndex = charIndex + 1
                                endwhile
                                "echo nonBlankCount
                                let lineNumber = lineNumber + 1
                              endwhile
                              return nonBlankCount
                            endfunction
                            
                            
                            
                            "Converts number of non blank characters to cursor position (line and column)
    1              0.000003 function! s:getCursorPosition(numberOfNonBlankCharactersFromTheStartOfFile)
                              "echo a:numberOfNonBlankCharactersFromTheStartOfFile
                              let lineNumber = 1
                              let nonBlankCount = 0
                              while lineNumber <= line('$')
                                let lineContent = getline(lineNumber)
                                let charIndex = 0
                                while charIndex < len(lineContent)
                                  let char = strpart(lineContent,charIndex,1)
                                  if match(char,'\s\|\n\|\r') == -1
                                    let nonBlankCount = nonBlankCount + 1
                                  endif
                                  let charIndex = charIndex + 1
                                  if nonBlankCount == a:numberOfNonBlankCharactersFromTheStartOfFile 
                                    "echo 'found position!'
                                    return {'line': lineNumber,'column': charIndex}
                                  end
                                endwhile
                                let lineNumber = lineNumber + 1
                              endwhile
                              "echo "Oops, nothing found!"
                            endfunction
                            
                            
                            
                            "Restoring current position by number of non blank characters
    1              0.000003 function! s:setNumberOfNonSpaceCharactersBeforeCursor(mark,numberOfNonBlankCharactersFromTheStartOfFile)
                              let location = s:getCursorPosition(a:numberOfNonBlankCharactersFromTheStartOfFile)
                              call setpos(a:mark, [0, location.line, location.column, 0])
                            endfunction
                            
                            
                            
    1              0.000002 function! s:getCursorAndMarksPositions()
                              let localMarks = map(range(char2nr('a'), char2nr('z'))," \"'\".nr2char(v:val) ") 
                              let marks = ['.'] + localMarks
                              let result = {}
                              for positionType in marks
                                let cursorPositionAsList = getpos(positionType)
                                let cursorPosition = {'buffer': cursorPositionAsList[0], 'line': cursorPositionAsList[1], 'column': cursorPositionAsList[2]}
                                if cursorPosition.buffer == 0 && cursorPosition.line > 0
                                  let result[positionType] = cursorPosition
                                endif
                              endfor
                              return result
                            endfunction
                            
                            
                            
                            
                            "% Declaring global variables and functions
                            
                            " Apply settings from 'editorconfig' file to beautifier.
                            " @param {String} filepath path to configuration 'editorconfig' file.
                            " @return {Number} If apply was success then return '0' else '1'
    1              0.000002 function BeautifierApplyConfig(...)
                            
                              " Получаем путь который нам передали
                              let l:filepath = get(a:000, 0)
                            
                              " Проходимся по дефолтным путям только если
                              " оказалось что нам не передали путь
                              "
                              " Если нам передали путь то не стоит его
                              " тут проверять на сушествование
                              if empty(l:filepath)
                                let l:filepath = get(filter(copy(s:paths_Editorconfig),'filereadable(v:val)'), 0)
                              endif
                            
                              if !filereadable(l:filepath)
                                " File doesn't exist then return '1'
                                call WarningMsg('Can not find global .editorconfig file!')
                                return 1
                              endif
                            
                            
                              let l:content = readfile(l:filepath)
                            
                              " Process .editorconfig file
                              let opts = s:processingEditconfigFile(l:content)
                            
                              let g:config_Beautifier = opts
                              call s:updateConfig(opts)
                            
                              " All Ok! return '0'
                              return 0
                            endfunction
                            
                            
                            " Common function for beautify
                            " @param {String} type The type of file js, css, html
                            " @param {[String]} line1 The start line from which will start
                            " formating text, by default '1'
                            " @param {[String]} line2 The end line on which stop formating,
                            " by default '$'
    1              0.000001 func! Beautifier(...)
                              let cursorPositions = s:getCursorAndMarksPositions()
                              call map(cursorPositions, " extend (v:val,{'characters': s:getNumberOfNonSpaceCharactersFromTheStartOfFile(v:val)}) ")
                              if !exists('b:config_Beautifier')
                                call s:updateConfig(g:config_Beautifier)
                              endif
                            
                              " Define type of file
                              let type = get(a:000, 0, expand('%:e'))
                              let allowedTypes = get(b:config_Beautifier[type], 'extensions')
                            
                              if !s:isAllowedType(type, allowedTypes)
                                call WarningMsg('File type is not allowed!')
                                return 1
                              endif
                            
                              let line1 = get(a:000, 1, '1')
                              let line2 = get(a:000, 2, '$')
                            
                              let opts = b:config_Beautifier[type]
                              let path = get(opts, 'path', s:getPathByType(type))
                              let path = expand(path)
                              let path = fnameescape(path)
                              " Get external engine which will
                              " be execute javascript file
                              " by default get node
                              let engine = get(opts, 'bin', 'node')
                            
                              " Get content from the files
                              let content = getline(line1, line2)
                            
                              " Length of lines before beautify
                              let lines_length = len(getline(line1, line2))
                            
                              " Write content to temporary file
                              call writefile(content, g:tmp_file_Beautifier)
                              " String arguments which will be passed
                              " to external command
                            
                              let opts_Beautifier_arg = s:toJSON(string(opts))
                              let path_Beautifier_arg = s:quote(path)
                              let tmp_file_Beautifier_arg = s:quote(g:tmp_file_Beautifier)
                            
                              if executable(engine)
                                let result = system(engine." ".fnameescape(s:plugin_Root_direcoty."/beautify.min.js")." --js_arguments ".tmp_file_Beautifier_arg." ".opts_Beautifier_arg." ".path_Beautifier_arg)
                              else
                                " Executable bin doesn't exist
                                call ErrorMsg('The '.engine.' is not executable!')
                                return 1
                              endif
                            
                              let lines_Beautify = split(result, "\n")
                            
                              call setline(line1, lines_Beautify)
                            
                              " delete excess lines
                              if lines_length > len(lines_Beautify)
                                let endline = len(lines_Beautify) + 1
                                silent exec endline.",$g/.*/d"
                              endif
                            
                              for [key,value] in items(cursorPositions)
                                call s:setNumberOfNonSpaceCharactersBeforeCursor(key,value.characters)
                              endfor
                              return result
                            endfun
                            
                            " editorconfig hook
                            " Intergration with editorconfig.
                            " https://github.com/editorconfig/editorconfig-vim.git
    1              0.000002 func! BeautifierEditorconfigHook(config)
                              let type = expand('%:e')
                              let config = a:config
                            
                              if !(type(config) == 4)
                                return 1
                              endif
                            
                              if !s:isAllowedType(type)
                                return 1
                              endif
                            
                            
                              " If buffer config variable does not exist
                              " then let it
                              if !exists('b:config_Beautifier')
                                let b:config_Beautifier = deepcopy(g:config_Beautifier)
                              endif
                            
                              if !len(config)
                                call s:updateConfig(g:config_Beautifier)
                                return 1
                              endif
                            
                              if empty(get(b:config_Beautifier, type))
                                call WarningMsg('Type '.type.' is not presented in config')
                                return 1
                              endif
                            
                              let config = extend(b:config_Beautifier[type], config)
                            
                              call s:treatConfig(config)
                            
                              let b:config_Beautifier[type] = config
                            
                              " All Ok! retun 0
                              return 0
                            endfun
                            
                            " @param {[Number|String]} a:0 Default value '1'
                            " @param {[Number|String]} a:1 Default value '$'
    1              0.000001 fun! JsBeautify(...)
                              return call('Beautifier', extend(['js'], a:000))
                            endfun
                            
    1              0.000002 fun! HtmlBeautify(...)
                              return call('Beautifier', extend(['html'], a:000))
                            endfun
                            
    1              0.000001 fun! CSSBeautify(...)
                              return call('Beautifier', extend(['css'], a:000))
                            endfun
                            
                            " Check if installed editorconfig plugin
                            " then add hook on change
    1              0.000001 try
    1              0.000007   let BeautifierHook = function('BeautifierEditorconfigHook')
    1   0.001057   0.000766   call editorconfig#AddNewHook(BeautifierHook)
                            catch
    1              0.000003 endt
                            
                            "XXX: legacy block code
                            "yet retain support old config
    1              0.000002 fun! LegacyMsg()
                              call WarningMsg('beautifier.vim#Please use .editorconfig for default settings')
                            endfun
                            
    1              0.000003 if exists('g:jsbeautify')
                              let g:config_Beautifier['js'] = g:jsbeautify
                              if exists('g:jsbeautify_file')
                                let g:config_Beautifier['js']['path'] = g:jsbeautify_file
                              endif
                              call LegacyMsg()
                            endif
                            
    1              0.000003 if exists('g:htmlbeautify')
                              let g:config_Beautifier['html'] = g:htmlbeautify
                              if exists('g:htmlbeautify_file')
                                let g:config_Beautifier['html']['path'] = g:htmlbeautify_file
                              endif
                              call LegacyMsg()
                            endif
                            
    1              0.000002 if exists('g:htmlbeautify')
                              let g:config_Beautifier['css'] = g:cssbeautify
                              if exists('g:cssbeautify_file')
                                let g:config_Beautifier['css']['path'] = g:cssbeautify_file
                              endif
                              call LegacyMsg()
                            endif
                            "XXX: end
                            
                            " If user doesn't set config_Beautifier in
                            " .vimrc then look up it in .editorconfig
    1              0.000002 if empty(g:config_Beautifier)
    1   0.000872   0.000012   call BeautifierApplyConfig(g:editorconfig_Beautifier)
    1              0.000004 endif

SCRIPT  /Applications/MacVim.app/Contents/Resources/vim/runtime/ftplugin/javascript.vim
Sourced 3 times
Total time:   0.000386
 Self time:   0.000386

count  total (s)   self (s)
                            " Vim filetype plugin file
                            " Language:	Javascript
                            " Maintainer:	Doug Kearns <dougkearns@gmail.com>
                            " Last Change:  2008 Jun 15
                            " URL:		http://gus.gscit.monash.edu.au/~djkea2/vim/ftplugin/javascript.vim
                            
    3              0.000056 if exists("b:did_ftplugin")
                              finish
                            endif
    3              0.000015 let b:did_ftplugin = 1
                            
    3              0.000034 let s:cpo_save = &cpo
    3              0.000027 set cpo-=C
                            
                            " Set 'formatoptions' to break comment lines but not other lines,
                            " " and insert the comment leader when hitting <CR> or using "o".
    3              0.000017 setlocal formatoptions-=t formatoptions+=croql
                            
                            " Set completion with CTRL-X CTRL-O to autoloaded function.
    3              0.000016 if exists('&ofu')
    3              0.000012     setlocal omnifunc=javascriptcomplete#CompleteJS
    3              0.000004 endif
                            
                            " Set 'comments' to format dashed lists in comments.
    3              0.000015 setlocal comments=sO:*\ -,mO:*\ \ ,exO:*/,s1:/*,mb:*,ex:*/,://
                            
    3              0.000008 setlocal commentstring=//%s
                            
                            " Change the :browse e filter to primarily show Java-related files.
    3              0.000018 if has("gui_win32")
                                let  b:browsefilter="Javascript Files (*.js)\t*.js\n" .
                            		\	"All Files (*.*)\t*.*\n"
                            endif
                                   
    3              0.000011 let b:undo_ftplugin = "setl fo< ofu< com< cms<" 
                            
    3              0.000021 let &cpo = s:cpo_save
    3              0.000015 unlet s:cpo_save

SCRIPT  /Users/admin/.vim/bundle/tern_for_vim/after/ftplugin/javascript_tern.vim
Sourced 3 times
Total time:   0.062800
 Self time:   0.000553

count  total (s)   self (s)
                            call tern#Enable()
                            
                            " Menu 
    3              0.000165 menu <silent> Tern.Jump\ To\ Defintion :TernDef<CR>
    3              0.000066 menu <silent> Tern.See\ Documentation :TernDoc<CR>
    3              0.000054 menu <silent> Tern.DataType :TernType <CR>
    3              0.000057 menu <silent> Tern.Show\ all\ References :TernRefs<CR>
    3              0.000062 menu <silent> Tern.Rename :TernRename <CR> 

SCRIPT  /Users/admin/.vim/bundle/tern_for_vim/autoload/tern.vim
Sourced 1 time
Total time:   0.061134
 Self time:   0.061134

count  total (s)   self (s)
                            if !has('python')
                                echo 'tern requires python support'
                                finish
                            endif
                            
    1              0.000006 py << endpy
                            
                            import vim, os, platform, subprocess, urllib2, webbrowser, json, re, string, time
                            from itertools import groupby
                            
                            def tern_displayError(err):
                              vim.command("echo " + json.dumps(str(err)))
                            
                            def tern_makeRequest(port, doc):
                              try:
                                req = urllib2.urlopen("http://localhost:" + str(port) + "/", json.dumps(doc),
                                                      float(vim.eval("g:tern_request_timeout")));
                                return json.loads(req.read())
                              except urllib2.HTTPError, error:
                                tern_displayError(error.read())
                                return None
                            
                            # Prefixed with _ to influence destruction order. See
                            # http://docs.python.org/2/reference/datamodel.html#object.__del__
                            _tern_projects = {}
                            
                            class Project(object):
                              def __init__(self, dir):
                                self.dir = dir
                                self.port = None
                                self.proc = None
                                self.last_failed = 0
                            
                              def __del__(self):
                                tern_killServer(self)
                            
                            def tern_projectDir():
                              cur = vim.eval("b:ternProjectDir")
                              if cur: return cur
                            
                              projectdir = ""
                              mydir = vim.eval("expand('%:p:h')")
                              if not os.path.isdir(mydir): return ""
                            
                              if mydir:
                                projectdir = mydir
                                while True:
                                  parent = os.path.dirname(mydir[:-1])
                                  if not parent:
                                    break
                                  if os.path.isfile(os.path.join(mydir, ".tern-project")):
                                    projectdir = mydir
                                    break
                                  mydir = parent
                            
                              vim.command("let b:ternProjectDir = " + json.dumps(projectdir))
                              return projectdir
                            
                            def tern_findServer(ignorePort=False):
                              dir = tern_projectDir()
                              if not dir: return (None, False)
                              project = _tern_projects.get(dir, None)
                              if project is None:
                                project = Project(dir)
                                _tern_projects[dir] = project
                              if project.port is not None and project.port != ignorePort:
                                return (project.port, True)
                            
                              portFile = os.path.join(dir, ".tern-port")
                              if os.path.isfile(portFile):
                                port = int(open(portFile, "r").read())
                                if port != ignorePort:
                                  project.port = port
                                  return (port, True)
                              return (tern_startServer(project), False)
                            
                            def tern_startServer(project):
                              if time.time() - project.last_failed < 30: return None
                            
                              win = platform.system() == "Windows"
                              env = None
                              if platform.system() == "Darwin":
                                env = os.environ.copy()
                                env["PATH"] += ":/usr/local/bin"
                              proc = subprocess.Popen(vim.eval("g:tern#command") + vim.eval("g:tern#arguments"),
                                                      cwd=project.dir, env=env,
                                                      stdin=subprocess.PIPE, stdout=subprocess.PIPE,
                                                      stderr=subprocess.STDOUT, shell=win)
                              output = ""
                              while True:
                                line = proc.stdout.readline()
                                if not line:
                                  tern_displayError("Failed to start server" + (output and ":\n" + output))
                                  project.last_failed = time.time()
                                  return None
                                match = re.match("Listening on port (\\d+)", line)
                                if match:
                                  port = int(match.group(1))
                                  project.port = port
                                  project.proc = proc
                                  return port
                                else:
                                  output += line
                            
                            def tern_killServer(project):
                              if project.proc is None: return
                              project.proc.stdin.close()
                              project.proc.wait()
                              project.proc = None
                            
                            def tern_killServers():
                              for project in _tern_projects.values():
                                tern_killServer(project)
                            
                            def tern_relativeFile():
                              filename = vim.eval("expand('%:p')")
                              return filename[len(tern_projectDir()) + 1:]
                            
                            def tern_bufferSlice(buf, pos, end):
                              text = ""
                              while pos < end:
                                text += buf[pos] + "\n"
                                pos += 1
                              return text
                            
                            def tern_fullBuffer():
                              return {"type": "full",
                                      "name": tern_relativeFile(),
                                      "text": tern_bufferSlice(vim.current.buffer, 0, len(vim.current.buffer))}
                            
                            def tern_bufferFragment():
                              curRow, curCol = vim.current.window.cursor
                              line = curRow - 1
                              buf = vim.current.buffer
                              minIndent = None
                              start = None
                            
                              for i in range(max(0, line - 50), line):
                                if not re.match(".*\\bfunction\\b", buf[i]): continue
                                indent = len(re.match("^\\s*", buf[i]).group(0))
                                if minIndent is None or indent <= minIndent:
                                  minIndent = indent
                                  start = i
                            
                              if start is None: start = max(0, line - 50)
                              end = min(len(buf) - 1, line + 20)
                              return {"type": "part",
                                      "name": tern_relativeFile(),
                                      "text": tern_bufferSlice(buf, start, end),
                                      "offsetLines": start}
                            
                            def tern_runCommand(query, pos=None, fragments=True):
                              if isinstance(query, str): query = {"type": query}
                              if (pos is None):
                                curRow, curCol = vim.current.window.cursor
                                pos = {"line": curRow - 1, "ch": curCol}
                              port, portIsOld = tern_findServer()
                              if port is None: return
                              curSeq = vim.eval("undotree()['seq_cur']")
                            
                              doc = {"query": query, "files": []}
                              if curSeq == vim.eval("b:ternBufferSentAt"):
                                fname, sendingFile = (tern_relativeFile(), False)
                              elif len(vim.current.buffer) > 250 and fragments:
                                f = tern_bufferFragment()
                                doc["files"].append(f)
                                pos = {"line": pos["line"] - f["offsetLines"], "ch": pos["ch"]}
                                fname, sendingFile = ("#0", False)
                              else:
                                doc["files"].append(tern_fullBuffer())
                                fname, sendingFile = ("#0", True)
                              query["file"] = fname
                              query["end"] = pos
                              query["lineCharPositions"] = True
                            
                              data = None
                              try:
                                data = tern_makeRequest(port, doc)
                                if data is None: return None
                              except:
                                pass
                            
                              if data is None and portIsOld:
                                try:
                                  port, portIsOld = tern_findServer(port)
                                  if port is None: return
                                  data = tern_makeRequest(port, doc)
                                  if data is None: return None
                                except Exception as e:
                                  tern_displayError(e)
                            
                              if sendingFile and vim.eval("b:ternInsertActive") == "0":
                                vim.command("let b:ternBufferSentAt = " + str(curSeq))
                              return data
                            
                            def tern_sendBuffer(files=None):
                              port, _portIsOld = tern_findServer()
                              if port is None: return False
                              try:
                                tern_makeRequest(port, {"files": files or [tern_fullBuffer()]})
                                return True
                              except:
                                return False
                            
                            def tern_sendBufferIfDirty():
                              if (vim.eval("exists('b:ternInsertActive')") == "1" and
                                  vim.eval("b:ternInsertActive") == "0"):
                                curSeq = vim.eval("undotree()['seq_cur']")
                                if curSeq > vim.eval("b:ternBufferSentAt") and tern_sendBuffer():
                                  vim.command("let b:ternBufferSentAt = " + str(curSeq))
                            
                            def tern_asCompletionIcon(type):
                              if type is None or type == "?": return "(?)"
                              if type.startswith("fn("): return "(fn)"
                              if type.startswith("["): return "([])"
                              if type == "number": return "(num)"
                              if type == "string": return "(str)"
                              if type == "bool": return "(bool)"
                              return "(obj)"
                            
                            def tern_ensureCompletionCached():
                              cached = vim.eval("b:ternLastCompletionPos")
                              curRow, curCol = vim.current.window.cursor
                              curLine = vim.current.buffer[curRow - 1]
                            
                              if (curRow == int(cached["row"]) and curCol >= int(cached["end"]) and
                                  curLine[int(cached["start"]):int(cached["end"])] == cached["word"] and
                                  (not re.match(".*\\W", curLine[int(cached["end"]):curCol]))):
                                return
                            
                              data = tern_runCommand({"type": "completions", "types": True, "docs": True},
                                                     {"line": curRow - 1, "ch": curCol})
                              if data is None: return
                            
                              completions = []
                              for rec in data["completions"]:
                                completions.append({"word": rec["name"],
                                                    "menu": tern_asCompletionIcon(rec.get("type")),
                                                    "info": tern_typeDoc(rec) })
                              vim.command("let b:ternLastCompletion = " + json.dumps(completions))
                              start, end = (data["start"]["ch"], data["end"]["ch"])
                              vim.command("let b:ternLastCompletionPos = " + json.dumps({
                                "row": curRow,
                                "start": start,
                                "end": end,
                                "word": curLine[start:end]
                              }))
                            
                            def tern_typeDoc(rec):
                              tp = rec.get("type")
                              result = rec.get("doc", " ")
                              if tp and tp != "?":
                                 result = tp + "\n" + result
                              return result
                            
                            def tern_lookupDocumentation(browse=False):
                              data = tern_runCommand("documentation")
                              if data is None: return
                            
                              doc = data.get("doc")
                              url = data.get("url")
                              if url:
                                if browse: return webbrowser.open(url)
                                doc = ((doc and doc + "\n\n") or "") + "See " + url
                              if doc:
                                vim.command("call tern#PreviewInfo(" + json.dumps(doc) + ")")
                              else:
                                vim.command("echo 'no documentation found'")
                            
                            def tern_echoWrap(data, name=""):
                              text = data
                              if len(name) > 0:
                                text = name+": " + text
                              col = int(vim.eval("&columns"))-23
                              if len(text) > col:
                                text = text[0:col]+"..."
                              vim.command("echo '{0}'".format(text))
                            
                            def tern_lookupType():
                              data = tern_runCommand("type")
                              if data: tern_echoWrap(data.get("type", ""))
                            
                            def tern_lookupArgumentHints(fname, apos):
                              curRow, curCol = vim.current.window.cursor
                              data = tern_runCommand({"type": "type", "preferFunction": True},
                                                     {"line": curRow - 1, "ch": apos})
                              if data: tern_echoWrap(data.get("type", ""),name=fname)
                            
                            def tern_lookupDefinition(cmd):
                              data = tern_runCommand("definition")
                              if data is None: return
                            
                              if "file" in data:
                                lnum     = data["start"]["line"] + 1
                                col      = data["start"]["ch"] + 1
                                filename = data["file"]
                            
                                if cmd == "edit" and filename == tern_relativeFile():
                                  vim.command("normal! m`")
                                  vim.command("call cursor(" + str(lnum) + "," + str(col) + ")")
                                else:
                                  vim.command(cmd + " +call\ cursor(" + str(lnum) + "," + str(col) + ") " +
                                    tern_projectFilePath(filename).replace(" ", "\\ "))
                              elif "url" in data:
                                vim.command("echo " + json.dumps("see " + data["url"]))
                              else:
                                vim.command("echo 'no definition found'")
                            
                            def tern_projectFilePath(path):
                              return os.path.join(tern_projectDir(), path)
                            
                            def tern_refs():
                              data = tern_runCommand("refs", fragments=False)
                              if data is None: return
                            
                              refs = []
                              for ref in data["refs"]:
                                lnum     = ref["start"]["line"] + 1
                                col      = ref["start"]["ch"] + 1
                                filename = tern_projectFilePath(ref["file"])
                                name     = data["name"]
                                text     = vim.eval("getbufline('" + filename + "'," + str(lnum) + ")")
                                refs.append({"lnum": lnum,
                                             "col": col,
                                             "filename": filename,
                                             "text": name + " (file not loaded)" if len(text)==0 else text[0]})
                              vim.command("call setloclist(0," + json.dumps(refs) + ") | lopen")
                            
                            # Copied here because Python 2.6 and lower don't have it built in, and
                            # python 3.0 and higher don't support old-style cmp= args to the sort
                            # method. There's probably a better way to do this...
                            def tern_cmp_to_key(mycmp):
                              class K(object):
                                def __init__(self, obj, *args):
                                  self.obj = obj
                                def __lt__(self, other):
                                  return mycmp(self.obj, other.obj) < 0
                                def __gt__(self, other):
                                  return mycmp(self.obj, other.obj) > 0
                                def __eq__(self, other):
                                  return mycmp(self.obj, other.obj) == 0
                                def __le__(self, other):
                                  return mycmp(self.obj, other.obj) <= 0
                                def __ge__(self, other):
                                  return mycmp(self.obj, other.obj) >= 0
                                def __ne__(self, other):
                                  return mycmp(self.obj, other.obj) != 0
                              return K
                            
                            def tern_rename(newName):
                              data = tern_runCommand({"type": "rename", "newName": newName}, fragments=False)
                              if data is None: return
                            
                              def mycmp(a,b):
                                return (cmp(a["file"], b["file"]) or
                                        cmp(a["start"]["line"], b["start"]["line"]) or
                                        cmp(a["start"]["ch"], b["start"]["ch"]))
                              data["changes"].sort(key=tern_cmp_to_key(mycmp))
                              changes_byfile = groupby(data["changes"]
                                                      ,key=lambda c: tern_projectFilePath(c["file"]))
                            
                              name = data["name"]
                              changes, external = ([], [])
                              for file, filechanges in changes_byfile:
                            
                                buffer = None
                                for buf in vim.buffers:
                                  if buf.name == file:
                                    buffer = buf
                            
                                if buffer is not None:
                                  lines = buffer
                                else:
                                  with open(file, "r") as f:
                                    lines = f.readlines()
                                for linenr, linechanges in groupby(filechanges, key=lambda c: c["start"]["line"]):
                                  text = lines[linenr]
                                  offset = 0
                                  changed = []
                                  for change in linechanges:
                                    colStart = change["start"]["ch"]
                                    colEnd = change["end"]["ch"]
                                    text = text[0:colStart + offset] + newName + text[colEnd + offset:]
                                    offset += len(newName) - len(name)
                                    changed.append({"lnum": linenr + 1,
                                                    "col": colStart + 1 + offset,
                                                    "filename": file})
                                  for change in changed:
                                    if buffer is not None:
                                      lines[linenr] = change["text"] = text
                                    else:
                                      change["text"] = "[not loaded] " + text
                                      lines[linenr] = text
                                  changes.extend(changed)
                                if buffer is None:
                                  with open(file, "w") as f:
                                    f.writelines(lines)
                                  external.append({"name": file, "text": string.join(lines, ""), "type": "full"})
                              if len(external):
                                tern_sendBuffer(external)
                              vim.command("call setloclist(0," + json.dumps(changes) + ") | lopen")
                            
                            endpy
                            
    1              0.000016 if !exists('g:tern#command')
    1              0.000014   let g:tern#command = ["node", expand('<sfile>:h') . '/../node_modules/tern/bin/tern', '--no-port-file']
    1              0.000002 endif
                            
    1              0.000003 if !exists('g:tern#arguments')
    1              0.000003   let g:tern#arguments = []
    1              0.000001 endif
                            
    1              0.000007 function! tern#PreviewInfo(info)
                              pclose
                              new +setlocal\ previewwindow|setlocal\ buftype=nofile|setlocal\ noswapfile
                              exe "normal z" . &previewheight . "\<cr>"
                              call append(0, type(a:info)==type("") ? split(a:info, "\n") : a:info)
                              wincmd p
                            endfunction
                            
    1              0.000004 function! tern#Complete(findstart, complWord)
                              if a:findstart
                                python tern_ensureCompletionCached()
                                return b:ternLastCompletionPos['start']
                              elseif b:ternLastCompletionPos['end'] - b:ternLastCompletionPos['start'] == len(a:complWord)
                                return b:ternLastCompletion
                              else
                                let rest = []
                                for entry in b:ternLastCompletion
                                  if stridx(entry["word"], a:complWord) == 0
                                    call add(rest, entry)
                                  endif
                                endfor
                                return rest
                              endif
                            endfunction
                            
    1              0.000002 function! tern#LookupType()
                              python tern_lookupType()
                              return ''
                            endfunction
                            
    1              0.000003 function! tern#LookupArgumentHints()
                              if g:tern_show_argument_hints == 'no'
                                return
                              endif
                              let fname = get(matchlist(getline('.')[:col('.')-2],'\([a-zA-Z0-9_]*\)([^()]*$'),1)
                              let pos   = match(getline('.')[:col('.')-2],'[a-zA-Z0-9_]*([^()]*$')
                              if pos >= 0
                                python tern_lookupArgumentHints(vim.eval('fname'),int(vim.eval('pos')))
                              else
                                python tern_lookupType()
                              endif
                              return ''
                            endfunction
                            
    1              0.000014 command! TernDoc py tern_lookupDocumentation()
    1              0.000008 command! TernDocBrowse py tern_lookupDocumentation(browse=True)
    1              0.000006 command! TernType py tern_lookupType()
    1              0.000007 command! TernDef py tern_lookupDefinition("edit")
    1              0.000007 command! TernDefPreview py tern_lookupDefinition("pedit")
    1              0.000006 command! TernDefSplit py tern_lookupDefinition("split")
    1              0.000007 command! TernDefTab py tern_lookupDefinition("tabe")
    1              0.000006 command! TernRefs py tern_refs()
    1              0.000012 command! TernRename exe 'py tern_rename("'.input("new name? ",expand("<cword>")).'")'
                            
    1              0.000004 if !exists('g:tern_show_argument_hints')
    1              0.000003   let g:tern_show_argument_hints = 'no'
    1              0.000001 endif
                            
    1              0.000003 if !exists('g:tern_map_keys')
    1              0.000003   let g:tern_map_keys = 0
    1              0.000001 endif
                            
    1              0.000003 if !exists('g:tern_map_prefix')
    1              0.000003   let g:tern_map_prefix = '<LocalLeader>'
    1              0.000001 endif
                            
    1              0.000003 if !exists('g:tern_request_timeout')
    1              0.000003   let g:tern_request_timeout = 1
    1              0.000001 endif
                            
    1              0.000004 function! tern#DefaultKeyMap(...)
                              let prefix = len(a:000)==1 ? a:1 : "<LocalLeader>"
                              execute 'nnoremap <buffer> '.prefix.'td' ':TernDoc<CR>'
                              execute 'nnoremap <buffer> '.prefix.'tb' ':TernDocBrowse<CR>'
                              execute 'nnoremap <buffer> '.prefix.'tt' ':TernType<CR>'
                              execute 'nnoremap <buffer> '.prefix.'td' ':TernDef<CR>'
                              execute 'nnoremap <buffer> '.prefix.'tpd' ':TernDefPreview<CR>'
                              execute 'nnoremap <buffer> '.prefix.'tsd' ':TernDefSplit<CR>'
                              execute 'nnoremap <buffer> '.prefix.'ttd' ':TernDefTab<CR>'
                              execute 'nnoremap <buffer> '.prefix.'tr' ':TernRefs<CR>'
                              execute 'nnoremap <buffer> '.prefix.'tR' ':TernRename<CR>'
                            endfunction
                            
    1              0.000003 function! tern#Enable()
                              if stridx(&buftype, "nofile") > -1 || stridx(&buftype, "nowrite") > -1
                                return
                              endif
                              let b:ternProjectDir = ''
                              let b:ternLastCompletion = []
                              let b:ternLastCompletionPos = {'row': -1, 'start': 0, 'end': 0}
                              let b:ternBufferSentAt = -1
                              let b:ternInsertActive = 0
                              setlocal omnifunc=tern#Complete
                              if g:tern_map_keys
                                call tern#DefaultKeyMap(g:tern_map_prefix)
                              endif
                              augroup TernAutoCmd
                                autocmd! * <buffer>
                                autocmd BufLeave <buffer> :py tern_sendBufferIfDirty()
                                if g:tern_show_argument_hints == 'on_move'
                                  autocmd CursorMoved,CursorMovedI <buffer> call tern#LookupArgumentHints()
                                elseif g:tern_show_argument_hints == 'on_hold'
                                  autocmd CursorHold,CursorHoldI <buffer> call tern#LookupArgumentHints()
                                endif
                                autocmd InsertEnter <buffer> let b:ternInsertActive = 1
                                autocmd InsertLeave <buffer> let b:ternInsertActive = 0
                              augroup END
                            endfunction
                            
    1              0.000005 augroup TernShutDown
    1              0.000015   autocmd VimLeavePre * call tern#Shutdown()
    1              0.000002 augroup END
                            
    1              0.000003 function! tern#Disable()
                              augroup TernAutoCmd
                                autocmd! * <buffer>
                              augroup END
                            endfunction
                            
    1              0.000002 function! tern#Shutdown()
                              py tern_killServers()
                            endfunction

SCRIPT  /Users/admin/.vim/bundle/vim-javascript/indent/javascript.vim
Sourced 3 times
Total time:   0.000622
 Self time:   0.000622

count  total (s)   self (s)
                            " Vim indent file
                            " Language: Javascript
                            " Acknowledgement: Based off of vim-ruby maintained by Nikolai Weibull http://vim-ruby.rubyforge.org
                            
                            " 0. Initialization {{{1
                            " =================
                            
                            " Only load this indent file when no other was loaded.
    3              0.000024 if exists("b:did_indent")
                              finish
                            endif
    3              0.000010 let b:did_indent = 1
                            
    3              0.000014 setlocal nosmartindent
                            
                            " Now, set up our indentation expression and keys that trigger it.
    3              0.000013 setlocal indentexpr=GetJavascriptIndent()
    3              0.000011 setlocal indentkeys=0{,0},0),0],0\,,!^F,o,O,e
                            
                            " Only define the function once.
    3              0.000013 if exists("*GetJavascriptIndent")
    2              0.000004   finish
                            endif
                            
    1              0.000008 let s:cpo_save = &cpo
    1              0.000007 set cpo&vim
                            
                            " 1. Variables {{{1
                            " ============
                            
    1              0.000006 let s:js_keywords = '^\s*\(break\|case\|catch\|continue\|debugger\|default\|delete\|do\|else\|finally\|for\|function\|if\|in\|instanceof\|new\|return\|switch\|this\|throw\|try\|typeof\|var\|void\|while\|with\)'
                            
                            " Regex of syntax group names that are or delimit string or are comments.
    1              0.000003 let s:syng_strcom = 'string\|regex\|comment\c'
                            
                            " Regex of syntax group names that are strings.
    1              0.000002 let s:syng_string = 'regex\c'
                            
                            " Regex of syntax group names that are strings or documentation.
    1              0.000002 let s:syng_multiline = 'comment\c'
                            
                            " Regex of syntax group names that are line comment.
    1              0.000002 let s:syng_linecom = 'linecomment\c'
                            
                            " Expression used to check whether we should skip a match with searchpair().
    1              0.000005 let s:skip_expr = "synIDattr(synID(line('.'),col('.'),1),'name') =~ '".s:syng_strcom."'"
                            
    1              0.000003 let s:line_term = '\s*\%(\%(\/\/\).*\)\=$'
                            
                            " Regex that defines continuation lines, not including (, {, or [.
    1              0.000005 let s:continuation_regex = '\%([\\*+/.:]\|\%(<%\)\@<![=-]\|\W[|&?]\|||\|&&\)' . s:line_term
                            
                            " Regex that defines continuation lines.
                            " TODO: this needs to deal with if ...: and so on
    1              0.000004 let s:msl_regex = '\%([\\*+/.:([]\|\%(<%\)\@<![=-]\|\W[|&?]\|||\|&&\)' . s:line_term
                            
    1              0.000004 let s:one_line_scope_regex = '\<\%(if\|else\|for\|while\)\>[^{;]*' . s:line_term
                            
                            " Regex that defines blocks.
    1              0.000004 let s:block_regex = '\%([{[]\)\s*\%(|\%([*@]\=\h\w*,\=\s*\)\%(,\s*[*@]\=\h\w*\)*|\)\=' . s:line_term
                            
    1              0.000002 let s:var_stmt = '^\s*var'
                            
    1              0.000003 let s:comma_first = '^\s*,'
    1              0.000002 let s:comma_last = ',\s*$'
                            
    1              0.000002 let s:ternary = '^\s\+[?|:]'
    1              0.000003 let s:ternary_q = '^\s\+?'
                            
                            " 2. Auxiliary Functions {{{1
                            " ======================
                            
                            " Check if the character at lnum:col is inside a string, comment, or is ascii.
    1              0.000004 function s:IsInStringOrComment(lnum, col)
                              return synIDattr(synID(a:lnum, a:col, 1), 'name') =~ s:syng_strcom
                            endfunction
                            
                            " Check if the character at lnum:col is inside a string.
    1              0.000002 function s:IsInString(lnum, col)
                              return synIDattr(synID(a:lnum, a:col, 1), 'name') =~ s:syng_string
                            endfunction
                            
                            " Check if the character at lnum:col is inside a multi-line comment.
    1              0.000003 function s:IsInMultilineComment(lnum, col)
                              return !s:IsLineComment(a:lnum, a:col) && synIDattr(synID(a:lnum, a:col, 1), 'name') =~ s:syng_multiline
                            endfunction
                            
                            " Check if the character at lnum:col is a line comment.
    1              0.000002 function s:IsLineComment(lnum, col)
                              return synIDattr(synID(a:lnum, a:col, 1), 'name') =~ s:syng_linecom
                            endfunction
                            
                            " Find line above 'lnum' that isn't empty, in a comment, or in a string.
    1              0.000002 function s:PrevNonBlankNonString(lnum)
                              let in_block = 0
                              let lnum = prevnonblank(a:lnum)
                              while lnum > 0
                                " Go in and out of blocks comments as necessary.
                                " If the line isn't empty (with opt. comment) or in a string, end search.
                                let line = getline(lnum)
                                if line =~ '/\*'
                                  if in_block
                                    let in_block = 0
                                  else
                                    break
                                  endif
                                elseif !in_block && line =~ '\*/'
                                  let in_block = 1
                                elseif !in_block && line !~ '^\s*\%(//\).*$' && !(s:IsInStringOrComment(lnum, 1) && s:IsInStringOrComment(lnum, strlen(line)))
                                  break
                                endif
                                let lnum = prevnonblank(lnum - 1)
                              endwhile
                              return lnum
                            endfunction
                            
                            " Find line above 'lnum' that started the continuation 'lnum' may be part of.
    1              0.000002 function s:GetMSL(lnum, in_one_line_scope)
                              " Start on the line we're at and use its indent.
                              let msl = a:lnum
                              let lnum = s:PrevNonBlankNonString(a:lnum - 1)
                              while lnum > 0
                                " If we have a continuation line, or we're in a string, use line as MSL.
                                " Otherwise, terminate search as we have found our MSL already.
                                let line = getline(lnum)
                                let col = match(line, s:msl_regex) + 1
                                if (col > 0 && !s:IsInStringOrComment(lnum, col)) || s:IsInString(lnum, strlen(line))
                                  let msl = lnum
                                else
                                  " Don't use lines that are part of a one line scope as msl unless the
                                  " flag in_one_line_scope is set to 1
                                  "
                                  if a:in_one_line_scope
                                    break
                                  end
                                  let msl_one_line = s:Match(lnum, s:one_line_scope_regex)
                                  if msl_one_line == 0
                                    break
                                  endif
                                endif
                                let lnum = s:PrevNonBlankNonString(lnum - 1)
                              endwhile
                              return msl
                            endfunction
                            
    1              0.000003 function s:RemoveTrailingComments(content)
                              let single = '\/\/\(.*\)\s*$'
                              let multi = '\/\*\(.*\)\*\/\s*$'
                              return substitute(substitute(a:content, single, '', ''), multi, '', '')
                            endfunction
                            
                            " Find if the string is inside var statement (but not the first string)
    1              0.000003 function s:InMultiVarStatement(lnum)
                              let lnum = s:PrevNonBlankNonString(a:lnum - 1)
                            
                            "  let type = synIDattr(synID(lnum, indent(lnum) + 1, 0), 'name')
                            
                              " loop through previous expressions to find a var statement
                              while lnum > 0
                                let line = getline(lnum)
                            
                                " if the line is a js keyword
                                if (line =~ s:js_keywords)
                                  " check if the line is a var stmt
                                  " if the line has a comma first or comma last then we can assume that we
                                  " are in a multiple var statement
                                  if (line =~ s:var_stmt)
                                    return lnum
                                  endif
                            
                                  " other js keywords, not a var
                                  return 0
                                endif
                            
                                let lnum = s:PrevNonBlankNonString(lnum - 1)
                              endwhile
                            
                              " beginning of program, not a var
                              return 0
                            endfunction
                            
                            " Find line above with beginning of the var statement or returns 0 if it's not
                            " this statement
    1              0.000002 function s:GetVarIndent(lnum)
                              let lvar = s:InMultiVarStatement(a:lnum)
                              let prev_lnum = s:PrevNonBlankNonString(a:lnum - 1)
                            
                              if lvar
                                let line = s:RemoveTrailingComments(getline(prev_lnum))
                            
                                " if the previous line doesn't end in a comma, return to regular indent
                                if (line !~ s:comma_last)
                                  return indent(prev_lnum) - &sw
                                else
                                  return indent(lvar) + &sw
                                endif
                              endif
                            
                              return -1
                            endfunction
                            
                            
                            " Check if line 'lnum' has more opening brackets than closing ones.
    1              0.000002 function s:LineHasOpeningBrackets(lnum)
                              let open_0 = 0
                              let open_2 = 0
                              let open_4 = 0
                              let line = getline(a:lnum)
                              let pos = match(line, '[][(){}]', 0)
                              while pos != -1
                                if !s:IsInStringOrComment(a:lnum, pos + 1)
                                  let idx = stridx('(){}[]', line[pos])
                                  if idx % 2 == 0
                                    let open_{idx} = open_{idx} + 1
                                  else
                                    let open_{idx - 1} = open_{idx - 1} - 1
                                  endif
                                endif
                                let pos = match(line, '[][(){}]', pos + 1)
                              endwhile
                              return (open_0 > 0) . (open_2 > 0) . (open_4 > 0)
                            endfunction
                            
    1              0.000003 function s:Match(lnum, regex)
                              let col = match(getline(a:lnum), a:regex) + 1
                              return col > 0 && !s:IsInStringOrComment(a:lnum, col) ? col : 0
                            endfunction
                            
    1              0.000003 function s:IndentWithContinuation(lnum, ind, width)
                              " Set up variables to use and search for MSL to the previous line.
                              let p_lnum = a:lnum
                              let lnum = s:GetMSL(a:lnum, 1)
                              let line = getline(lnum)
                            
                              " If the previous line wasn't a MSL and is continuation return its indent.
                              " TODO: the || s:IsInString() thing worries me a bit.
                              if p_lnum != lnum
                                if s:Match(p_lnum,s:continuation_regex)||s:IsInString(p_lnum,strlen(line))
                                  return a:ind
                                endif
                              endif
                            
                              " Set up more variables now that we know we aren't continuation bound.
                              let msl_ind = indent(lnum)
                            
                              " If the previous line ended with [*+/.-=], start a continuation that
                              " indents an extra level.
                              if s:Match(lnum, s:continuation_regex)
                                if lnum == p_lnum
                                  return msl_ind + a:width
                                else
                                  return msl_ind
                                endif
                              endif
                            
                              return a:ind
                            endfunction
                            
    1              0.000005 function s:InOneLineScope(lnum)
                              let msl = s:GetMSL(a:lnum, 1)
                              if msl > 0 && s:Match(msl, s:one_line_scope_regex)
                                return msl
                              endif
                              return 0
                            endfunction
                            
    1              0.000003 function s:ExitingOneLineScope(lnum)
                              let msl = s:GetMSL(a:lnum, 1)
                              if msl > 0
                                " if the current line is in a one line scope ..
                                if s:Match(msl, s:one_line_scope_regex)
                                  return 0
                                else
                                  let prev_msl = s:GetMSL(msl - 1, 1)
                                  if s:Match(prev_msl, s:one_line_scope_regex)
                                    return prev_msl
                                  endif
                                endif
                              endif
                              return 0
                            endfunction
                            
                            " 3. GetJavascriptIndent Function {{{1
                            " =========================
                            
    1              0.000002 function GetJavascriptIndent()
                              " 3.1. Setup {{{2
                              " ----------
                            
                              " Set up variables for restoring position in file.  Could use v:lnum here.
                              let vcol = col('.')
                            
                              " 3.2. Work on the current line {{{2
                              " -----------------------------
                            
                              let ind = -1
                              " Get the current line.
                              let line = getline(v:lnum)
                              " previous nonblank line number
                              let prevline = prevnonblank(v:lnum - 1)
                            
                              " If we got a closing bracket on an empty line, find its match and indent
                              " according to it.  For parentheses we indent to its column - 1, for the
                              " others we indent to the containing line's MSL's level.  Return -1 if fail.
                              let col = matchend(line, '^\s*[],})]')
                              if col > 0 && !s:IsInStringOrComment(v:lnum, col)
                                call cursor(v:lnum, col)
                            
                                let lvar = s:InMultiVarStatement(v:lnum)
                                if lvar
                                  let prevline_contents = s:RemoveTrailingComments(getline(prevline))
                            
                                  " check for comma first
                                  if (line[col - 1] =~ ',')
                                    " if the previous line ends in comma or semicolon don't indent
                                    if (prevline_contents =~ '[;,]\s*$')
                                      return indent(s:GetMSL(line('.'), 0))
                                    " get previous line indent, if it's comma first return prevline indent
                                    elseif (prevline_contents =~ s:comma_first)
                                      return indent(prevline)
                                    " otherwise we indent 1 level
                                    else
                                      return indent(lvar) + &sw
                                    endif
                                  endif
                                endif
                            
                            
                                let bs = strpart('(){}[]', stridx(')}]', line[col - 1]) * 2, 2)
                                if searchpair(escape(bs[0], '\['), '', bs[1], 'bW', s:skip_expr) > 0
                                  if line[col-1]==')' && col('.') != col('$') - 1
                                    let ind = virtcol('.')-1
                                  else
                                    let ind = indent(s:GetMSL(line('.'), 0))
                                  endif
                                endif
                                return ind
                              endif
                            
                              " If the line is comma first, dedent 1 level
                              if (getline(prevline) =~ s:comma_first)
                                return indent(prevline) - &sw
                              endif
                            
                              if (line =~ s:ternary)
                                if (getline(prevline) =~ s:ternary_q)
                                  return indent(prevline)
                                else
                                  return indent(prevline) + &sw
                                endif
                              endif
                            
                              " If we are in a multi-line comment, cindent does the right thing.
                              if s:IsInMultilineComment(v:lnum, 1) && !s:IsLineComment(v:lnum, 1)
                                return cindent(v:lnum)
                              endif
                            
                              " Check for multiple var assignments
                            "  let var_indent = s:GetVarIndent(v:lnum)
                            "  if var_indent >= 0
                            "    return var_indent
                            "  endif
                            
                              " 3.3. Work on the previous line. {{{2
                              " -------------------------------
                            
                              " If the line is empty and the previous nonblank line was a multi-line
                              " comment, use that comment's indent. Deduct one char to account for the
                              " space in ' */'.
                              if line =~ '^\s*$' && s:IsInMultilineComment(prevline, 1)
                                return indent(prevline) - 1
                              endif
                            
                              " Find a non-blank, non-multi-line string line above the current line.
                              let lnum = s:PrevNonBlankNonString(v:lnum - 1)
                            
                              " If the line is empty and inside a string, use the previous line.
                              if line =~ '^\s*$' && lnum != prevline
                                return indent(prevnonblank(v:lnum))
                              endif
                            
                              " At the start of the file use zero indent.
                              if lnum == 0
                                return 0
                              endif
                            
                              " Set up variables for current line.
                              let line = getline(lnum)
                              let ind = indent(lnum)
                            
                              " If the previous line ended with a block opening, add a level of indent.
                              if s:Match(lnum, s:block_regex)
                                return indent(s:GetMSL(lnum, 0)) + &sw
                              endif
                            
                              " If the previous line contained an opening bracket, and we are still in it,
                              " add indent depending on the bracket type.
                              if line =~ '[[({]'
                                let counts = s:LineHasOpeningBrackets(lnum)
                                if counts[0] == '1' && searchpair('(', '', ')', 'bW', s:skip_expr) > 0
                                  if col('.') + 1 == col('$')
                                    return ind + &sw
                                  else
                                    return virtcol('.')
                                  endif
                                elseif counts[1] == '1' || counts[2] == '1'
                                  return ind + &sw
                                else
                                  call cursor(v:lnum, vcol)
                                end
                              endif
                            
                              " 3.4. Work on the MSL line. {{{2
                              " --------------------------
                            
                              let ind_con = ind
                              let ind = s:IndentWithContinuation(lnum, ind_con, &sw)
                            
                              " }}}2
                              "
                              "
                              let ols = s:InOneLineScope(lnum)
                              if ols > 0
                                let ind = ind + &sw
                              else
                                let ols = s:ExitingOneLineScope(lnum)
                                while ols > 0 && ind > 0
                                  let ind = ind - &sw
                                  let ols = s:InOneLineScope(ols - 1)
                                endwhile
                              endif
                            
                              return ind
                            endfunction
                            
                            " }}}1
                            
    1              0.000008 let &cpo = s:cpo_save
    1              0.000004 unlet s:cpo_save

SCRIPT  /Applications/MacVim.app/Contents/Resources/vim/runtime/indent/javascript.vim
Sourced 3 times
Total time:   0.000051
 Self time:   0.000051

count  total (s)   self (s)
                            " Vim indent file
                            " Language:	Javascript
                            " Maintainer:	None!  Wanna improve this?
                            " Last Change:	2007 Jan 22
                            
                            " Only load this indent file when no other was loaded.
    3              0.000026 if exists("b:did_indent")
    3              0.000007    finish

SCRIPT  /Users/admin/.vim/bundle/vim-javascript/syntax/javascript.vim
Sourced 3 times
Total time:   0.007135
 Self time:   0.007135

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:     JavaScript
                            " Maintainer:   vim-javascript community
                            " URL:          https://github.com/pangloss/vim-javascript
                            
    3              0.000025 if !exists("main_syntax")
    3              0.000010   if version < 600
                                syntax clear
                              elseif exists("b:current_syntax")
                                finish
                              endif
    3              0.000010   let main_syntax = 'javascript'
    3              0.000003 endif
                            
    3              0.000010 if !exists('g:javascript_conceal')
    1              0.000003   let g:javascript_conceal = 0
    1              0.000001 endif
                            
                            "" Drop fold if it is set but VIM doesn't support it.
    3              0.000008 let b:javascript_fold='true'
    3              0.000007 if version < 600    " Don't support the old version
                              unlet! b:javascript_fold
                            endif
                            
                            "" dollar sign is permittd anywhere in an identifier
    3              0.000198 setlocal iskeyword+=$
                            
    3              0.000011 syntax sync fromstart
                            
    3              0.000056 syntax match   jsNoise           /\%(:\|,\|\;\|\.\)/
                            
                            "" Program Keywords
    3              0.000023 syntax keyword jsStorageClass   const var let
    3              0.000022 syntax keyword jsOperator       delete instanceof typeof void new in
    3              0.000025 syntax match   jsOperator       /\(!\||\|&\|+\|-\|<\|>\|=\|%\|\/\|*\|\~\|\^\)/
    3              0.000017 syntax keyword jsBooleanTrue    true
    3              0.000015 syntax keyword jsBooleanFalse   false
                            
                            "" JavaScript comments
    3              0.000021 syntax keyword jsCommentTodo    TODO FIXME XXX TBD contained
    3              0.000061 syntax region  jsLineComment    start=+\/\/+ end=+$+ keepend contains=jsCommentTodo,@Spell
    3              0.000031 syntax region  jsEnvComment     start="\%^#!" end="$" display
    3              0.000059 syntax region  jsLineComment    start=+^\s*\/\/+ skip=+\n\s*\/\/+ end=+$+ keepend contains=jsCommentTodo,@Spell fold
    3              0.000039 syntax region  jsCvsTag         start="\$\cid:" end="\$" oneline contained
    3              0.000052 syntax region  jsComment        start="/\*"  end="\*/" contains=jsCommentTodo,jsCvsTag,@Spell fold
                            
                            "" JSDoc / JSDoc Toolkit
    3              0.000015 if !exists("javascript_ignore_javaScriptdoc")
    3              0.000007   syntax case ignore
                            
                              "" syntax coloring for javadoc comments (HTML)
                              "syntax include @javaHtml <sfile>:p:h/html.vim
                              "unlet b:current_syntax
                            
    3              0.000127   syntax region jsDocComment      matchgroup=jsComment start="/\*\*\s*"  end="\*/" contains=jsDocTags,jsCommentTodo,jsCvsTag,@jsHtml,@Spell fold
                            
                              " tags containing a param
    3              0.000103   syntax match  jsDocTags         contained "@\(alias\|augments\|borrows\|class\|constructs\|default\|defaultvalue\|emits\|exception\|exports\|extends\|file\|fires\|kind\|listens\|member\|memberOf\|mixes\|module\|name\|namespace\|requires\|throws\|var\|variation\|version\)\>" nextgroup=jsDocParam skipwhite
                              " tags containing type and param
    3              0.000049   syntax match  jsDocTags         contained "@\(arg\|argument\|param\|property\)\>" nextgroup=jsDocType skipwhite
                              " tags containing type but no param
    3              0.000060   syntax match  jsDocTags         contained "@\(callback\|enum\|external\|this\|type\|typedef\|return\|returns\)\>" nextgroup=jsDocTypeNoParam skipwhite
                              " tags containing references
    3              0.000034   syntax match  jsDocTags         contained "@\(lends\|see\)\>" nextgroup=jsDocSeeTag skipwhite
                              " other tags (no extra syntax)
    3              0.000098   syntax match  jsDocTags         contained "@\(abstract\|access\|author\|classdesc\|constant\|const\|constructor\|copyright\|deprecated\|desc\|description\|event\|example\|fileOverview\|function\|global\|ignore\|inner\|instance\|license\|method\|mixin\|overview\|private\|protected\|public\|readonly\|since\|static\|todo\|summary\|undocumented\|virtual\)\>"
                            
    3              0.000035   syntax region jsDocType         start="{" end="}" oneline contained nextgroup=jsDocParam skipwhite
    3              0.000037   syntax match  jsDocType         contained "\%(#\|\"\|\w\|\.\|:\|\/\)\+" nextgroup=jsDocParam skipwhite
    3              0.000024   syntax region jsDocTypeNoParam  start="{" end="}" oneline contained
    3              0.000023   syntax match  jsDocTypeNoParam  contained "\%(#\|\"\|\w\|\.\|:\|\/\)\+"
    3              0.000028   syntax match  jsDocParam        contained "\%(#\|\"\|{\|}\|\w\|\.\|:\|\/\)\+"
    3              0.000038   syntax region jsDocSeeTag       contained matchgroup=jsDocSeeTag start="{" end="}" contains=jsDocTags
                            
    3              0.000006   syntax case match
    3              0.000003 endif   "" JSDoc end
                            
    3              0.000005 syntax case match
                            
                            "" Syntax in the JavaScript code
    3              0.000032 syntax match   jsFuncCall        /\k\+\%(\s*(\)\@=/
    3              0.000034 syntax match   jsSpecial         "\v\\%(0|\\x\x\{2\}\|\\u\x\{4\}\|\c[A-Z]|.)"
    3              0.000053 syntax region  jsStringD         start=+"+  skip=+\\\\\|\\$"+  end=+"+  contains=jsSpecial,@htmlPreproc
    3              0.000077 syntax region  jsStringS         start=+'+  skip=+\\\\\|\\$'+  end=+'+  contains=jsSpecial,@htmlPreproc
    3              0.000030 syntax region  jsRegexpCharClass start=+\[+ end=+\]+ contained
    3              0.000039 syntax match   jsRegexpBoundary   "\v%(\<@![\^$]|\\[bB])" contained
    3              0.000027 syntax match   jsRegexpBackRef   "\v\\[1-9][0-9]*" contained
    3              0.000038 syntax match   jsRegexpQuantifier "\v\\@<!%([?*+]|\{\d+%(,|,\d+)?})\??" contained
    3              0.000023 syntax match   jsRegexpOr        "\v\<@!\|" contained
    3              0.000024 syntax match   jsRegexpMod       "\v\(@<=\?[:=!>]" contained
    3              0.000054 syntax cluster jsRegexpSpecial   contains=jsRegexpBoundary,jsRegexpBackRef,jsRegexpQuantifier,jsRegexpOr,jsRegexpMod
    3              0.000056 syntax region  jsRegexpGroup     start="\\\@<!(" end="\\\@<!)" contained contains=jsRegexpCharClass,@jsRegexpSpecial keepend
    3              0.000109 syntax region  jsRegexpString    start=+\(\(\(return\|case\)\s\+\)\@<=\|\(\([)\]"']\|\d\|\w\)\s*\)\@<!\)/\(\*\|/\)\@!+ skip=+\\\\\|\\/+ end=+/[gimy]\{,4}+ contains=jsSpecial,jsRegexpCharClass,jsRegexpGroup,@jsRegexpSpecial,@htmlPreproc oneline keepend
    3              0.000045 syntax match   jsNumber          /\<-\=\d\+L\=\>\|\<0[xX]\x\+\>/
    3              0.000014 syntax keyword jsNumber          Infinity
    3              0.000036 syntax match   jsFloat           /\<-\=\%(\d\+\.\d\+\|\d\+\.\|\.\d\+\)\%([eE][+-]\=\d\+\)\=\>/
    3              0.000056 syntax match   jsObjectKey       /\<[a-zA-Z_$][0-9a-zA-Z_$]*\(\s*:\)\@=/ contains=jsFunctionKey
    3              0.000027 syntax match   jsFunctionKey     /\<[a-zA-Z_$][0-9a-zA-Z_$]*\(\s*:\s*function\s*\)\@=/ contained
                            
                            "" JavaScript Prototype
    3              0.000016 syntax keyword jsPrototype      prototype
                            
    3              0.000011 if g:javascript_conceal == 1
                              syntax keyword jsNull           null conceal cchar=ø
                              syntax keyword jsThis           this conceal cchar=@
                              syntax keyword jsReturn         return conceal cchar=⇚
                              syntax keyword jsUndefined      undefined conceal cchar=¿
                              syntax keyword jsNan            NaN conceal cchar=ℕ
                            else
    3              0.000009   syntax keyword jsNull           null
    3              0.000009   syntax keyword jsThis           this
    3              0.000010   syntax keyword jsReturn         return
    3              0.000008   syntax keyword jsUndefined      undefined
    3              0.000009   syntax keyword jsNan            NaN
    3              0.000003 endif
                            
                            "" Statement Keywords
    3              0.000016 syntax keyword jsStatement      break continue with
    3              0.000016 syntax keyword jsConditional    if else switch
    3              0.000016 syntax keyword jsRepeat         do while for
    3              0.000015 syntax keyword jsLabel          case default
    3              0.000015 syntax keyword jsKeyword        yield
    3              0.000017 syntax keyword jsException      try catch throw finally
                            
    3              0.000082 syntax keyword jsGlobalObjects   Array Boolean Date Function Iterator Number Object RegExp String Proxy ParallelArray ArrayBuffer DataView Float32Array Float64Array Int16Array Int32Array Int8Array Uint16Array Uint32Array Uint8Array Uint8ClampedArray Intl JSON Math console document window
    3              0.000032 syntax match   jsGlobalObjects  /\%(Intl\.\)\@<=\(Collator\|DateTimeFormat\|NumberFormat\)/
                            
    3              0.000027 syntax keyword jsExceptions     Error EvalError InternalError RangeError ReferenceError StopIteration SyntaxError TypeError URIError
                            
    3              0.000025 syntax keyword jsBuiltins       decodeURI decodeURIComponent encodeURI encodeURIComponent eval isFinite isNaN parseFloat parseInt uneval
                            
    3              0.000057 syntax keyword jsFutureKeys     abstract enum int short boolean export interface static byte extends long super char final native synchronized class float package throws goto private transient debugger implements protected volatile double import public
                            
                            "" DOM/HTML/CSS specified things
                            
                              " DOM2 Objects
    3              0.000039   syntax keyword jsGlobalObjects  DOMImplementation DocumentFragment Document Node NodeList NamedNodeMap CharacterData Attr Element Text Comment CDATASection DocumentType Notation Entity EntityReference ProcessingInstruction
    3              0.000015   syntax keyword jsExceptions     DOMException
                            
                              " DOM2 CONSTANT
    3              0.000039   syntax keyword jsDomErrNo       INDEX_SIZE_ERR DOMSTRING_SIZE_ERR HIERARCHY_REQUEST_ERR WRONG_DOCUMENT_ERR INVALID_CHARACTER_ERR NO_DATA_ALLOWED_ERR NO_MODIFICATION_ALLOWED_ERR NOT_FOUND_ERR NOT_SUPPORTED_ERR INUSE_ATTRIBUTE_ERR INVALID_STATE_ERR SYNTAX_ERR INVALID_MODIFICATION_ERR NAMESPACE_ERR INVALID_ACCESS_ERR
    3              0.000043   syntax keyword jsDomNodeConsts  ELEMENT_NODE ATTRIBUTE_NODE TEXT_NODE CDATA_SECTION_NODE ENTITY_REFERENCE_NODE ENTITY_NODE PROCESSING_INSTRUCTION_NODE COMMENT_NODE DOCUMENT_NODE DOCUMENT_TYPE_NODE DOCUMENT_FRAGMENT_NODE NOTATION_NODE
                            
                              " HTML events and internal variables
    3              0.000022   syntax case ignore
    3              0.000111   syntax keyword jsHtmlEvents     onblur onclick oncontextmenu ondblclick onfocus onkeydown onkeypress onkeyup onmousedown onmousemove onmouseout onmouseover onmouseup onresize
    3              0.000011   syntax case match
                            
                            " Follow stuff should be highligh within a special context
                            " While it can't be handled with context depended with Regex based highlight
                            " So, turn it off by default
    3              0.000017 if exists("javascript_enable_domhtmlcss")
                            
                                " DOM2 things
                                syntax match jsDomElemAttrs     contained /\%(nodeName\|nodeValue\|nodeType\|parentNode\|childNodes\|firstChild\|lastChild\|previousSibling\|nextSibling\|attributes\|ownerDocument\|namespaceURI\|prefix\|localName\|tagName\)\>/
                                syntax match jsDomElemFuncs     contained /\%(insertBefore\|replaceChild\|removeChild\|appendChild\|hasChildNodes\|cloneNode\|normalize\|isSupported\|hasAttributes\|getAttribute\|setAttribute\|removeAttribute\|getAttributeNode\|setAttributeNode\|removeAttributeNode\|getElementsByTagName\|getAttributeNS\|setAttributeNS\|removeAttributeNS\|getAttributeNodeNS\|setAttributeNodeNS\|getElementsByTagNameNS\|hasAttribute\|hasAttributeNS\)\>/ nextgroup=jsParen skipwhite
                                " HTML things
                                syntax match jsHtmlElemAttrs    contained /\%(className\|clientHeight\|clientLeft\|clientTop\|clientWidth\|dir\|id\|innerHTML\|lang\|length\|offsetHeight\|offsetLeft\|offsetParent\|offsetTop\|offsetWidth\|scrollHeight\|scrollLeft\|scrollTop\|scrollWidth\|style\|tabIndex\|title\)\>/
                                syntax match jsHtmlElemFuncs    contained /\%(blur\|click\|focus\|scrollIntoView\|addEventListener\|dispatchEvent\|removeEventListener\|item\)\>/ nextgroup=jsParen skipwhite
                            
                                " CSS Styles in JavaScript
                                syntax keyword jsCssStyles      contained color font fontFamily fontSize fontSizeAdjust fontStretch fontStyle fontVariant fontWeight letterSpacing lineBreak lineHeight quotes rubyAlign rubyOverhang rubyPosition
                                syntax keyword jsCssStyles      contained textAlign textAlignLast textAutospace textDecoration textIndent textJustify textJustifyTrim textKashidaSpace textOverflowW6 textShadow textTransform textUnderlinePosition
                                syntax keyword jsCssStyles      contained unicodeBidi whiteSpace wordBreak wordSpacing wordWrap writingMode
                                syntax keyword jsCssStyles      contained bottom height left position right top width zIndex
                                syntax keyword jsCssStyles      contained border borderBottom borderLeft borderRight borderTop borderBottomColor borderLeftColor borderTopColor borderBottomStyle borderLeftStyle borderRightStyle borderTopStyle borderBottomWidth borderLeftWidth borderRightWidth borderTopWidth borderColor borderStyle borderWidth borderCollapse borderSpacing captionSide emptyCells tableLayout
                                syntax keyword jsCssStyles      contained margin marginBottom marginLeft marginRight marginTop outline outlineColor outlineStyle outlineWidth padding paddingBottom paddingLeft paddingRight paddingTop
                                syntax keyword jsCssStyles      contained listStyle listStyleImage listStylePosition listStyleType
                                syntax keyword jsCssStyles      contained background backgroundAttachment backgroundColor backgroundImage gackgroundPosition backgroundPositionX backgroundPositionY backgroundRepeat
                                syntax keyword jsCssStyles      contained clear clip clipBottom clipLeft clipRight clipTop content counterIncrement counterReset cssFloat cursor direction display filter layoutGrid layoutGridChar layoutGridLine layoutGridMode layoutGridType
                                syntax keyword jsCssStyles      contained marks maxHeight maxWidth minHeight minWidth opacity MozOpacity overflow overflowX overflowY verticalAlign visibility zoom cssText
                                syntax keyword jsCssStyles      contained scrollbar3dLightColor scrollbarArrowColor scrollbarBaseColor scrollbarDarkShadowColor scrollbarFaceColor scrollbarHighlightColor scrollbarShadowColor scrollbarTrackColor
                            
                                " Highlight ways
                                syntax match jsDotNotation      "\." nextgroup=jsPrototype,jsDomElemAttrs,jsDomElemFuncs,jsHtmlElemAttrs,jsHtmlElemFuncs
                                syntax match jsDotNotation      "\.style\." nextgroup=jsCssStyles
                            
                            endif "DOM/HTML/CSS
                            
                            "" end DOM/HTML/CSS specified things
                            
                            
                            "" Code blocks
    3              0.000295 syntax cluster jsExpression contains=jsComment,jsLineComment,jsDocComment,jsStringD,jsStringS,jsRegexpString,jsNumber,jsFloat,jsThis,jsOperator,jsBooleanTrue,jsBooleanFalse,jsNull,jsFunction,jsGlobalObjects,jsExceptions,jsFutureKeys,jsDomErrNo,jsDomNodeConsts,jsHtmlEvents,jsDotNotation,jsBracket,jsParen,jsBlock,jsFuncCall,jsUndefined,jsNan,jsKeyword,jsStorageClass,jsPrototype,jsBuiltins,jsNoise
    3              0.000080 syntax cluster jsAll        contains=@jsExpression,jsLabel,jsConditional,jsRepeat,jsReturn,jsStatement,jsTernaryIf,jsException
    3              0.000094 syntax region  jsBracket    matchgroup=jsBrackets     start="\[" end="\]" contains=@jsAll,jsParensErrB,jsParensErrC,jsBracket,jsParen,jsBlock,@htmlPreproc fold
    3              0.000079 syntax region  jsParen      matchgroup=jsParens       start="("  end=")"  contains=@jsAll,jsParensErrA,jsParensErrC,jsParen,jsBracket,jsBlock,@htmlPreproc fold
    3              0.000081 syntax region  jsBlock      matchgroup=jsBraces       start="{"  end="}"  contains=@jsAll,jsParensErrA,jsParensErrB,jsParen,jsBracket,jsBlock,jsObjectKey,@htmlPreproc fold
    3              0.000071 syntax region  jsFuncBlock  matchgroup=jsFuncBraces   start="{"  end="}"  contains=@jsAll,jsParensErrA,jsParensErrB,jsParen,jsBracket,jsBlock,@htmlPreproc contained fold
    3              0.000094 syntax region  jsTernaryIf  matchgroup=jsTernaryIfOperator start=+?+  end=+:+  contains=@jsExpression,jsTernaryIf
                            
                            "" catch errors caused by wrong parenthesis
    3              0.000026 syntax match   jsParensError    ")\|}\|\]"
    3              0.000014 syntax match   jsParensErrA     contained "\]"
    3              0.000013 syntax match   jsParensErrB     contained ")"
    3              0.000012 syntax match   jsParensErrC     contained "}"
                            
    3              0.000012 if main_syntax == "javascript"
    3              0.000008   syntax sync clear
    3              0.000013   syntax sync ccomment jsComment minlines=200
    3              0.000026   syntax sync match jsHighlight grouphere jsBlock /{/
    3              0.000004 endif
                            
    3              0.000007 if g:javascript_conceal == 1
                              syntax match   jsFunction       /\<function\>/ nextgroup=jsFuncName,jsFuncArgs skipwhite conceal cchar=ƒ
                            else
    3              0.000031   syntax match   jsFunction       /\<function\>/ nextgroup=jsFuncName,jsFuncArgs skipwhite
    3              0.000003 endif
                            
    3              0.000027 syntax match   jsFuncName       contained /\<[a-zA-Z_$][0-9a-zA-Z_$]*/ nextgroup=jsFuncArgs skipwhite
    3              0.000050 syntax region  jsFuncArgs       contained matchgroup=jsFuncParens start='(' end=')' contains=jsFuncArgCommas nextgroup=jsFuncBlock keepend skipwhite skipempty
    3              0.000012 syntax match   jsFuncArgCommas  contained ','
    3              0.000024 syntax keyword jsArgsObj        arguments contained containedin=jsFuncBlock
                            
                            " Define the default highlighting.
                            " For version 5.7 and earlier: only when not done already
                            " For version 5.8 and later: only when an item doesn't have highlighting yet
    3              0.000012 if version >= 508 || !exists("did_javascript_syn_inits")
    3              0.000006   if version < 508
                                let did_javascript_syn_inits = 1
                                command -nargs=+ HiLink hi link <args>
                              else
    3              0.000030     command -nargs=+ HiLink hi def link <args>
    3              0.000004   endif
    3              0.000062   HiLink jsComment              Comment
    3              0.000032   HiLink jsLineComment          Comment
    3              0.000029   HiLink jsEnvComment           PreProc
    3              0.000028   HiLink jsDocComment           Comment
    3              0.000028   HiLink jsCommentTodo          Todo
    3              0.000030   HiLink jsCvsTag               Function
    3              0.000028   HiLink jsDocTags              Special
    3              0.000028   HiLink jsDocSeeTag            Function
    3              0.000027   HiLink jsDocType              Type
    3              0.000029   HiLink jsDocTypeNoParam       Type
    3              0.000029   HiLink jsDocParam             Label
    3              0.000028   HiLink jsStringS              String
    3              0.000028   HiLink jsStringD              String
    3              0.000029   HiLink jsTernaryIfOperator    Conditional
    3              0.000028   HiLink jsRegexpString         String
    3              0.000028   HiLink jsRegexpBoundary       SpecialChar
    3              0.000028   HiLink jsRegexpQuantifier     SpecialChar
    3              0.000030   HiLink jsRegexpOr             Conditional
    3              0.000027   HiLink jsRegexpMod            SpecialChar
    3              0.000028   HiLink jsRegexpBackRef        SpecialChar
    3              0.000019   HiLink jsRegexpGroup          jsRegexpString
    3              0.000034   HiLink jsRegexpCharClass      Character
    3              0.000035   HiLink jsCharacter            Character
    3              0.000028   HiLink jsPrototype            Special
    3              0.000027   HiLink jsConditional          Conditional
    3              0.000031   HiLink jsBranch               Conditional
    3              0.000028   HiLink jsLabel                Label
    3              0.000028   HiLink jsReturn               Statement
    3              0.000025   HiLink jsRepeat               Repeat
    3              0.000028   HiLink jsStatement            Statement
    3              0.000027   HiLink jsException            Exception
    3              0.000027   HiLink jsKeyword              Keyword
    3              0.000032   HiLink jsFunction             Type
    3              0.000032   HiLink jsFuncName             Function
    3              0.000037   HiLink jsArgsObj              Special
    3              0.000049   HiLink jsError                Error
    3              0.000049   HiLink jsParensError          Error
    3              0.000028   HiLink jsParensErrA           Error
    3              0.000028   HiLink jsParensErrB           Error
    3              0.000026   HiLink jsParensErrC           Error
    3              0.000028   HiLink jsOperator             Operator
    3              0.000028   HiLink jsStorageClass         StorageClass
    3              0.000028   HiLink jsThis                 Special
    3              0.000029   HiLink jsNan                  Number
    3              0.000026   HiLink jsNull                 Type
    3              0.000027   HiLink jsUndefined            Type
    3              0.000027   HiLink jsNumber               Number
    3              0.000027   HiLink jsFloat                Float
    3              0.000029   HiLink jsBooleanTrue          Boolean
    3              0.000028   HiLink jsBooleanFalse         Boolean
    3              0.000022   HiLink jsNoise                Noise
    3              0.000014   HiLink jsBrackets             Noise
    3              0.000015   HiLink jsParens               Noise
    3              0.000016   HiLink jsBraces               Noise
    3              0.000012   HiLink jsFuncBraces           Noise
    3              0.000013   HiLink jsFuncParens           Noise
    3              0.000028   HiLink jsSpecial              Special
    3              0.000026   HiLink jsGlobalObjects        Special
    3              0.000027   HiLink jsExceptions           Special
    3              0.000027   HiLink jsFutureKeys           Special
    3              0.000026   HiLink jsBuiltins             Special
                            
    3              0.000028   HiLink jsDomErrNo             Constant
    3              0.000028   HiLink jsDomNodeConsts        Constant
    3              0.000028   HiLink jsDomElemAttrs         Label
    3              0.000026   HiLink jsDomElemFuncs         PreProc
                            
    3              0.000028   HiLink jsHtmlEvents           Special
    3              0.000027   HiLink jsHtmlElemAttrs        Label
    3              0.000026   HiLink jsHtmlElemFuncs        PreProc
                            
    3              0.000026   HiLink jsCssStyles            Label
                            
    3              0.000008   delcommand HiLink
    3              0.000003 endif
                            
                            " Define the htmlJavaScript for HTML syntax html.vim
                            "syntax clear htmlJavaScript
                            "syntax clear jsExpression
    3              0.000035 syntax cluster  htmlJavaScript       contains=@jsAll,jsBracket,jsParen,jsBlock
    3              0.000034 syntax cluster  javaScriptExpression contains=@jsAll,jsBracket,jsParen,jsBlock,@htmlPreproc
                            " Vim's default html.vim highlights all javascript as 'Special'
    3              0.000017 hi! def link javaScript              NONE
                            
    3              0.000013 let b:current_syntax = "javascript"
    3              0.000009 if main_syntax == 'javascript'
    3              0.000007   unlet main_syntax
    3              0.000009 endif

SCRIPT  /Applications/MacVim.app/Contents/Resources/vim/runtime/syntax/javascript.vim
Sourced 3 times
Total time:   0.000133
 Self time:   0.000133

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:	JavaScript
                            " Maintainer:	Claudio Fleiner <claudio@fleiner.com>
                            " Updaters:	Scott Shattuck (ss) <ss@technicalpursuit.com>
                            " URL:		http://www.fleiner.com/vim/syntax/javascript.vim
                            " Changes:	(ss) added keywords, reserved words, and other identifiers
                            "		(ss) repaired several quoting and grouping glitches
                            "		(ss) fixed regex parsing issue with multiple qualifiers [gi]
                            "		(ss) additional factoring of keywords, globals, and members
                            " Last Change:	2012 Oct 05
                            " 		2013 Jun 12: adjusted javaScriptRegexpString (Kevin Locke)
                            
                            " For version 5.x: Clear all syntax items
                            " For version 6.x: Quit when a syntax file was already loaded
                            " tuning parameters:
                            " unlet javaScript_fold
                            
    3              0.000033 if !exists("main_syntax")
    3              0.000012   if version < 600
                                syntax clear
                              elseif exists("b:current_syntax")
    3              0.000006     finish

SCRIPT  /Users/admin/.vim/bundle/javascript-libraries-syntax.vim/after/syntax/javascript.vim
Sourced 3 times
Total time:   0.020311
 Self time:   0.000171

count  total (s)   self (s)
                            " Vim plugin file
                            " Language:    
                            " Maintainer:  othree <othree@gmail.com>
                            " Last Change: 2013/08/26
                            " Version:     0.4.1
                            " URL:         https://github.com/othree/javascript-libraries-syntax.vim
                            
    3              0.000016 if b:current_syntax == 'javascript'
    3   0.012155   0.000098   call jslibsyntax#load()
    3              0.000010 endif

SCRIPT  /Users/admin/.vim/bundle/javascript-libraries-syntax.vim/autoload/jslibsyntax.vim
Sourced 1 time
Total time:   0.000057
 Self time:   0.000057

count  total (s)   self (s)
                            " Vim plugin file
                            " Language:    JS Lib syntax loader
                            " Maintainer:  othree <othree@gmail.com>
                            " Last Change: 2013/02/24
                            " Version:     0.3
                            " URL:         https://github.com/othree/javascript-libraries-syntax.vim
                            
    1              0.000009 let s:libs = [
                              \ 'jquery',
                              \ 'underscore',
                              \ 'backbone',
                              \ 'prelude',
                              \ 'angularjs',
                              \ 'requirejs',
                              \ 'sugar'
                              \ ]
                            
    1              0.000010 let s:path = expand('<sfile>:p:h')
                            
    1              0.000004 function! jslibsyntax#load()
                              if !exists('g:used_javascript_libs') 
                                let g:used_javascript_libs = join(s:libs, ',')
                              endif
                            
                              let index = 0
                              let loaded = 0
                              while index < len(s:libs)
                                let lib = s:libs[index]
                                let use = g:used_javascript_libs =~ lib
                                if exists('b:javascript_lib_use_'.lib)
                                  exec('let use = b:javascript_lib_use_'.lib)
                                endif
                                if use
                                  let fn = s:path.'/syntax/'.lib.'.'.&filetype.'.vim'
                                  if filereadable(fn)
                                    exe('source '.fnameescape(fn))
                                    let loaded = loaded + 1
                                  endif
                                endif
                                let index = index + 1
                              endwhile
                              let fn = s:path.'/syntax/postprocess.'.&filetype.'.vim'
                              if loaded > 0 && filereadable(fn)
                                exe('source '.fnameescape(fn))
                              endif
                            endfunction
                            

SCRIPT  /Users/admin/.vim/bundle/javascript-libraries-syntax.vim/autoload/syntax/jquery.javascript.vim
Sourced 3 times
Total time:   0.003246
 Self time:   0.003246

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:    jQuery for javascript
                            " Maintainer:  othree <othree@gmail.com>
                            " Maintainer:  Bruno Michel <brmichel@free.fr>
                            " Last Change: 2013/07/26
                            " Version:     1.9.0.2
                            " URL:         http://api.jquery.com/
                            
    3              0.000218 setlocal iskeyword+=$
                            
    3              0.000079 syntax keyword javascriptjQuery          containedin=ALLBUT,javascriptComment,javascriptLineComment,javascriptString jQuery $
                            " syntax match   javascriptjQuerydot       contained /\./ nextgroup=@javascriptQGlobals
                            " syntax match   javascriptjQuerydot       contained /([^)]*)\./ nextgroup=@javascriptQFunctions
                            
                            " jQuery.*
    3              0.000077 syntax cluster javascriptQGlobals        contains=javascriptQCore,javascriptQCoreObj,javascriptQCoreData,javascriptQUtilities,javascriptQProperties
    3              0.000018 syntax keyword javascriptQCore           contained holdReady noConflict when
    3              0.000015 syntax keyword javascriptQCoreObj        contained Callback Deferred
    3              0.000056 syntax keyword javascriptQCoreData       contained data dequeue hasData queue removeData
    3              0.000120 syntax keyword javascriptQCoreAjax       contained ajax ajaxPrefilter ajaxSetup ajaxTransport param get getJSON getScript post
    3              0.000081 syntax keyword javascriptQProperties     contained context fx.interval fx.off length support cssHooks
    3              0.000207 syntax keyword javascriptQUtilities      contained each extend globalEval grep inArray isArray isEmptyObject isFunction isPlainObject isWindow isXMLDoc makeArray map merge noop now parseHTML parseJSON parseXML proxy trim type unique
    3              0.000025 syntax match   javascriptQUtilities      contained /contains/
                            
                            " jqobj.*
    3              0.000198 syntax cluster javascriptQFunctions      contains=@javascriptQGlobals,javascriptQAjax,javascriptQAttributes,javascriptQCallbacks,javascriptQCore,javascriptQCSS,javascriptQData,javascriptQDeferred,javascriptQDimensions,javascriptQEffects,javascriptQEvents,javascriptQManipulation,javascriptQMiscellaneous,javascriptQOffset,javascriptQTraversing,javascriptQUtilities
    3              0.000021 syntax keyword javascriptQAjax           contained ajaxComplete ajaxError ajaxSend ajaxStart ajaxStop ajaxSuccess
    3              0.000013 syntax keyword javascriptQAjax           contained serialize serializeArray ajaxTransport load
    3              0.000016 syntax keyword javascriptQAttributes     contained addClass attr hasClass html prop removeAttr removeClass removeProp toggleClass val
    3              0.000019 syntax keyword javascriptQCallbacks      contained add disable disabled empty fire fired fireWith has lock locked remove Callbacks
    3              0.000010 syntax keyword javascriptQCSS            contained css
    3              0.000014 syntax keyword javascriptQData           contained clearQueue data dequeue queue removeData
    3              0.000024 syntax keyword javascriptQDeferred       contained Deferred always done fail notify progress promise reject rejectWith resolved resolveWith notifyWith state then
    3              0.000015 syntax keyword javascriptQDimensions     contained height innerHeight innerWidth outerHeight outerWidth width
    3              0.000013 syntax keyword javascriptQEffects        contained hide show toggle
    3              0.000032 syntax keyword javascriptQEffects        contained animate delay stop
    3              0.000032 syntax keyword javascriptQEffects        contained fadeIn fadeOut fadeTo fadeToggle
    3              0.000019 syntax keyword javascriptQEffects        contained slideDown slideToggle slideUp
    3              0.000015 syntax keyword javascriptQEvents         contained error resize scroll
    3              0.000013 syntax keyword javascriptQEvents         contained ready unload
    3              0.000031 syntax keyword javascriptQEvents         contained bind delegate on off one proxy trigger triggerHandler unbind undelegate
    3              0.000037 syntax keyword javascriptQEvents         contained Event currentTarget isDefaultPrevented isImmediatePropagationStopped isPropagationStopped namespace pageX pageY preventDefault relatedTarget result stopImmediatePropagation stopPropagation target timeStamp which
    3              0.000019 syntax keyword javascriptQEvents         contained blur change focus select submit
    3              0.000018 syntax keyword javascriptQEvents         contained focusin focusout keydown keypress keyup
    3              0.000023 syntax keyword javascriptQEvents         contained click dblclick hover mousedown mouseenter mouseleave mousemove mouseout mouseover mouseup
    3              0.000013 syntax keyword javascriptQManipulation   contained clone
    3              0.000038 syntax keyword javascriptQManipulation   contained unwrap wrap wrapAll wrapInner
    3              0.000019 syntax keyword javascriptQManipulation   contained append appendTo html preprend prependTo text
    3              0.000015 syntax keyword javascriptQManipulation   contained after before insertAfter insertBefore
    3              0.000015 syntax keyword javascriptQManipulation   contained detach empty remove
    3              0.000012 syntax keyword javascriptQManipulation   contained replaceAll replaceWith
    3              0.000012 syntax keyword javascriptQMiscellaneous  contained index toArray
    3              0.000018 syntax keyword javascriptQOffset         contained offset offsetParent position scrollTop scrollLeft
    3              0.000032 syntax keyword javascriptQTraversing     contained eq filter first has is last map not slice
    3              0.000016 syntax keyword javascriptQTraversing     contained add andBack contents end
    3              0.000037 syntax keyword javascriptQTraversing     contained children closest find next nextAll nextUntil parent parents parentsUntil prev prevAll prevUntil siblings
                            
                            
                            " selector
    3              0.000074 syntax region  javascriptString           start=+"+  skip=+\\\\\|\\"+  end=+"\|$+  contains=javascriptSpecial,@htmlPreproc,@jSelectors
    3              0.000051 syntax region  javascriptString           start=+'+  skip=+\\\\\|\\'+  end=+'\|$+  contains=javascriptSpecial,@htmlPreproc,@jSelectors
                            
    3              0.000112 syntax cluster jSelectors      contains=jId,jClass,jOperators,jBasicFilters,jContentFilters,jVisibility,jChildFilters,jForms,jFormFilters
    3              0.000027 syntax match   jId             contained /#[0-9A-Za-z_\-]\+/
    3              0.000019 syntax match   jClass          contained /\.[0-9A-Za-z_\-]\+/
    3              0.000018 syntax match   jOperators      contained /*\|>\|+\|-\|\~/
    3              0.000033 syntax match   jBasicFilters   contained /:\(animated\|eq\|even\|first\|focus\|gt\|header\|last\|lang\|lt\|not\|odd\|root\|target\)/
    3              0.000023 syntax match   jChildFilters   contained /:\(first\|last\|nth\|only\|nth-last\)-child/
    3              0.000021 syntax match   jChildFilters   contained /:\(first\|last\|nth\|only\|nth-last\)-of-type/
    3              0.000017 syntax match   jContentFilters contained /:\(contains\|empty\|has\|parent\)/
    3              0.000039 syntax match   jForms          contained /:\(button\|checkbox\|checked\|disabled\|enabled\|file\|image\|input\|password\|radio\|reset\|selected\|submit\|text\)/
    3              0.000018 syntax match   jVisibility     contained /:\(hidden\|visible\)/
                            
                            " Define the default highlighting.
                            " For version 5.7 and earlier: only when not done already
                            " For version 5.8 and later: only when an item doesn't have highlighting yet
    3              0.000017 if version >= 508 || !exists("did_jquery_javascript_syntax_inits")
    3              0.000006   if version < 508
                                let did_jquery_javascript_syntax_inits = 1
                                command -nargs=+ HiLink hi link <args>
                              else
    3              0.000028     command -nargs=+ HiLink hi def link <args>
    3              0.000005   endif
                            
    3              0.000059   HiLink javascriptjQuery          Constant
                            
    3              0.000032   HiLink javascriptQCore           PreProc
    3              0.000029   HiLink javascriptQCoreObj        PreProc
    3              0.000029   HiLink javascriptQCoreData       PreProc
                            
    3              0.000030   HiLink javascriptQAjax           PreProc
    3              0.000027   HiLink javascriptQAttributes     PreProc
    3              0.000028   HiLink javascriptQCallbacks      PreProc
    3              0.000028   HiLink javascriptQCSS            PreProc
    3              0.000028   HiLink javascriptQData           PreProc
    3              0.000028   HiLink javascriptQDeferred       PreProc
    3              0.000027   HiLink javascriptQDimensions     PreProc
    3              0.000027   HiLink javascriptQEffects        PreProc
    3              0.000028   HiLink javascriptQEvents         PreProc
    3              0.000028   HiLink javascriptQManipulation   PreProc
    3              0.000026   HiLink javascriptQMiscellaneous  PreProc
    3              0.000027   HiLink javascriptQOffset         PreProc
    3              0.000028   HiLink javascriptQProperties     PreProc
    3              0.000031   HiLink javascriptQTraversing     PreProc
    3              0.000027   HiLink javascriptQUtilities      PreProc
                            
    3              0.000029   HiLink jId             Identifier
    3              0.000028   HiLink jClass          Constant
    3              0.000039   HiLink jOperators      Special
    3              0.000038   HiLink jBasicFilters   Statement
    3              0.000037   HiLink jContentFilters Statement
    3              0.000046   HiLink jVisibility     Statement
    3              0.000037   HiLink jChildFilters   Statement
    3              0.000032   HiLink jForms          Statement
    3              0.000031   HiLink jFormFilters    Statement
                            
                            
    3              0.000009   delcommand HiLink
    3              0.000013 endif

SCRIPT  /Users/admin/.vim/bundle/javascript-libraries-syntax.vim/autoload/syntax/underscore.javascript.vim
Sourced 3 times
Total time:   0.000801
 Self time:   0.000801

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:    underscore.js for javascript
                            " Maintainer:  othree <othree@gmail.com>
                            " Last Change: 2013/07/26
                            " Version:     1.4.4.2
                            " URL:         http://underscorejs.org/
                            " LoDash:      1.2.0
                            " URL:         http://lodash.com/
                            
    3              0.000052 syntax keyword javascriptunderscore containedin=ALLBUT,javascriptComment,javascriptLineComment,javascriptString _
                            " syntax match   javascriptunderscoredot contained /\./ nextgroup=@javascript_Functions
                            " syntax match   javascriptunderscoredot contained /([^)]*)\./ nextgroup=@javascript_Functions
                            
    3              0.000085 syntax cluster javascript_Functions contains=javascript_collections,javascript_arrays,javascript_functions,javascript_objects,javascript_chaining,javascript_lodash
                            
    3              0.000020 syntax match   javascript_collections contained /contains/
    3              0.000022 syntax keyword javascript_collections contained each map reduce reduceRight find filter where findWhere
    3              0.000017 syntax keyword javascript_collections contained reject every some invoke pluck max min sortBy
    3              0.000014 syntax keyword javascript_collections contained groupBy countBy shuffle toArray size
    3              0.000018 syntax keyword javascript_arrays contained first initial last rest compact flatten without union
    3              0.000017 syntax keyword javascript_arrays contained intersection difference uniq zip object indextOf
    3              0.000011 syntax keyword javascript_arrays contained lastIndexOf sortedIndex range
    3              0.000018 syntax keyword javascript_functions contained bind bindAll partial memoize delay throttle debounce
    3              0.000013 syntax keyword javascript_functions contained once after wrap compose
    3              0.000017 syntax keyword javascript_objects contained keys values pairs invert functions extend pick omit
    3              0.000016 syntax keyword javascript_objects contained defaults clone tap has isEqual isEmpty isElement isArray
    3              0.000012 syntax keyword javascript_objects contained isObject isArguments isFunction isString isNumber
    3              0.000015 syntax keyword javascript_objects contained isFinite isBoolean isDate isRegExp isNaN isNull 
    3              0.000010 syntax keyword javascript_objects contained isUndefined
    3              0.000021 syntax keyword javascript_utility contained noConflict identify times random mixin uniqueId
    3              0.000013 syntax keyword javascript_utility contained escape unescape result template
    3              0.000010 syntax keyword javascript_chaining contained chain value
                            
    3              0.000015 syntax keyword javascript_lodash contained at bindKey cloneDeep createCallback findIndex findKey
    3              0.000017 syntax keyword javascript_lodash contained forEach forIn forOwn isPlainObject merge parseInt partial
    3              0.000012 syntax keyword javascript_lodash contained partialRight runInContext support unzip where 
                            
                            
                            " Define the default highlighting.
                            " For version 5.7 and earlier: only when not done already
                            " For version 5.8 and later: only when an item doesn't have highlighting yet
    3              0.000013 if version >= 508 || !exists("did_underscore_javascript_syntax_inits")
    3              0.000006   if version < 508
                                let did_underscore_javascript_syntax_inits = 1
                                command -nargs=+ HiLink hi link <args>
                              else
    3              0.000024     command -nargs=+ HiLink hi def link <args>
    3              0.000004   endif
                            
    3              0.000039   HiLink javascriptunderscore      Constant
                            
    3              0.000030   HiLink javascript_collections    PreProc
    3              0.000029   HiLink javascript_arrays         PreProc
    3              0.000029   HiLink javascript_functions      PreProc
    3              0.000028   HiLink javascript_objects        PreProc
    3              0.000027   HiLink javascript_utility        PreProc
    3              0.000029   HiLink javascript_chaining       PreProc
                            
                            
    3              0.000006   delcommand HiLink
    3              0.000013 endif

SCRIPT  /Users/admin/.vim/bundle/javascript-libraries-syntax.vim/autoload/syntax/backbone.javascript.vim
Sourced 3 times
Total time:   0.001143
 Self time:   0.001143

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:    Backbone.js for javascript
                            " Maintainer:  othree <othree@gmail.com>
                            " Last Change: 2013/07/26
                            " Version:     0.9.10
                            " URL:         http://backbonejs.org/
                            
    3              0.000096 syntax keyword javascriptBackbone Backbone Collection Model View Events Router History Sync Utility containedin=ALLBUT,javascriptComment,javascriptLineComment,javascriptString
                            
    3              0.000123 syntax cluster javascriptBFunctions contains=javascriptBEvents,javascriptBModel,javascriptBCollection,javascriptBRouter,javascriptBHistory,javascriptBSync,javascriptBView,javascriptBUtility
    3              0.000088 syntax cluster javascriptBAttrs contains=javascriptBModelAttrs,javascriptBCollectionAttrs,javascriptBRouterAttrs,javascriptBSyncAttrs,javascriptBViewAttrs
                            
    3              0.000018 syntax keyword javascriptBEvents contained on off trigger once listenTo stopListening
    3              0.000022 syntax keyword javascriptBModel contained extend constructor initialize get set escape has unset clear
    3              0.000022 syntax keyword javascriptBModel contained toJSON sync fetch save destroy validate validationError url parse
    3              0.000018 syntax keyword javascriptBModel contained clone isNew hasChanged changedAttributes previous previousAttributes
    3              0.000022 syntax keyword javascriptBCollection contained extend constructor initialize toJSON sync add remove reset update get at 
    3              0.000032 syntax keyword javascriptBCollection contained push pop unshift shift length comparator sort pluck where url parse clone fetch create
    3              0.000015 syntax keyword javascriptBRouter contained extend constructor initialize route navigate
    3              0.000011 syntax keyword javascriptBHistory contained start
    3              0.000018 syntax keyword javascriptBSync contained ajax 
    3              0.000020 syntax keyword javascriptBView contained extend constructor initialize setElement render remove delegateEvents undelegateEvents
    3              0.000009 syntax keyword javascriptBUtility contained noConflict 
                            
    3              0.000015 syntax keyword javascriptBModelAttrs contained id idAttribute cid attributes changed defaults urlRoot
    3              0.000014 syntax keyword javascriptBCollectionAttrs contained model models length comparator url
    3              0.000007 syntax keyword javascriptBRouterAttrs contained routes
    3              0.000010 syntax keyword javascriptBSyncAttrs contained emulateHTTP emulateJSON
    3              0.000011 syntax keyword javascriptBViewAttrs contained el attributes
    3              0.000009 syntax keyword javascriptBViewAttrs match /$el/
                            
                            
                            " Define the default highlighting.
                            " For version 5.7 and earlier: only when not done already
                            " For version 5.8 and later: only when an item doesn't have highlighting yet
    3              0.000014 if version >= 508 || !exists("did_backbone_javascript_syntax_inits")
    3              0.000006   if version < 508
                                let did_backbone_javascript_syntax_inits = 1
                                command -nargs=+ HiLink hi link <args>
                              else
    3              0.000025     command -nargs=+ HiLink hi def link <args>
    3              0.000004   endif
                            
    3              0.000040   HiLink javascriptBackbone         Constant
                            
    3              0.000030   HiLink javascriptBEvents          PreProc
    3              0.000028   HiLink javascriptBModel           PreProc
    3              0.000029   HiLink javascriptBCollection      PreProc
    3              0.000028   HiLink javascriptBRouter          PreProc
    3              0.000028   HiLink javascriptBHistory         PreProc
    3              0.000029   HiLink javascriptBSync            PreProc
    3              0.000028   HiLink javascriptBView            PreProc
    3              0.000027   HiLink javascriptBUtility         PreProc
                            
    3              0.000028   HiLink javascriptBModelAttrs      PreProc
    3              0.000029   HiLink javascriptBCollectionAttrs PreProc
    3              0.000029   HiLink javascriptBRouterAttrs     PreProc
    3              0.000028   HiLink javascriptBSyncAttrs       PreProc
    3              0.000028   HiLink javascriptBViewAttrs       PreProc
                            
                            
    3              0.000008   delcommand HiLink
    3              0.000012 endif

SCRIPT  /Users/admin/.vim/bundle/javascript-libraries-syntax.vim/autoload/syntax/prelude.javascript.vim
Sourced 3 times
Total time:   0.000393
 Self time:   0.000393

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:    prelude.ls for javascript
                            " Maintainer:  othree <othree@gmail.com>
                            " Last Change: 2013/07/26
                            " Version:     0.6.0
                            " URL:         http://gkz.github.com/prelude-ls/
                            
    3              0.000032 syntax cluster javascriptpFunctions contains=javascriptpFunction
                            
    3              0.000021 syntax keyword javascriptpFunction contained map filter reject partition find each head tail last initial
    3              0.000025 syntax keyword javascriptpFunction contained empty values keys length cons append join reverse fold fold1
    3              0.000020 syntax keyword javascriptpFunction contained foldr foldr1 unfold andList orList any all unique sort sortBy
    3              0.000019 syntax keyword javascriptpFunction contained compare sum product mean concat concatMap maximum minimum scan scan1
    3              0.000020 syntax keyword javascriptpFunction contained scanr scanr1 replicate take drop splitAt takeWhile dropWhile span breakIt
    3              0.000018 syntax keyword javascriptpFunction contained listToObj objToFunc zip zipWith zipAll zipAllWith compose curry id flip
    3              0.000017 syntax keyword javascriptpFunction contained fix lines unlines words unwords max min negate abs signum
    3              0.000018 syntax keyword javascriptpFunction contained quot rem div mod recip pi tau exp sqrt ln
    3              0.000022 syntax keyword javascriptpFunction contained pow sin cos tan asin acos atan atan2 truncate round
    3              0.000018 syntax keyword javascriptpFunction contained ceiling floor isItNaN even odd gcd lcm
                            
                            
                            " Define the default highlighting.
                            " For version 5.7 and earlier: only when not done already
                            " For version 5.8 and later: only when an item doesn't have highlighting yet
    3              0.000013 if version >= 508 || !exists("did_prelude_javascript_syntax_inits")
    3              0.000008   if version < 508
                                let did_prelude_javascript_syntax_inits = 1
                                command -nargs=+ HiLink hi link <args>
                              else
    3              0.000024     command -nargs=+ HiLink hi def link <args>
    3              0.000003   endif
                            
    3              0.000039   HiLink javascriptpFunction        PreProc
                            
                            
    3              0.000008   delcommand HiLink
    3              0.000012 endif

SCRIPT  /Users/admin/.vim/bundle/javascript-libraries-syntax.vim/autoload/syntax/angularjs.javascript.vim
Sourced 3 times
Total time:   0.002308
 Self time:   0.002308

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:    AngularJS for javascript
                            " Maintainer:  othree <othree@gmail.com>
                            " Last Change: 2013/07/26
                            " Version:     1.1.13.1
                            " URL:         http://angularjs.org/
                            
    3              0.000205 setlocal iskeyword+=$
                            
    3              0.000074 syntax keyword javascriptAngular angular containedin=ALLBUT,javascriptComment,javascriptLineComment,javascriptString nextgroup=javascriptAngulardot
    3              0.000038 syntax match   javascriptAngulardot contained /\./ nextgroup=javascriptAngularMethods
    3              0.000017 syntax keyword javascriptAngularMethods contained bind bootstrap copy element equals
    3              0.000016 syntax keyword javascriptAngularMethods contained extend forEach fromJson identity injector
    3              0.000017 syntax keyword javascriptAngularMethods contained isArray isDate isDefined isElement isFunction
    3              0.000015 syntax keyword javascriptAngularMethods contained isNumber isObject isString isUndefined lowercase
    3              0.000016 syntax keyword javascriptAngularMethods contained mock module noop toJson uppercase version
                            
    3              0.000056 syntax keyword javascriptAServices containedin=ALLBUT,javascriptComment,javascriptLineComment,javascriptString $anchorScroll $cacheFactory $compile $controller $document
    3              0.000042 syntax keyword javascriptAServices containedin=ALLBUT,javascriptComment,javascriptLineComment,javascriptString $exceptionHandler $filter $httpBackend
    3              0.000041 syntax keyword javascriptAServices containedin=ALLBUT,javascriptComment,javascriptLineComment,javascriptString $locale $parse $rootElement
    3              0.000045 syntax keyword javascriptAServices containedin=ALLBUT,javascriptComment,javascriptLineComment,javascriptString $routeParams $templateCache $window 
    3              0.000042 syntax keyword javascriptAServices containedin=ALLBUT,javascriptComment,javascriptLineComment,javascriptString $cookies $resource $sanitize
                            
    3              0.000054 syntax keyword javascriptAServices containedin=ALLBUT,javascriptComment,javascriptLineComment,javascriptString $http nextgroup=javascriptAShttpdot
    3              0.000033 syntax match   javascriptAShttpdot contained /\./ nextgroup=javascriptAShttpMethods
    3              0.000023 syntax keyword javascriptAShttpMethods contained get head post put delete jsonp defaults prendingRequests 
                            
    3              0.000057 syntax keyword javascriptAServices containedin=ALLBUT,javascriptComment,javascriptLineComment,javascriptString $interpolate nextgroup=javascriptASinterpolatedot
    3              0.000032 syntax match   javascriptASinterpolatedot contained /\./ nextgroup=javascriptASinterpolateMethods
    3              0.000014 syntax keyword javascriptASinterpolateMethods contained endSymbol startSymbol
                            
    3              0.000046 syntax keyword javascriptAServices containedin=ALLBUT,javascriptComment,javascriptLineComment,javascriptString $location nextgroup=javascriptASlocationdot
    3              0.000027 syntax match   javascriptASlocationdot contained /\./ nextgroup=javascriptASlocationMethods
    3              0.000028 syntax keyword javascriptASlocationMethods contained absUrl hash host path port protocol replace search url
                            
    3              0.000047 syntax keyword javascriptAServices containedin=ALLBUT,javascriptComment,javascriptLineComment,javascriptString $log nextgroup=javascriptASlogdot
    3              0.000169 syntax match   javascriptASlogdot contained /\./ nextgroup=javascriptASlogMethods
    3              0.000013 syntax keyword javascriptASlogMethods contained error info log warn
                            
    3              0.000052 syntax keyword javascriptAServices containedin=ALLBUT,javascriptComment,javascriptLineComment,javascriptString $q nextgroup=javascriptASqdot
    3              0.000027 syntax match   javascriptASqdot contained /\./ nextgroup=javascriptASqMethods
    3              0.000012 syntax keyword javascriptASqMethods contained all defer reject when
                            
    3              0.000046 syntax keyword javascriptAServices containedin=ALLBUT,javascriptComment,javascriptLineComment,javascriptString $route nextgroup=javascriptASroutedot
    3              0.000030 syntax match   javascriptASroutedot contained /\./ nextgroup=javascriptASrouteMethods
    3              0.000011 syntax keyword javascriptASrouteMethods contained reload current route
                            
    3              0.000045 syntax keyword javascriptAServices containedin=ALLBUT,javascriptComment,javascriptLineComment,javascriptString $timeout nextgroup=javascriptAStimeoutdot
    3              0.000028 syntax match   javascriptAStimeoutdot contained /\./ nextgroup=javascriptAStimeoutMethods
    3              0.000011 syntax keyword javascriptAStimeoutMethods contained cancel
                            
    3              0.000063 syntax keyword javascriptAServices containedin=ALLBUT,javascriptComment,javascriptLineComment,javascriptString $scope $rootScope nextgroup=javascriptASscopedot
    3              0.000025 syntax match   javascriptASscopedot contained /\./ nextgroup=javascriptASscopeMethods
    3              0.000017 syntax keyword javascriptASscopeMethods contained $apply $broadcast $destroy $digest $emit $eval $evalAsync $new $on $watch $id
                            
    3              0.000046 syntax keyword javascriptAServices containedin=ALLBUT,javascriptComment,javascriptLineComment,javascriptString $cookieStore nextgroup=javascriptAScookieStoredot
    3              0.000035 syntax match   javascriptAScookieStoredot contained /\./ nextgroup=javascriptAScookieStoreMethods
    3              0.000012 syntax keyword javascriptAScookieStoreMethods contained get put remove
                            
    3              0.000024 syntax cluster javascriptAFunctions contains=javascriptAMFunctions
    3              0.000020 syntax cluster javascriptAAttrs contains=javascriptAMAttrs
                            
    3              0.000024 syntax keyword javascriptAMFunctions contained config constant controller directive factory
    3              0.000015 syntax keyword javascriptAMFunctions contained filter provider run service value
    3              0.000009 syntax keyword javascriptAMAttrs contained name requires
                            
                            
                            " Define the default highlighting.
                            " For version 5.7 and earlier: only when not done already
                            " For version 5.8 and later: only when an item doesn't have highlighting yet
    3              0.000015 if version >= 508 || !exists("did_angularjs_javascript_syntax_inits")
    3              0.000006   if version < 508
                                let did_angularjs_javascript_syntax_inits = 1
                                command -nargs=+ HiLink hi link <args>
                              else
    3              0.000024     command -nargs=+ HiLink hi def link <args>
    3              0.000003   endif
                            
    3              0.000041   HiLink javascriptAngular         Constant
    3              0.000032   HiLink javascriptAServices       Constant
                            
    3              0.000029   HiLink javascriptAngularMethods  PreProc
    3              0.000029   HiLink javascriptAMFunctions     PreProc
    3              0.000028   HiLink javascriptAMAttrs         PreProc
                            
    3              0.000030   HiLink javascriptAShttpMethods        PreProc
    3              0.000029   HiLink javascriptASinterpolateMethods PreProc
    3              0.000030   HiLink javascriptASlocationMethods    PreProc
    3              0.000028   HiLink javascriptASlogMethods         PreProc
    3              0.000030   HiLink javascriptASqMethods           PreProc
    3              0.000028   HiLink javascriptASrouteMethods       PreProc
    3              0.000028   HiLink javascriptAStimeoutMethods     PreProc
    3              0.000030   HiLink javascriptASscopeMethods       PreProc
    3              0.000029   HiLink javascriptAScookieStoreMethods PreProc
                            
    3              0.000008   delcommand HiLink
    3              0.000012 endif

SCRIPT  /Users/admin/.vim/bundle/javascript-libraries-syntax.vim/autoload/syntax/requirejs.javascript.vim
Sourced 3 times
Total time:   0.000467
 Self time:   0.000467

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:    require.js for javascript
                            " Maintainer:  othree <othree@gmail.com>
                            " Last Change: 2013/07/26
                            " Version:     2.1.4.1
                            " URL:         http://requirejs.org/
                            
                            
    3              0.000066 syntax keyword javascriptRequire require requirejs containedin=ALLBUT,javascriptComment,javascriptLineComment,javascriptString nextgroup=javascriptRequiredot
    3              0.000031 syntax match   javascriptRequiredot contained /\./ nextgroup=javascriptRequireMethods
    3              0.000011 syntax keyword javascriptRequireMethods contained config
                            
    3              0.000062 syntax keyword javascriptRdefine define containedin=ALLBUT,javascriptComment,javascriptLineComment,javascriptString nextgroup=javascriptRdefinedot
    3              0.000028 syntax match   javascriptRdefinedot contained /\./ nextgroup=javascriptRdefineMethods
    3              0.000011 syntax keyword javascriptRdefineMethods contained amd
                            
                            
                            " Define the default highlighting.
                            " For version 5.7 and earlier: only when not done already
                            " For version 5.8 and later: only when an item doesn't have highlighting yet
    3              0.000023 if version >= 508 || !exists("did_requirejs_javascript_syntax_inits")
    3              0.000008   if version < 508
                                let did_requirejs_javascript_syntax_inits = 1
                                command -nargs=+ HiLink hi link <args>
                              else
    3              0.000024     command -nargs=+ HiLink hi def link <args>
    3              0.000003   endif
                            
    3              0.000035   HiLink javascriptRequire         PreProc
    3              0.000029   HiLink javascriptRequireMethods  PreProc
    3              0.000027   HiLink javascriptRdefine         PreProc
    3              0.000027   HiLink javascriptRdefineMethods  PreProc
                            
                            
    3              0.000007   delcommand HiLink
    3              0.000011 endif

SCRIPT  /Users/admin/.vim/bundle/javascript-libraries-syntax.vim/autoload/syntax/sugar.javascript.vim
Sourced 3 times
Total time:   0.006813
 Self time:   0.006813

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:    prelude.ls for javascript
                            " Maintainer:  othree <othree@gmail.com>
                            " Last Change: 2013/07/26
                            " Version:     1.3.9
                            " URL:         http://sugarjs.com/
                            "              http://sugarjs.com/api
                            
    3              0.000034 syntax cluster javascriptSFunctions contains=javascriptSFunction
                            
                            " String
    3              0.000267 syntax keyword javascriptSFunction contained add assign at camelize capitalize chars codes compact dasherize decodeBase64
    3              0.000328 syntax keyword javascriptSFunction contained each encodeBase64 endsWith escapeHTML escapeRegExp escapeURL first from hankaku has
    3              0.000416 syntax keyword javascriptSFunction contained hasArabic hasCyrillic hasGreek hasHangul hasHan hasKanji hasHebrew hasHiragana hasKana hasKatakana
    3              0.000404 syntax keyword javascriptSFunction contained hasLatin hasThai hasDevanagari hiragana humanize insert isBlank isArabic isCyrillic isGreek
    3              0.000396 syntax keyword javascriptSFunction contained isHangul isHan isKanji isHebrew isHiragana isKana isKatakana isKatakana isThai isDevanagari
    3              0.000325 syntax keyword javascriptSFunction contained katakana last lines normalize pad padLeft padRight paragraphs parameterize plualize
    3              0.000276 syntax keyword javascriptSFunction contained remove removeTags repeat reverse shift singularize spacify startsWith stripTags titleize
    3              0.000279 syntax keyword javascriptSFunction contained to toNumber trim trimLeft trimRight truncate underscore unescapeHTML unescapeURL words
    3              0.000047 syntax keyword javascriptSFunction contained zenkaku
                            
                            " Number
    3              0.000451 syntax keyword javascriptSFunction contained abbr bytes ceil chr downto duration floor format hex isEven
    3              0.000142 syntax keyword javascriptSFunction contained isInteger isMultipleOf isOdd log abs sin asin cos acos tan
    3              0.000118 syntax keyword javascriptSFunction contained atan sqrt exp pow metric ordinalize pad round times toNumber
    3              0.000424 syntax keyword javascriptSFunction contained millisecond milliseconds second seconds minute minutes hour hours day days
    3              0.000287 syntax keyword javascriptSFunction contained week weeks month months year years upto
                            
                            " Array
                            
    3              0.000112 syntax keyword javascriptSFunction contained create add all any at average clone compact count each
    3              0.000203 syntax keyword javascriptSFunction contained every exclude filter find findAll findFrom findIndex findIndexFrom first flatten
    3              0.000233 syntax keyword javascriptSFunction contained forEach from groupBy inGroups inGroupsOf include indexOf insert intersect isEmpty
    3              0.000176 syntax keyword javascriptSFunction contained last lastIndexOf least map max min most none randomize reduce
    3              0.000139 syntax keyword javascriptSFunction contained reduceRight remove removeAt sample some sortBy subtract sum to union
    3              0.000009 syntax keyword javascriptSFunction contained unique zip
                            
                            " Object
                            
    3              0.000096 syntax keyword javascriptSFunction contained extended fromQueryString isArray isObject isBoolean isDate isFunction isNaN isNumber isString
    3              0.000062 syntax keyword javascriptSFunction contained isRegExp toQueryString clone each map any all none count find
    3              0.000059 syntax keyword javascriptSFunction contained findAll reduce isEmpty sum average min max least most equal
    3              0.000056 syntax keyword javascriptSFunction contained has keys merge reject select size tap values watch 
                            
                            " Function
                            
    3              0.000100 syntax keyword javascriptSFunction contained after bind cancel debounce delay everyfill lazyredrawonce throttle 
                            
                            " RegExp
                            
    3              0.000183 syntax keyword javascriptSFunction contained escape addFlag getFlags removeFlag setFlags
                            
                            " Date
    3              0.000325 syntax keyword javascriptSFunction contained addLocale create future getLocale now past range setLocale addMilliseconds addSeconds
    3              0.000359 syntax keyword javascriptSFunction contained addMinutes addHours addDays addWeeks addMonths addYears advance beginningOfDay beginningOfWeek beginningOfMonth
    3              0.000021 syntax keyword javascriptSFunction contained beginningOfYear clone daysInMonth endOfDay endOfWeek endOfMonth endOfYear format getISOWeek getUTCOffset
    3              0.000017 syntax keyword javascriptSFunction contained getWeekday is isAfter isBefore isBetween isToday isYesterday isTomorrow isWeekday isWeekend
    3              0.000034 syntax keyword javascriptSFunction contained isSunday isMonday isTuesday isWednesday isThursday isFriday isSaturday isFuture isLastWeek isLastMonth
    3              0.000015 syntax keyword javascriptSFunction contained isLastYear isPast isThisWeek isThisMonth isThisYear isUTC isValid iso relative reset
    3              0.000022 syntax keyword javascriptSFunction contained rewind set setISOWeek setWeekday toISOString toJSON millisecondsSince secondsSince minutesSince hoursSince
    3              0.000016 syntax keyword javascriptSFunction contained daysSince weeksSince monthsSince yearsSince millisecondsUntil secondsUntil minutesUntil hoursUntil daysUntil weeksUntil
    3              0.000016 syntax keyword javascriptSFunction contained monthsUntil yearsUntil millisecondAfter millisecondsAfter secondAfter secondsAfter minuteAfter minutesAfter hourAfter hoursAfter
    3              0.000015 syntax keyword javascriptSFunction contained dayAfter daysAfter weekAfter weeksAfter monthAfter monthsAfter yearAfter yearsAfter millisecondAgo millisecondsAgo
    3              0.000016 syntax keyword javascriptSFunction contained secondAgo secondsAgo minuteAgo minutesAgo hourAgo hoursAgo dayAgo daysAgo weekAgo weeksAgo
    3              0.000016 syntax keyword javascriptSFunction contained monthAgo monthsAgo yearAgo yearsAgo millisecondBefore millisecondsBefore secondBefore secondsBefore minuteBefore minutesBefore
    3              0.000019 syntax keyword javascriptSFunction contained hourBefore hoursBefore dayBefore daysBefore weekBefore weeksBefore monthBefore monthsBefore yearBefore yearsBefore
    3              0.000017 syntax keyword javascriptSFunction contained millisecondFromNow millisecondsFromNow secondFromNow secondsFromNow minuteFromNow minutesFromNow hourFromNow hoursFromNow dayFromNow daysFromNow
    3              0.000013 syntax keyword javascriptSFunction contained weekFromNow weeksFromNow monthFromNow monthsFromNow yearFromNow yearsFromNow utc
                            
                            " Range
                            
    3              0.000016 syntax keyword javascriptSFunction contained clamp clone every intersect isValid span toString union
    3              0.000008 syntax keyword javascriptSFunction contained contain[s]
                            
                            " Define the default highlighting.
                            " For version 5.7 and earlier: only when not done already
                            " For version 5.8 and later: only when an item doesn't have highlighting yet
    3              0.000016 if version >= 508 || !exists("did_prelude_javascript_syntax_inits")
    3              0.000007   if version < 508
                                let did_prelude_javascript_syntax_inits = 1
                                command -nargs=+ HiLink hi link <args>
                              else
    3              0.000025     command -nargs=+ HiLink hi def link <args>
    3              0.000005   endif
                            
    3              0.000052   HiLink javascriptSFunction        PreProc
                            
                            
    3              0.000011   delcommand HiLink
    3              0.000013 endif

SCRIPT  /Users/admin/.vim/bundle/javascript-libraries-syntax.vim/autoload/syntax/postprocess.javascript.vim
Sourced 3 times
Total time:   0.000172
 Self time:   0.000172

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:    JS Lib syntax post process for javascript
                            " Maintainer:  othree <othree@gmail.com>
                            " Last Change: 2013/07/26
                            " Version:     0.4
                            " URL:         https://github.com/othree/javascript-libraries-syntax.vim
                            "
                            
    3              0.000036 syntax cluster javascriptLibraryFuncs contains=@javascriptQFunctions,@javascript_Functions,@javascriptBFunctions,@javascriptpFunctions,@javascriptAFunctions,@javascriptSFunctions
    3              0.000032 syntax cluster javascriptLibraryAttrs contains=@javascriptQAttrs,@javascript_Attrs,@javascriptBAttrs,@javascriptpAttrs,@javascriptAAttrs
    3              0.000078 syntax match   javascriptLDot /\./ containedin=ALLBUT,javascriptComment,javascriptLineComment,javascriptLineComment,javascriptString nextgroup=@javascriptLibraryFuncs,@javascriptLibraryAttrs

FUNCTION  sy#repo#process_diff()
Called 2 times
Total time:   1.873726
 Self time:   0.006278

count  total (s)   self (s)
    2              0.000005   let added    = 0
    2              0.000004   let deleted  = 0
    2              0.000003   let modified = 0
                            
                              " Determine where we have to put our signs.
   30              0.002067   for line in filter(split(a:diff, '\n'), 'v:val =~ "^@@ "')
   28              0.000602     let tokens = matchlist(line, '^@@ -\v(\d+),?(\d*) \+(\d+),?(\d*)')
                            
   28              0.000125     let old_line = str2nr(tokens[1])
   28              0.000082     let new_line = str2nr(tokens[3])
                            
   28              0.000128     let old_count = empty(tokens[2]) ? 1 : str2nr(tokens[2])
   28              0.000113     let new_count = empty(tokens[4]) ? 1 : str2nr(tokens[4])
                            
   28              0.000104     let signs = []
                            
                                " 2 lines added:
                            
                                " @@ -5,0 +6,2 @@ this is line 5
                                " +this is line 5
                                " +this is line 5
                            
   28              0.000058     if (old_count == 0) && (new_count >= 1)
   12              0.000018       let added += new_count
   12              0.000015       let offset = 0
                            
   35              0.000044       while offset < new_count
   23              0.000125         call add(signs, { 'type': 'SignifyAdd', 'lnum': new_line + offset, 'path': a:path })
   23              0.000036         let offset += 1
   23              0.000019       endwhile
                            
                                " 2 lines removed:
                            
                                " @@ -6,2 +5,0 @@ this is line 5
                                " -this is line 6
                                " -this is line 7
                            
   12              0.000020     elseif (old_count >= 1) && (new_count == 0)
    8              0.000014       let deleted += old_count
                            
    8              0.000017       if new_line == 0
                                    call add(signs, { 'type': 'SignifyDeleteFirstLine', 'lnum': 1, 'path': a:path })
                                  else
    8              0.000062         call add(signs, { 'type': (old_count > 9) ? 'SignifyDeleteMore' : 'SignifyDelete'. old_count, 'lnum': new_line, 'path': a:path })
    8              0.000006       endif
                            
                                " 2 lines changed:
                            
                                " @@ -5,2 +5,2 @@ this is line 4
                                " -this is line 5
                                " -this is line 6
                                " +this os line 5
                                " +this os line 6
                            
    8              0.000008     elseif old_count == new_count
    4              0.000008       let modified += old_count
    4              0.000004       let offset    = 0
                            
   10              0.000012       while offset < new_count
    6              0.000030         call add(signs, { 'type': 'SignifyChange', 'lnum': new_line + offset, 'path': a:path })
    6              0.000010         let offset += 1
    6              0.000005       endwhile
    4              0.000002     else
                            
                                  " 2 lines changed; 2 lines deleted:
                            
                                  " @@ -5,4 +5,2 @@ this is line 4
                                  " -this is line 5
                                  " -this is line 6
                                  " -this is line 7
                                  " -this is line 8
                                  " +this os line 5
                                  " +this os line 6
                            
    4              0.000005       if old_count > new_count
    1              0.000002         let modified += new_count
    1              0.000002         let removed   = (old_count - new_count)
    1              0.000002         let deleted  += removed
    1              0.000001         let offset    = 0
                            
    5              0.000010         while offset < (new_count - 1)
    4              0.000020           call add(signs, { 'type': 'SignifyChange', 'lnum': new_line + offset, 'path': a:path })
    4              0.000004           let offset += 1
    4              0.000002         endwhile
                            
    1              0.000010         call add(signs, { 'type': (removed > 9) ? 'SignifyChangeDeleteMore' : 'SignifyChangeDelete'. removed, 'lnum': new_line, 'path': a:path })
                            
                                  " lines changed and added:
                            
                                  " @@ -5 +5,3 @@ this is line 4
                                  " -this is line 5
                                  " +this os line 5
                                  " +this is line 42
                                  " +this is line 666
                            
    1              0.000000       else
    3              0.000005         let modified += old_count
    3              0.000007         let added    += (new_count - old_count)
    3              0.000004         let offset    = 0
                            
   11              0.000015         while offset < old_count
    8              0.000042           call add(signs, { 'type': 'SignifyChange', 'lnum': new_line + offset, 'path': a:path })
    8              0.000012           let offset += 1
    8              0.000014         endwhile
                            
   31              0.000043         while offset < new_count
   28              0.000133           call add(signs, { 'type': 'SignifyAdd', 'lnum': new_line + offset, 'path': a:path })
   28              0.000045           let offset += 1
   28              0.000014         endwhile
    3              0.000003       endif
    4              0.000002     endif
                            
   28   1.867608   0.000160     call sy#sign#set(signs)
   28              0.000024   endfor
                            
    2              0.000012   let g:sy[g:sy_path].stats = [added, modified, deleted]

FUNCTION  <SNR>46_repo_head_ref()
Called 20 times
Total time:   0.001519
 Self time:   0.001342

count  total (s)   self (s)
   20   0.001497   0.001320   return readfile(self.dir('HEAD'))[0]

FUNCTION  <SNR>82_BufEnterHook()
Called 11 times
Total time:   0.000815
 Self time:   0.000480

count  total (s)   self (s)
   11   0.000348   0.000203     call syntastic#log#debug(g:SyntasticDebugAutocommands, 'autocmd: BufEnter, buffer ' . bufnr("") . ' = ' . string(bufname(str2nr(bufnr("")))) . ', &buftype = ' . string(&buftype))
                                " TODO: at this point there is no b:syntastic_loclist
   11              0.000062     let loclist = filter(getloclist(0), 'v:val["valid"] == 1')
   11   0.000284   0.000094     let buffers = syntastic#util#unique(map( loclist, 'v:val["bufnr"]' ))
   11              0.000053     if &buftype == 'quickfix' && !empty(loclist) && empty(filter( buffers, 'syntastic#util#bufIsActive(v:val)' ))
                                    call g:SyntasticLoclistHide()
                                endif

FUNCTION  <SNR>46_buffer_getline()
Called 72 times
Total time:   0.000392
 Self time:   0.000392

count  total (s)   self (s)
   72              0.000351   return getbufline(self['#'],a:lnum)[0]

FUNCTION  airline#extensions#undotree#apply()
Called 45 times
Total time:   0.000900
 Self time:   0.000900

count  total (s)   self (s)
   45              0.000143   if exists('t:undotree')
                                if &ft == 'undotree'
                                  if exists('*t:undotree.GetStatusLine')
                                    call airline#extensions#apply_left_override('undo', '%{t:undotree.GetStatusLine()}')
                                  else
                                    call airline#extensions#apply_left_override('undotree', '%f')
                                  endif
                                endif
                            
                                if &ft == 'diff' && exists('*t:diffpanel.GetStatusLine')
                                  call airline#extensions#apply_left_override('diff', '%{t:diffpanel.GetStatusLine()}')
                                endif
                              endif

FUNCTION  syntastic#log#debug()
Called 81 times
Total time:   0.000785
 Self time:   0.000506

count  total (s)   self (s)
   81   0.000647   0.000368     if !s:isDebugEnabled(a:level)
   81              0.000066         return
                                endif
                            
                                let leader = s:logTimestamp()
                                call s:logRedirect(1)
                            
                                if a:0 > 0
                                    " filter out dictionary functions
                                    echomsg leader . a:msg . ' ' . strtrans(string(type(a:1) == type({}) || type(a:1) == type([]) ? filter(copy(a:1), 'type(v:val) != type(function("tr"))') : a:1))
                                else
                                    echomsg leader . a:msg
                                endif
                            
                                call s:logRedirect(0)

FUNCTION  airline#util#exec_funcrefs()
Called 45 times
Total time:   0.109242
 Self time:   0.002956

count  total (s)   self (s)
  225              0.000395     for Fn in a:list
  225   0.107837   0.001551       let code = call(Fn, a:000)
  225              0.000341       if code != 0
   45              0.000049         return code
                                  endif
  180              0.000121     endfor
                                return 0

FUNCTION  neobundle#config#fuzzy_search()
Called 1 time
Total time:   0.002739
 Self time:   0.000784

count  total (s)   self (s)
    1              0.000002   let bundles = []
    7              0.000014   for name in a:bundle_names
    6   0.000725   0.000666     let bundles += filter(neobundle#config#get_neobundles(), 'stridx(v:val.name, name) >= 0')
    6              0.000005   endfor
                            
    1              0.000001   let _ = []
    7              0.000006   for bundle in bundles
    6   0.001600   0.000051     let _ += neobundle#config#search( map(copy(bundle.depends), 'v:val.name'))
    6              0.000014     call add(_, bundle)
    6              0.000004   endfor
                            
    1   0.000351   0.000004   return neobundle#util#uniq(_)

FUNCTION  <SNR>108_get_visible_buffers()
Called 20 times
Total time:   0.009311
 Self time:   0.002310

count  total (s)   self (s)
   20   0.003311   0.000177   let buffers = s:get_buffer_list()
   20              0.000060   let cur = bufnr('%')
                            
   20              0.000039   let total_width = 0
   20              0.000034   let max_width = 0
                            
   53              0.000082   for nr in buffers
   33   0.004173   0.000306     let width = len(airline#extensions#tabline#get_buffer_name(nr)) + 4
   33              0.000095     let total_width += width
   33              0.000139     let max_width = max([max_width, width])
   33              0.000036   endfor
                            
                              " only show current and surrounding buffers if there are too many buffers
   20              0.000085   let position  = index(buffers, cur)
   20              0.000054   let vimwidth = &columns
   20              0.000051   if total_width > vimwidth && position > -1
                                let buf_count = len(buffers)
                            
                                " determine how many buffers to show based on the longest buffer width,
                                " use one on the right side and put the rest on the left
                                let buf_max   = vimwidth / max_width
                                let buf_right = 1
                                let buf_left  = max([0, buf_max - buf_right])
                            
                                let start = max([0, position - buf_left])
                                let end   = min([buf_count, position + buf_right])
                            
                                " fill up available space on the right
                                if position < buf_left
                                  let end += (buf_left - position)
                                endif
                            
                                " fill up available space on the left
                                if end > buf_count - 1 - buf_right
                                  let start -= max([0, buf_right - (buf_count - 1 - position)])
                                endif
                            
                                let buffers = eval('buffers[' . start . ':' . end . ']')
                            
                                if start > 0
                                  call insert(buffers, -1, 0)
                                endif
                            
                                if end < buf_count - 1
                                  call add(buffers, -1)
                                endif
                              endif
                            
   20              0.000027   return buffers

FUNCTION  <SNR>57_ExpandMap()
Called 10 times
Total time:   0.000308
 Self time:   0.000308

count  total (s)   self (s)
   10              0.000022   let map = a:map
   10              0.000252   let map = substitute(map, '\(<Plug>\w\+\)', '\=maparg(submatch(1), "i")', 'g')
   10              0.000018   return map

FUNCTION  <SNR>139_NetrwBrowseChgDir()
Called 12 times
Total time:  18.836833
 Self time:   8.063079

count  total (s)   self (s)
                            "  call Dfunc("s:NetrwBrowseChgDir(islocal=".a:islocal."> newdir<".a:newdir.">) a:0=".a:0." curpos<".string(getpos("."))."> b:netrw_curdir<".(exists("b:netrw_curdir")? b:netrw_curdir : "").">")
                            
   12              0.000043   let ykeep= @@
   12              0.000047   if !exists("b:netrw_curdir")
                               " Don't try to change-directory: this can happen, for example, when netrw#ErrorMsg has been called
                               " and the current window is the NetrwMessage window.
                               let @@= ykeep
                            "   call Decho("(NetrwBrowseChgDir) b:netrw_curdir doesn't exist!")
                            "   call Decho("(NetrwBrowseChgDir) getcwd<".getcwd().">")
                            "   call Dret("s:NetrwBrowseChgDir")
                               return
                              endif
                            
                              " NetrwBrowseChgDir: save options and initialize {{{3
   12   0.004177   0.000096   keepj call s:NetrwOptionSave("s:")
   12   0.102924   0.000096   keepj call s:NetrwSafeOptions()
   12   0.001959   0.000079   let nbcd_curpos                = netrw#NetrwSavePosn()
   12              0.000089   let s:nbcd_curpos_{bufnr('%')} = nbcd_curpos
                            "  call Decho("(NetrwBrowseChgDir) setting s:nbcd_curpos_".bufnr('%')." to SavePosn")
   12              0.000154   if (has("win32") || has("win95") || has("win64") || has("win16"))
                               let dirname                   = substitute(b:netrw_curdir,'\\','/','ge')
                              else
   12              0.000029    let dirname= b:netrw_curdir
   12              0.000009   endif
   12              0.000027   let newdir    = a:newdir
   12              0.000020   let dolockout = 0
                            
                              " set up o/s-dependent directory recognition pattern
   12              0.000049   if has("amiga")
                               let dirpat= '[\/:]$'
                              else
   12              0.000016    let dirpat= '[\/]$'
   12              0.000011   endif
                            "  call Decho("(NetrwBrowseChgDir) dirname<".dirname.">  dirpat<".dirpat.">")
                            
   12              0.000128   if dirname !~ dirpat
                               " apparently vim is "recognizing" that it is in a directory and
                               " is removing the trailing "/".  Bad idea, so let's put it back.
   12              0.000038    let dirname= dirname.'/'
                            "   call Decho("(NetrwBrowseChgDir) adjusting dirname<".dirname.">")
   12              0.000010   endif
                            
   12              0.000068   if newdir !~ dirpat
                               " ------------------------------
                               " NetrwBrowseChgDir: edit a file {{{3
                               " ------------------------------
                            "   call Decho('(NetrwBrowseChgDir:edit-a-file) case "handling a file": newdir<'.newdir.'> !~ dirpat<'.dirpat.">")
                            
                               " save position for benefit of Rexplore
    2   0.000274   0.000018    let s:rexposn_{bufnr("%")}= netrw#NetrwSavePosn()
                            
                            "   call Decho("(NetrwBrowseChgDir:edit-a-file) setting s:rexposn_".bufnr("%")." to SavePosn")
    2              0.000012    if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST && exists("w:netrw_treedict") && newdir !~ '^\(/\|\a:\)'
                                let dirname= s:NetrwTreeDir()
                                if dirname =~ '/$'
                                 let dirname= dirname.newdir
                                else
                                 let dirname= s:NetrwTreeDir()."/".newdir
                                endif
                            "    call Decho("(NetrwBrowseChgDir:edit-a-file) dirname<".dirname.">")
                            "    call Decho("(NetrwBrowseChgDir:edit-a-file) tree listing")
                               elseif newdir =~ '^\(/\|\a:\)'
                                let dirname= newdir
                               else
    2   0.000183   0.000014     let dirname= s:ComposePath(dirname,newdir)
    2              0.000002    endif
                            "   call Decho("(NetrwBrowseChgDir:edit-a-file) handling a file: dirname<".dirname."> (a:0=".a:0.")")
                               " this lets NetrwBrowseX avoid the edit
    2              0.000002    if a:0 < 1
                            "    call Decho("(NetrwBrowseChgDir:edit-a-file) set up windows for editing<".fnameescape(dirname).">  didsplit=".(exists("s:didsplit")? s:didsplit : "doesn't exist"))
    2   0.001833   0.000013     keepj call s:NetrwOptionRestore("s:")
    2              0.000006     if !exists("s:didsplit")
                            "     call Decho("(NetrwBrowseChgDir:edit-a-file) s:didsplit does not exist; g:netrw_browse_split=".g:netrw_browse_split." win#".winnr())
    2              0.000004      if     g:netrw_browse_split == 1
                                  " horizontally splitting the window first
                                  keepalt new
                                  if !&ea
                                   keepalt wincmd _
                                  endif
                                 elseif g:netrw_browse_split == 2
                                  " vertically splitting the window first
                                  keepalt rightb vert new
                                  if !&ea
                                   keepalt wincmd |
                                  endif
                                 elseif g:netrw_browse_split == 3
                                  " open file in new tab
                                  keepalt tabnew
                                 elseif g:netrw_browse_split == 4
                                  " act like "P" (ie. open previous window)
                                  if s:NetrwPrevWinOpen(2) == 3
                                   let @@= ykeep
                            "       call Dret("s:NetrwBrowseChgDir")
                                   return
                                  endif
                                 else
                                  " handling a file, didn't split, so remove menu
                            "      call Decho("(NetrwBrowseChgDir:edit-a-file) handling a file+didn't split, so remove menu")
    2   0.003472   0.000012       call s:NetrwMenu(0)
                                  " optional change to window
    2              0.000004       if g:netrw_chgwin >= 1
                                   exe "keepj keepalt ".g:netrw_chgwin."wincmd w"
                                  endif
    2              0.000001      endif
    2              0.000001     endif
                            
                                " the point where netrw actually edits the (local) file
                                " if its local only: LocalBrowseCheck() doesn't edit a file, but NetrwBrowse() will
    2              0.000003     if a:islocal
                            "     call Decho("(NetrwBrowseChgDir:edit-a-file) edit local file: exe e! ".fnameescape(dirname))
    2  18.706925   8.058352      exe "keepj keepalt e! ".fnameescape(dirname)
    2   0.000169   0.000033      call s:NetrwCursor()
    2              0.000000     else
                            "     call Decho("(NetrwBrowseChgDir:edit-a-file) remote file: NetrwBrowse will edit it")
                                endif
    2              0.000006     let dolockout= 1
                            
                                " handle g:Netrw_funcref -- call external-to-netrw functions
                                "   This code will handle g:Netrw_funcref as an individual function reference
                                "   or as a list of function references.  It will ignore anything that's not
                                "   a function reference.  See  :help Funcref  for information about function references.
    2              0.000007     if exists("g:Netrw_funcref")
                            "     call Decho("(NetrwBrowseChgDir:edit-a-file) handle optional Funcrefs")
                                 if type(g:Netrw_funcref) == 2
                            "      call Decho("(NetrwBrowseChgDir:edit-a-file) handling a g:Netrw_funcref")
                                  keepj call g:Netrw_funcref()
                                 elseif type(g:Netrw_funcref) == 3
                            "      call Decho("(NetrwBrowseChgDir:edit-a-file) handling a list of g:Netrw_funcrefs")
                                  for Fncref in g:Netrw_funcref
                                   if type(FncRef) == 2
                                    keepj call FncRef()
                                   endif
                                  endfor
                                 endif
                                endif
    2              0.000002    endif
                            
    2              0.000002   elseif newdir =~ '^/'
                               " ----------------------------------------------------
                               " NetrwBrowseChgDir: just go to the new directory spec {{{3
                               " ----------------------------------------------------
                            "   call Decho('(NetrwBrowseChgDir:goto-newdir) case "just go to new directory spec": newdir<'.newdir.'>')
                               let dirname    = newdir
                               keepj call s:SetRexDir(a:islocal,dirname)
                               keepj call s:NetrwOptionRestore("s:")
                            
                              elseif newdir == './'
                               " ---------------------------------------------
                               " NetrwBrowseChgDir: refresh the directory list {{{3
                               " ---------------------------------------------
                            "   call Decho('(NetrwBrowseChgDir:refresh-dirlist) case "refresh directory listing": newdir == "./"')
                               keepj call s:SetRexDir(a:islocal,dirname)
                            
                              elseif newdir == '../'
                               " --------------------------------------
                               " NetrwBrowseChgDir: go up one directory {{{3
                               " --------------------------------------
                            "   call Decho('(NetrwBrowseChgDir:go-up) case "go up one directory": newdir == "../"')
                            
    2              0.000025    if w:netrw_liststyle == s:TREELIST && exists("w:netrw_treedict")
                                " force a refresh
                            "    call Decho("(NetrwBrowseChgDir:go-up) clear buffer<".expand("%")."> with :%d")
                            "    call Decho("(NetrwBrowseChgDir:go-up) setl noro ma")
                                setl noro ma
                                keepj %d
                               endif
                            
    2              0.000011    if has("amiga")
                                " amiga
                            "    call Decho('(NetrwBrowseChgDir:go-up) case "go up one directory": newdir == "../" and amiga')
                                if a:islocal
                                 let dirname= substitute(dirname,'^\(.*[/:]\)\([^/]\+$\)','\1','')
                                 let dirname= substitute(dirname,'/$','','')
                                else
                                 let dirname= substitute(dirname,'^\(.*[/:]\)\([^/]\+/$\)','\1','')
                                endif
                            "    call Decho("(NetrwBrowseChgDir:go-up) amiga: dirname<".dirname."> (go up one dir)")
                            
                               else
                                " unix or cygwin
                            "    call Decho('(NetrwBrowseChgDir:go-up) case "go up one directory": newdir == "../" and unix or cygwin')
    2              0.000002     if a:islocal
    2              0.000036      let dirname= substitute(dirname,'^\(.*\)/\([^/]\+\)/$','\1','')
    2              0.000005      if dirname == ""
                                  let dirname= '/'
                                 endif
    2              0.000000     else
                                 let dirname= substitute(dirname,'^\(\a\+://.\{-}/\{1,2}\)\(.\{-}\)\([^/]\+\)/$','\1\2','')
                                endif
                            "    call Decho("(NetrwBrowseChgDir:go-up) unix: dirname<".dirname."> (go up one dir)")
    2              0.000000    endif
    2   0.000028   0.000014    keepj call s:SetRexDir(a:islocal,dirname)
                            
    2              0.000005   elseif exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST && exists("w:netrw_treedict")
                               " --------------------------------------
                               " NetrwBrowseChgDir: Handle Tree Listing {{{3
                               " --------------------------------------
                            "   call Decho('(NetrwBrowseChgDir:tree-list) case liststyle is TREELIST and w:netrw_treedict exists')
                               " force a refresh (for TREELIST, wait for NetrwTreeDir() to force the refresh)
                            "   call Decho("(NetrwBrowseChgDir) (treelist) setl noro ma")
                               setl noro ma
                               if !(exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST && exists("b:netrw_curdir"))
                            "    call Decho("(NetrwBrowseChgDir) clear buffer<".expand("%")."> with :%d")
                                keepj %d
                               endif
                               let treedir      = s:NetrwTreeDir()
                               let s:treecurpos = nbcd_curpos
                               let haskey= 0
                            "   call Decho("(NetrwBrowseChgDir:tree-list) w:netrw_treedict<".string(w:netrw_treedict).">")
                            
                               " search treedict for tree dir as-is
                               if has_key(w:netrw_treedict,treedir)
                            "    call Decho('(NetrwBrowseChgDir:tree-list) ....searched for treedir<'.treedir.'> : found it!')
                                let haskey= 1
                               else
                            "    call Decho('(NetrwBrowseChgDir:tree-list) ....searched for treedir<'.treedir.'> : not found')
                               endif
                            
                               " search treedict for treedir with a / appended
                               if !haskey && treedir !~ '/$'
                                if has_key(w:netrw_treedict,treedir."/")
                                 let treedir= treedir."/"
                            "     call Decho('(NetrwBrowseChgDir:tree-list) ....searched.for treedir<'.treedir.'> found it!')
                                 let haskey = 1
                                else
                            "     call Decho('(NetrwBrowseChgDir:tree-list) ....searched for treedir<'.treedir.'/> : not found')
                                endif
                               endif
                            
                               " search treedict for treedir with any trailing / elided
                               if !haskey && treedir =~ '/$'
                                let treedir= substitute(treedir,'/$','','')
                                if has_key(w:netrw_treedict,treedir)
                            "     call Decho('(NetrwBrowseChgDir:tree-list) ....searched.for treedir<'.treedir.'> found it!')
                                 let haskey = 1
                                else
                            "     call Decho('(NetrwBrowseChgDir:tree-list) ....searched for treedir<'.treedir.'> : not found')
                                endif
                               endif
                            
                               if haskey
                                " close tree listing for selected subdirectory
                            "    call Decho("(NetrwBrowseChgDir:tree-list) closing selected subdirectory<".dirname.">")
                                call remove(w:netrw_treedict,treedir)
                            "    call Decho("(NetrwBrowseChgDir) removed     entry<".treedir."> from treedict")
                            "    call Decho("(NetrwBrowseChgDir) yielding treedict<".string(w:netrw_treedict).">")
                                let dirname= w:netrw_treetop
                               else
                                " go down one directory
                                let dirname= substitute(treedir,'/*$','/','')
                            "    call Decho("(NetrwBrowseChgDir:tree-list) go down one dir: treedir<".treedir.">")
                               endif
                               keepj call s:SetRexDir(a:islocal,dirname)
                               let s:treeforceredraw = 1
                            
                              else
                               " ----------------------------------------
                               " NetrwBrowseChgDir: Go down one directory {{{3
                               " ----------------------------------------
    8   0.000787   0.000060    let dirname    = s:ComposePath(dirname,newdir)
                            "   call Decho("(NetrwBrowseChgDir:go-down) go down one dir: dirname<".dirname."> newdir<".newdir.">")
    8   0.000111   0.000051    keepj call s:SetRexDir(a:islocal,dirname)
    8              0.000006   endif
                            
                             " --------------------------------------
                             " NetrwBrowseChgDir: Restore and Cleanup {{{3
                             " --------------------------------------
   12   0.009825   0.000075   keepj call s:NetrwOptionRestore("s:")
   12              0.000017   if dolockout
                            "   call Decho("(NetrwBrowseChgDir:restore) filewritable(dirname<".dirname.">)=".filewritable(dirname))
    2              0.000041    if filewritable(dirname)
                            "    call Decho("(NetrwBrowseChgDir:restore) doing modification lockout settings: ma nomod noro")
                            "    call Decho("(NetrwBrowseChgDir:restore) setl ma nomod noro")
    2              0.000021     setl ma nomod noro
                            "    call Decho("(NetrwBrowseChgDir:restore) ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
    2              0.000002    else
                            "    call Decho("(NetrwBrowseChgDir:restore) doing modification lockout settings: ma nomod ro")
                            "    call Decho("(NetrwBrowseChgDir:restore) setl ma nomod noro")
                                setl ma nomod ro
                            "    call Decho("(NetrwBrowseChgDir:restore) ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
                               endif
    2              0.000001   endif
   12              0.000050   let @@= ykeep
                            
                            "  call Dret("s:NetrwBrowseChgDir <".dirname."> : curpos<".string(getpos(".")).">")
   12              0.000025   return dirname

FUNCTION  neobundle#config#is_sourced()
Called 6 times
Total time:   0.000056
 Self time:   0.000033

count  total (s)   self (s)
    6   0.000052   0.000029   return get(neobundle#config#get(a:name), 'sourced', 0)

FUNCTION  airline#check_mode()
Called 139 times
Total time:   0.012514
 Self time:   0.012514

count  total (s)   self (s)
  139              0.000739   let context = s:contexts[a:winnr]
                            
  139              0.000625   if get(w:, 'airline_active', 1)
  139              0.000463     let l:m = mode()
  139              0.000350     if l:m ==# "i"
                                  let l:mode = ['insert']
                                elseif l:m ==# "R"
                                  let l:mode = ['replace']
                                elseif l:m =~# '\v(v|V||s|S|)'
                                  let l:mode = ['visual']
                                else
  139              0.000395       let l:mode = ['normal']
  139              0.000157     endif
  139              0.000838     let w:airline_current_mode = get(g:airline_mode_map, l:m, l:m)
  139              0.000121   else
                                let l:mode = ['inactive']
                                let w:airline_current_mode = get(g:airline_mode_map, '__')
                              endif
                            
  139              0.000242   if g:airline_detect_modified
  139              0.000365     if &modified
                                  call add(l:mode, 'modified')
                                endif
  139              0.000096   endif
                            
  139              0.000307   if g:airline_detect_paste && &paste
                                call add(l:mode, 'paste')
                              endif
                            
  139              0.000673   let mode_string = join(l:mode)
  139              0.000704   if get(w:, 'airline_lastmode', '') != mode_string
                                call airline#highlighter#highlight_modified_inactive(context.bufnr)
                                call airline#highlighter#highlight(l:mode)
                                let w:airline_lastmode = mode_string
                              endif
                            
  139              0.000167   return ''

FUNCTION  jslibsyntax#load()
Called 3 times
Total time:   0.020041
 Self time:   0.004165

count  total (s)   self (s)
    3              0.000018   if !exists('g:used_javascript_libs') 
    1              0.000006     let g:used_javascript_libs = join(s:libs, ',')
    1              0.000001   endif
                            
    3              0.000008   let index = 0
    3              0.000007   let loaded = 0
   24              0.000082   while index < len(s:libs)
   21              0.000083     let lib = s:libs[index]
   21              0.000182     let use = g:used_javascript_libs =~ lib
   21              0.000122     if exists('b:javascript_lib_use_'.lib)
                                  exec('let use = b:javascript_lib_use_'.lib)
                                endif
   21              0.000021     if use
   21              0.000140       let fn = s:path.'/syntax/'.lib.'.'.&filetype.'.vim'
   21              0.000408       if filereadable(fn)
   21   0.017847   0.002206         exe('source '.fnameescape(fn))
   21              0.000123         let loaded = loaded + 1
   21              0.000023       endif
   21              0.000015     endif
   21              0.000057     let index = index + 1
   21              0.000025   endwhile
    3              0.000024   let fn = s:path.'/syntax/postprocess.'.&filetype.'.vim'
    3              0.000071   if loaded > 0 && filereadable(fn)
    3   0.000540   0.000305     exe('source '.fnameescape(fn))
    3              0.000004   endif

FUNCTION  DetectNode()
Called 4 times
Total time:   0.000034
 Self time:   0.000034

count  total (s)   self (s)
    4              0.000009   if !did_filetype()
                                if getline(1) =~ '^#.*\<node\>'
                                  setfiletype javascript
                                endif
                              endif

FUNCTION  <SNR>139_NetrwSafeOptions()
Called 24 times
Total time:   0.192069
 Self time:   0.007332

count  total (s)   self (s)
                            "  call Dfunc("s:NetrwSafeOptions() win#".winnr()." buf#".bufnr("%")."<".bufname(bufnr("%"))."> winnr($)=".winnr("$"))
                            "  call Decho("win#".winnr()."'s ft=".&ft)
   24              0.000319   if exists("+acd") | setl noacd | endif
   24              0.000100   setl noai
   24              0.000089   setl noaw
   24              0.000040   setl nobomb
   24              0.000086   setl noci
   24              0.000085   setl nocin
   24              0.000066   if g:netrw_liststyle == s:TREELIST
                               setl bh=hide
                              endif
   24              0.000144   setl cino=
   24              0.000123   setl com=
   24              0.000152   setl cpo-=a
   24              0.000118   setl cpo-=A
   24              0.000124   setl fo=nroql2
   24              0.000084    setl nohid
   24              0.000072   setl noim
   24              0.004238   setl isk+=@ isk+=* isk+=/
   24              0.000045   setl magic
   24              0.000082   setl report=10000
   24              0.000089   setl sel=inclusive
   24              0.000045   setl nospell
   24              0.000101   setl tw=0
   24              0.000076   setl wig=
   24              0.000053   set  cedit&
   24              0.000090   if g:netrw_use_noswf && has("win32") && !has("win95")
                               setl noswf
                              endif
   24   0.001732   0.000152   call s:NetrwCursor()
                            
                              " allow the user to override safe options
                            "  call Decho("ft<".&ft."> ei=".&ei)
   24              0.000106   if &ft == "netrw"
                            "   call Decho("do any netrw FileType autocmds (doau FileType netrw)")
   24   0.183385   0.000228    sil! keepalt keepj doau FileType netrw
   24              0.000023   endif
                            
                            "  call Decho("fo=".&fo.(exists("+acd")? " acd=".&acd : " acd doesn't exist")." bh=".&l:bh)
                            "  call Dret("s:NetrwSafeOptions")

FUNCTION  ctrlp#utils#writecache()
Called 2 times
Total time:   0.000758
 Self time:   0.000728

count  total (s)   self (s)
    2   0.000051   0.000021 	if isdirectory(ctrlp#utils#mkdir(a:0 ? a:1 : s:cache_dir))
    2              0.000702 		sil! cal writefile(a:lines, a:0 >= 2 ? a:2 : ctrlp#utils#cachefile())
    2              0.000004 	en

FUNCTION  <SNR>110_get_array()
Called 364 times
Total time:   0.005061
 Self time:   0.005061

count  total (s)   self (s)
  364              0.000768   let fg = a:fg
  364              0.000578   let bg = a:bg
  364              0.003345   return has('gui_running') ? [ fg, bg, '', '', join(a:opts, ',') ] : [ '', '', fg, bg, join(a:opts, ',') ]

FUNCTION  airline#themes#get_highlight()
Called 364 times
Total time:   0.047567
 Self time:   0.003386

count  total (s)   self (s)
  364   0.047369   0.003188   return call('airline#highlighter#get_highlight', [a:group] + a:000)

FUNCTION  <SNR>139_NetrwCursor()
Called 26 times
Total time:   0.001716
 Self time:   0.001716

count  total (s)   self (s)
   26              0.000114   if !exists("w:netrw_liststyle")
                               let w:netrw_liststyle= g:netrw_liststyle
                              endif
                            "  call Dfunc("s:NetrwCursor() ft<".&ft."> liststyle=".w:netrw_liststyle." g:netrw_cursor=".g:netrw_cursor." s:netrw_usercuc=".s:netrw_usercuc." s:netrw_usercul=".s:netrw_usercul)
                            
   26              0.000119   if &ft != "netrw"
                               " if the current window isn't a netrw directory listing window, then use user cursorline/column
                               " settings.  Affects when netrw is used to read/write a file using scp/ftp/etc.
                            "   call Decho("case ft!=netrw: use user cul,cuc")
    2              0.000014    let &l:cursorline   = s:netrw_usercul
    2              0.000006    let &l:cursorcolumn = s:netrw_usercuc
                            
    2              0.000004   elseif g:netrw_cursor == 4
                               " all styles: cursorline, cursorcolumn
                            "   call Decho("case g:netrw_cursor==4: setl cul cuc")
                               setl cursorline
                               setl cursorcolumn
                            
                              elseif g:netrw_cursor == 3
                               " thin-long-tree: cursorline, user's cursorcolumn
                               " wide          : cursorline, cursorcolumn
                               if w:netrw_liststyle == s:WIDELIST
                            "    call Decho("case g:netrw_cursor==3 and wide: setl cul cuc")
                                setl cursorline
                                setl cursorcolumn
                               else
                            "    call Decho("case g:netrw_cursor==3 and not wide: setl cul (use user's cuc)")
                                setl cursorline
                                let &l:cursorcolumn   = s:netrw_usercuc
                               endif
                            
                              elseif g:netrw_cursor == 2
                               " thin-long-tree: cursorline, user's cursorcolumn
                               " wide          : cursorline, user's cursorcolumn
                            "   call Decho("case g:netrw_cursor==2: setl cuc (use user's cul)")
   24              0.000097    let &l:cursorcolumn = s:netrw_usercuc
   24              0.000056    setl cursorline
                            
   24              0.000037   elseif g:netrw_cursor == 1
                               " thin-long-tree: user's cursorline, user's cursorcolumn
                               " wide          : cursorline,        user's cursorcolumn
                               let &l:cursorcolumn = s:netrw_usercuc
                               if w:netrw_liststyle == s:WIDELIST
                            "    call Decho("case g:netrw_cursor==2 and wide: setl cul (use user's cuc)")
                                set cursorline
                               else
                            "    call Decho("case g:netrw_cursor==2 and not wide: (use user's cul,cuc)")
                                let &l:cursorline   = s:netrw_usercul
                               endif
                            
                              else
                               " all styles: user's cursorline, user's cursorcolumn
                            "   call Decho("default: (use user's cul,cuc)")
                               let &l:cursorline   = s:netrw_usercul
                               let &l:cursorcolumn = s:netrw_usercuc
                              endif
                            
                            "  call Dret("s:NetrwCursor : l:cursorline=".&l:cursorline." l:cursorcolumn=".&l:cursorcolumn)

FUNCTION  <SNR>28_BMFilename()
Called 50 times
Total time:   0.003613
 Self time:   0.001657

count  total (s)   self (s)
   50              0.000299   if isdirectory(a:name)
   40              0.000046     return
                              endif
   10   0.001532   0.000074   let munge = <SID>BMMunge(a:name, a:num)
   10   0.000564   0.000066   let hash = <SID>BMHash(munge)
   10              0.000018   if s:bmenu_short == 0
   10              0.000065     let name = 'an ' . g:bmenu_priority . '.' . hash . ' &Buffers.' . munge
   10              0.000008   else
                                let name = 'an ' . g:bmenu_priority . '.' . hash . '.' . hash . ' &Buffers.' . <SID>BMHash2(munge) . munge
                              endif
                              " set 'cpo' to include the <CR>
   10              0.000048   let cpo_save = &cpo
   10              0.000061   set cpo&vim
   10              0.000738   exe name . ' :confirm b' . a:num . '<CR>'
   10              0.000076   let &cpo = cpo_save

FUNCTION  <SNR>139_NetrwBookHistRead()
Called 1 time
Total time:   0.002636
 Self time:   0.002345

count  total (s)   self (s)
                            "  call Dfunc("s:NetrwBookHistRead()")
    1              0.000004   if !exists("g:netrw_dirhistmax") || g:netrw_dirhistmax <= 0
                            "   "  call Dret("s:NetrwBookHistRead - suppressed due to g:netrw_dirhistmax")
                               return
                              endif
    1              0.000002   let ykeep= @@
    1              0.000003   if !exists("s:netrw_initbookhist")
    1   0.000190   0.000010    let home    = s:NetrwHome()
    1              0.000003    let savefile= home."/.netrwbook"
    1              0.000026    if filereadable(savefile)
                            "    call Decho("sourcing .netrwbook")
                                exe "keepalt keepj so ".savefile
                               endif
    1              0.000002    if g:netrw_dirhistmax > 0
    1              0.000003     let savefile= home."/.netrwhist"
    1              0.000074     if filereadable(savefile)
                            "    call Decho("sourcing .netrwhist")
    1   0.002288   0.002177      exe "keepalt keepj so ".savefile
    1              0.000002     endif
    1              0.000002     let s:netrw_initbookhist= 1
    1              0.000015     au VimLeave * call s:NetrwBookHistSave()
    1              0.000001    endif
    1              0.000001   endif
    1              0.000005   let @@= ykeep
                            "  call Dret("s:NetrwBookHistRead")

FUNCTION  <SNR>139_NetrwGetWord()
Called 12 times
Total time:   0.003096
 Self time:   0.002145

count  total (s)   self (s)
                            "  call Dfunc("s:NetrwGetWord() line#".line(".")." liststyle=".g:netrw_liststyle." virtcol=".virtcol("."))
   12   0.001123   0.000172   call s:UseBufWinVars()
                            
                              " insure that w:netrw_liststyle is set up
   12              0.000042   if !exists("w:netrw_liststyle")
                               if exists("g:netrw_liststyle")
                                let w:netrw_liststyle= g:netrw_liststyle
                               else
                                let w:netrw_liststyle= s:THINLIST
                               endif
                            "   call Decho("w:netrw_liststyle=".w:netrw_liststyle)
                              endif
                            
   12              0.000078   if exists("w:netrw_bannercnt") && line(".") < w:netrw_bannercnt
                               " Active Banner support
                            "   call Decho("active banner handling")
                               keepj norm! 0
                               let dirname= "./"
                               let curline= getline('.')
                            
                               if curline =~ '"\s*Sorted by\s'
                                keepj norm s
                                let s:netrw_skipbrowse= 1
                                echo 'Pressing "s" also works'
                            
                               elseif curline =~ '"\s*Sort sequence:'
                                let s:netrw_skipbrowse= 1
                                echo 'Press "S" to edit sorting sequence'
                            
                               elseif curline =~ '"\s*Quick Help:'
                                keepj norm ?
                                let s:netrw_skipbrowse= 1
                                echo 'Pressing "?" also works'
                            
                               elseif curline =~ '"\s*\%(Hiding\|Showing\):'
                                keepj norm a
                                let s:netrw_skipbrowse= 1
                                echo 'Pressing "a" also works'
                            
                               elseif line("$") > w:netrw_bannercnt
                                exe 'sil keepj '.w:netrw_bannercnt
                               endif
                            
                              elseif w:netrw_liststyle == s:THINLIST
                            "   call Decho("thin column handling")
   12              0.000148    keepj norm! 0
   12              0.000076    let dirname= getline('.')
                            
   12              0.000023   elseif w:netrw_liststyle == s:LONGLIST
                            "   call Decho("long column handling")
                               keepj norm! 0
                               let dirname= substitute(getline('.'),'^\(\%(\S\+ \)*\S\+\).\{-}$','\1','e')
                            
                              elseif w:netrw_liststyle == s:TREELIST
                            "   call Decho("treelist handling")
                               let dirname= substitute(getline('.'),'^\(| \)*','','e')
                            
                              else
                            "   call Decho("obtain word from wide listing")
                               let dirname= getline('.')
                            
                               if !exists("b:netrw_cpf")
                                let b:netrw_cpf= 0
                                exe 'sil keepj '.w:netrw_bannercnt.',$g/^./if virtcol("$") > b:netrw_cpf|let b:netrw_cpf= virtcol("$")|endif'
                                call histdel("/",-1)
                            "   call Decho("computed cpf=".b:netrw_cpf)
                               endif
                            
                            "   call Decho("buf#".bufnr("%")."<".bufname("%").">")
                               let filestart = (virtcol(".")/b:netrw_cpf)*b:netrw_cpf
                            "   call Decho("filestart= ([virtcol=".virtcol(".")."]/[b:netrw_cpf=".b:netrw_cpf."])*b:netrw_cpf=".filestart."  bannercnt=".w:netrw_bannercnt)
                            "   call Decho("1: dirname<".dirname.">")
                               if filestart == 0
                                keepj norm! 0ma
                               else
                                call cursor(line("."),filestart+1)
                                keepj norm! ma
                               endif
                               let rega= @a
                               let eofname= filestart + b:netrw_cpf + 1
                               if eofname <= col("$")
                                call cursor(line("."),filestart+b:netrw_cpf+1)
                                keepj norm! "ay`a
                               else
                                keepj norm! "ay$
                               endif
                               let dirname = @a
                               let @a      = rega
                            "   call Decho("2: dirname<".dirname.">")
                               let dirname= substitute(dirname,'\s\+$','','e')
                            "   call Decho("3: dirname<".dirname.">")
                              endif
                            
                              " symlinks are indicated by a trailing "@".  Remove it before further processing.
   12              0.000159   let dirname= substitute(dirname,"@$","","")
                            
                              " executables are indicated by a trailing "*".  Remove it before further processing.
   12              0.000078   let dirname= substitute(dirname,"\*$","","")
                            
                            "  call Dret("s:NetrwGetWord <".dirname.">")
   12              0.000028   return dirname

FUNCTION  <SNR>18_SelectJavascript()
Called 4 times
Total time:   0.000055
 Self time:   0.000055

count  total (s)   self (s)
    4              0.000033   if getline(1) =~# '^#!.*/bin/env\s\+node\>'
                                set ft=javascript
                              endif

FUNCTION  sy#sign#set()
Called 28 times
Total time:   1.867448
 Self time:   1.867448

count  total (s)   self (s)
   28              0.000186   let hunk = { 'ids': [], 'start': a:signs[0].lnum, 'end': a:signs[-1].lnum }
                            
  106              0.000163   for sign in a:signs
                                " Preserve non-signify signs
   78              0.000322     if !g:signify_sign_overwrite && has_key(s:other_signs_line_numbers, sign.lnum)
                                  continue
                                endif
                            
   78              0.000178     call add(hunk.ids, g:id_top)
   78              1.865394     execute 'sign place' g:id_top 'line='. sign.lnum 'name='. sign.type 'file='. sign.path
                            
   78              0.000220     let g:id_top += 1
   78              0.000174   endfor
                            
   28              0.000111   call add(g:sy[sign.path].hunks, hunk)

FUNCTION  <SNR>139_NetrwWideListing()
Called 12 times
Total time:   0.001318
 Self time:   0.001318

count  total (s)   self (s)
                            
   12              0.000031   if w:netrw_liststyle == s:WIDELIST
                            "   call Dfunc("NetrwWideListing() w:netrw_liststyle=".w:netrw_liststyle.' fo='.&fo.' l:fo='.&l:fo)
                               " look for longest filename (cpf=characters per filename)
                               " cpf: characters per filename
                               " fpl: filenames per line
                               " fpc: filenames per column
                               setl ma noro
                            "   call Decho("setl ma noro")
                               let b:netrw_cpf= 0
                               if line("$") >= w:netrw_bannercnt
                                exe 'sil keepj '.w:netrw_bannercnt.',$g/^./if virtcol("$") > b:netrw_cpf|let b:netrw_cpf= virtcol("$")|endif'
                                keepj call histdel("/",-1)
                               else
                            "    call Dret("NetrwWideListing")
                                return
                               endif
                               let b:netrw_cpf= b:netrw_cpf + 2
                            "   call Decho("b:netrw_cpf=max_filename_length+2=".b:netrw_cpf)
                            
                               " determine qty files per line (fpl)
                               let w:netrw_fpl= winwidth(0)/b:netrw_cpf
                               if w:netrw_fpl <= 0
                                let w:netrw_fpl= 1
                               endif
                            "   call Decho("fpl= [winwidth=".winwidth(0)."]/[b:netrw_cpf=".b:netrw_cpf.']='.w:netrw_fpl)
                            
                               " make wide display
                               exe 'sil keepj '.w:netrw_bannercnt.',$s/^.*$/\=escape(printf("%-'.b:netrw_cpf.'s",submatch(0)),"\\")/'
                               keepj call histdel("/",-1)
                               let fpc         = (line("$") - w:netrw_bannercnt + w:netrw_fpl)/w:netrw_fpl
                               let newcolstart = w:netrw_bannercnt + fpc
                               let newcolend   = newcolstart + fpc - 1
                            "   call Decho("bannercnt=".w:netrw_bannercnt." fpl=".w:netrw_fpl." fpc=".fpc." newcol[".newcolstart.",".newcolend."]")
                               sil! let keepregstar = @*
                               while line("$") >= newcolstart
                                if newcolend > line("$") | let newcolend= line("$") | endif
                                let newcolqty= newcolend - newcolstart
                                exe newcolstart
                                if newcolqty == 0
                                 exe "sil! keepj norm! 0\<c-v>$hx".w:netrw_bannercnt."G$p"
                                else
                                 exe "sil! keepj norm! 0\<c-v>".newcolqty.'j$hx'.w:netrw_bannercnt.'G$p'
                                endif
                                exe "sil! keepj ".newcolstart.','.newcolend.'d'
                                exe 'sil! keepj '.w:netrw_bannercnt
                               endwhile
                               sil! let @*= keepregstar
                               exe "sil! keepj ".w:netrw_bannercnt.',$s/\s\+$//e'
                               keepj call histdel("/",-1)
                               exe "nmap <buffer> <silent> w	/^\\\\|\\s\\s\\zs\\S/\<cr>"
                               exe "nmap <buffer> <silent> b	?^\\\\|\\s\\s\\zs\\S?\<cr>"
                            "   call Decho("NetrwWideListing) setl noma nomod ro")
                               setl noma nomod ro
                            "   call Decho("(NetrwWideListing) ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
                            "   call Dret("NetrwWideListing")
                               return
                              else
   12              0.000082    if hasmapto("w","n")
   12              0.000210     sil! nunmap <buffer> w
   12              0.000009    endif
   12              0.000042    if hasmapto("b","n")
   12              0.000108     sil! nunmap <buffer> b
   12              0.000018    endif
   12              0.000007   endif
                            

FUNCTION  fugitive#buffer()
Called 24 times
Total time:   0.000831
 Self time:   0.000154

count  total (s)   self (s)
   24   0.000814   0.000137   return s:buffer(a:0 ? a:1 : '%')

FUNCTION  <SNR>108_get_buffers()
Called 20 times
Total time:   0.038545
 Self time:   0.002899

count  total (s)   self (s)
   20   0.000917   0.000155   let b = airline#builder#new(s:builder_context)
   20              0.000081   let cur = bufnr('%')
   20              0.000093   let tab_bufs = tabpagebuflist(tabpagenr())
   53   0.009536   0.000225   for nr in s:get_visible_buffers()
   33              0.000050     if nr < 0
                                  call b.add_raw('%#airline_tabhid#...')
                                  continue
                                endif
   33              0.000049     if cur == nr
    8              0.000054       if g:airline_detect_modified && getbufvar(nr, '&modified')
                                    let group = 'airline_tabmod'
                                  else
    8              0.000018         let group = 'airline_tabsel'
    8              0.000013       endif
    8              0.000006     else
   25              0.000068       if index(tab_bufs, nr) > -1
                                    let group = 'airline_tab'
                                  else
   25              0.000048         let group = 'airline_tabhid'
   25              0.000020       endif
   25              0.000016     endif
   33   0.005504   0.000405     call b.add_section(group, s:spc.'%(%{airline#extensions#tabline#get_buffer_name('.nr.')}%)'.s:spc)
   33              0.000030   endfor
                            
   20   0.010249   0.000144   call b.add_section('airline_tabfill', '')
   20   0.000257   0.000096   call b.split()
   20   0.010178   0.000138   call b.add_section('airline_tabtype', ' buffers ')
   20   0.000280   0.000112   return b.build()

FUNCTION  neobundle#get_not_installed_bundles()
Called 1 time
Total time:   0.003055
 Self time:   0.000095

count  total (s)   self (s)
    1   0.002751   0.000012   let bundles = empty(a:bundle_names) ? neobundle#config#get_neobundles() : neobundle#config#fuzzy_search(a:bundle_names)
                            
    1   0.000138   0.000022   call neobundle#installer#_load_install_info(bundles)
                            
    1   0.000163   0.000058   return filter(copy(bundles), "  v:val.rtp != '' && !v:val.local  && !isdirectory(neobundle#util#expand(v:val.path))")

FUNCTION  airline#parts#filetype()
Called 20 times
Total time:   0.000067
 Self time:   0.000067

count  total (s)   self (s)
   20              0.000057   return &filetype

FUNCTION  airline#parts#iminsert()
Called 20 times
Total time:   0.000168
 Self time:   0.000168

count  total (s)   self (s)
   20              0.000069   if g:airline_detect_iminsert && &iminsert && exists('b:keymap_name')
                                return toupper(b:keymap_name)
                              endif
   20              0.000019   return ''

FUNCTION  <SNR>63_addtomrufs()
Called 28 times
Total time:   0.004478
 Self time:   0.003350

count  total (s)   self (s)
   28              0.000339 	let fn = fnamemodify(a:fname, ':p')
   28              0.000197 	let fn = exists('+ssl') ? tr(fn, '/', '\') : fn
   28              0.002567 	if ( !empty({s:in}) && fn !~# {s:in} ) || ( !empty({s:ex}) && fn =~# {s:ex} ) || !empty(getbufvar('^'.fn.'$', '&bt')) || !filereadable(fn) | retu
                            	en
    6              0.000043 	let idx = index(s:mrufs, fn, 0, !{s:cseno})
    6              0.000007 	if idx
    2              0.000018 		cal filter(s:mrufs, 'v:val !='.( {s:cseno} ? '#' : '?' ).' fn')
    2              0.000006 		cal insert(s:mrufs, fn)
    2              0.000007 		if {s:soup} && idx < 0
    2   0.001183   0.000055 			cal s:savetofile(s:mergelists())
    2              0.000001 		en
    2              0.000002 	en

FUNCTION  <SNR>115_get_section()
Called 228 times
Total time:   0.008968
 Self time:   0.007926

count  total (s)   self (s)
  228              0.000822   if has_key(s:section_truncate_width, a:key)
   81              0.000311     if winwidth(a:winnr) < s:section_truncate_width[a:key]
                                  return ''
                                endif
   81              0.000046   endif
  228              0.000521   let spc = g:airline_symbols.space
  228   0.003085   0.002043   let text = airline#util#getwinvar(a:winnr, 'airline_section_'.a:key, g:airline_section_{a:key})
  228              0.001918   let [prefix, suffix] = [get(a:000, 0, '%('.spc), get(a:000, 1, spc.'%)')]
  228              0.001008   return empty(text) ? '' : prefix.text.suffix

FUNCTION  <SNR>139_LocalBrowseShellCmdRefresh()
Called 1 time
Total time:   0.000056
 Self time:   0.000056

count  total (s)   self (s)
                            "  call Dfunc("LocalBrowseShellCmdRefresh() browselist=".(exists("s:netrw_browselist")? string(s:netrw_browselist) : "empty")." ".tabpagenr("$")." tabs")
                              " determine which buffers currently reside in a tab
    1              0.000009   if !exists("s:netrw_browselist")
                            "   call Dret("LocalBrowseShellCmdRefresh : browselist is empty")
                               return
                              endif
    1              0.000006   if !exists("w:netrw_bannercnt")
                            "   call Dret("LocalBrowseShellCmdRefresh : don't refresh when focus not on netrw window")
                               return
                              endif
    1              0.000006   if exists("s:locbrowseshellcmd")
    1              0.000003    if s:locbrowseshellcmd
    1              0.000005     let s:locbrowseshellcmd= 0
                            "    call Dret("LocalBrowseShellCmdRefresh : NetrwBrowse itself caused the refresh")
    1              0.000002     return
                               endif
                               let s:locbrowseshellcmd= 0
                              endif
                              let itab       = 1
                              let buftablist = []
                              let ykeep      = @@
                              while itab <= tabpagenr("$")
                               let buftablist = buftablist + tabpagebuflist()
                               let itab       = itab + 1
                               tabn
                              endwhile
                            "  call Decho("(LocalBrowseShellCmdRefresh) buftablist".string(buftablist))
                            "  call Decho("(LocalBrowseShellCmdRefresh) s:netrw_browselist<".(exists("s:netrw_browselist")? string(s:netrw_browselist) : "").">")
                              "  GO through all buffers on netrw_browselist (ie. just local-netrw buffers):
                              "   | refresh any netrw window
                              "   | wipe out any non-displaying netrw buffer
                              let curwin = winnr()
                              let ibl    = 0
                              for ibuf in s:netrw_browselist
                            "   call Decho("(LocalBrowseShellCmdRefresh) bufwinnr(".ibuf.") index(buftablist,".ibuf.")=".index(buftablist,ibuf))
                               if bufwinnr(ibuf) == -1 && index(buftablist,ibuf) == -1
                                " wipe out any non-displaying netrw buffer
                            "    call Decho("(LocalBrowseShellCmdRefresh) wiping  buf#".ibuf,"<".bufname(ibuf).">")
                                exe "sil! bd ".fnameescape(ibuf)
                                call remove(s:netrw_browselist,ibl)
                            "    call Decho("(LocalBrowseShellCmdRefresh) browselist=".string(s:netrw_browselist))
                                continue
                               elseif index(tabpagebuflist(),ibuf) != -1
                                " refresh any netrw buffer
                            "    call Decho("(LocalBrowseShellCmdRefresh) refresh buf#".ibuf.'-> win#'.bufwinnr(ibuf))
                                exe bufwinnr(ibuf)."wincmd w"
                                keepj call s:NetrwRefresh(1,s:NetrwBrowseChgDir(1,'./'))
                               endif
                               let ibl= ibl + 1
                              endfor
                              exe curwin."wincmd w"
                              let @@= ykeep
                            
                            "  call Dret("LocalBrowseShellCmdRefresh")

FUNCTION  <SNR>139_UseBufWinVars()
Called 24 times
Total time:   0.001712
 Self time:   0.001712

count  total (s)   self (s)
                            "  call Dfunc("s:UseBufWinVars()")
   24              0.000297   if exists("b:netrw_liststyle")       && !exists("w:netrw_liststyle")      |let w:netrw_liststyle       = b:netrw_liststyle      |endif
   24              0.000180   if exists("b:netrw_bannercnt")       && !exists("w:netrw_bannercnt")      |let w:netrw_bannercnt       = b:netrw_bannercnt      |endif
   24              0.000134   if exists("b:netrw_method")          && !exists("w:netrw_method")         |let w:netrw_method          = b:netrw_method         |endif
   24              0.000174   if exists("b:netrw_prvdir")          && !exists("w:netrw_prvdir")         |let w:netrw_prvdir          = b:netrw_prvdir         |endif
   24              0.000141   if exists("b:netrw_explore_indx")    && !exists("w:netrw_explore_indx")   |let w:netrw_explore_indx    = b:netrw_explore_indx   |endif
   24              0.000144   if exists("b:netrw_explore_listlen") && !exists("w:netrw_explore_listlen")|let w:netrw_explore_listlen = b:netrw_explore_listlen|endif
   24              0.000133   if exists("b:netrw_explore_mtchcnt") && !exists("w:netrw_explore_mtchcnt")|let w:netrw_explore_mtchcnt = b:netrw_explore_mtchcnt|endif
   24              0.000138   if exists("b:netrw_explore_bufnr")   && !exists("w:netrw_explore_bufnr")  |let w:netrw_explore_bufnr   = b:netrw_explore_bufnr  |endif
   24              0.000127   if exists("b:netrw_explore_line")    && !exists("w:netrw_explore_line")   |let w:netrw_explore_line    = b:netrw_explore_line   |endif
   24              0.000132   if exists("b:netrw_explore_list")    && !exists("w:netrw_explore_list")   |let w:netrw_explore_list    = b:netrw_explore_list   |endif
                            "  call Dret("s:UseBufWinVars")

FUNCTION  <SNR>28_BMRemove()
Called 48 times
Total time:   0.002349
 Self time:   0.001722

count  total (s)   self (s)
   48              0.000104   if s:bmenu_wait == 0
   48              0.000786     let name = expand("<afile>")
   48              0.000253     if isdirectory(name)
   41              0.000046       return
                                endif
    7   0.000682   0.000055     let munge = <SID>BMMunge(name, expand("<abuf>"))
                            
    7              0.000012     if s:bmenu_short == 0
    7              0.000281       exe 'silent! aun &Buffers.' . munge
    7              0.000010     else
                                  exe 'silent! aun &Buffers.' . <SID>BMHash2(munge) . munge
                                endif
    7              0.000023     let s:bmenu_count = s:bmenu_count - 1
    7              0.000007   endif

FUNCTION  sy#util#escape()
Called 4 times
Total time:   0.000071
 Self time:   0.000071

count  total (s)   self (s)
    4              0.000011   if exists('+shellslash')
                                let old_ssl = &shellslash
                                set noshellslash
                              endif
                            
    4              0.000016   let path = shellescape(a:path)
                            
    4              0.000006   if exists('old_ssl')
                                let &shellslash = old_ssl
                              endif
                            
    4              0.000005   return path

FUNCTION  fugitive#detect()
Called 34 times
Total time:   0.028345
 Self time:   0.004602

count  total (s)   self (s)
   34              0.000259   if exists('b:git_dir') && (b:git_dir ==# '' || b:git_dir =~# '/$')
                                unlet b:git_dir
                              endif
   34              0.000085   if !exists('b:git_dir')
   18   0.006898   0.000119     let dir = fugitive#extract_git_dir(a:path)
   18              0.000034     if dir !=# ''
    8              0.000018       let b:git_dir = dir
    8              0.000007     endif
   18              0.000012   endif
   34              0.000086   if exists('b:git_dir')
   24   0.016514   0.000656     silent doautocmd User Fugitive
   24              0.001099     cnoremap <buffer> <expr> <C-R><C-G> fnameescape(<SID>recall())
   24              0.000446     nnoremap <buffer> <silent> y<C-G> :call setreg(v:register, <SID>recall())<CR>
   24   0.000959   0.000128     let buffer = fugitive#buffer()
   24              0.000264     if expand('%:p') =~# '//'
                                  call buffer.setvar('&path', s:sub(buffer.getvar('&path'), '^\.%(,|$)', ''))
                                endif
   24   0.000386   0.000266     if stridx(buffer.getvar('&tags'), escape(b:git_dir.'/tags', ', ')) == -1
    8   0.000179   0.000089       call buffer.setvar('&tags', escape(b:git_dir.'/tags', ', ').','.buffer.getvar('&tags'))
    8              0.000016       if &filetype !=# ''
    8   0.000167   0.000102         call buffer.setvar('&tags', escape(b:git_dir.'/'.&filetype.'.tags', ', ').','.buffer.getvar('&tags'))
    8              0.000008       endif
    8              0.000001     endif
   24              0.000012   endif

FUNCTION  <SNR>63_record()
Called 42 times
Total time:   0.005738
 Self time:   0.001260

count  total (s)   self (s)
   42              0.000133 	if s:locked | retu | en
   42              0.000121 	let bufnr = a:bufnr + 0
   42              0.000135 	let bufname = bufname(bufnr)
   42              0.000134 	if bufnr > 0 && !empty(bufname)
   28              0.000224 		cal filter(s:mrbs, 'v:val != bufnr')
   28              0.000081 		cal insert(s:mrbs, bufnr)
   28   0.004657   0.000179 		cal s:addtomrufs(bufname)
   28              0.000035 	en

FUNCTION  ctrlp#utils#readfile()
Called 2 times
Total time:   0.000136
 Self time:   0.000136

count  total (s)   self (s)
    2              0.000034 	if filereadable(a:file)
    2              0.000079 		let data = readfile(a:file)
    2              0.000009 		if empty(data) || type(data) != 3
                            			unl data
                            			let data = []
                            		en
    2              0.000002 		retu data
                            	en
                            	retu []

FUNCTION  neobundle#config#tsort()
Called 7 times
Total time:   0.000096
 Self time:   0.000096

count  total (s)   self (s)
    7              0.000010   let sorted = []
    7              0.000014   let mark = {}
    7              0.000015   for target in a:bundles
                                call s:tsort_impl(target, a:bundles, mark, sorted)
                              endfor
                            
    7              0.000008   return sorted

FUNCTION  <SNR>83_isDebugEnabled()
Called 81 times
Total time:   0.000279
 Self time:   0.000279

count  total (s)   self (s)
                                " poor man's bit test for bit N, assuming a:level == 2**N
   81              0.000192     return (g:syntastic_debug / a:level) % 2

FUNCTION  107()
Called 20 times
Total time:   0.000151
 Self time:   0.000151

count  total (s)   self (s)
   20              0.000135     return has('signs') && exists('b:syntastic_enable_signs') ? b:syntastic_enable_signs : g:syntastic_enable_signs

FUNCTION  108()
Called 10 times
Total time:   0.001268
 Self time:   0.000306

count  total (s)   self (s)
   10   0.000140   0.000048     call syntastic#log#debug(g:SyntasticDebugNotifications, 'signs: refresh')
   10   0.000170   0.000069     let old_signs = copy(self._bufSignIds())
   10   0.000103   0.000033     if self.enabled()
   10   0.000618   0.000049         call self._signErrors(a:loclist)
   10              0.000007     endif
   10   0.000171   0.000041     call self._removeSigns(old_signs)
   10              0.000029     let s:first_sign_id = s:next_sign_id

FUNCTION  <SNR>87_LocalBrowse()
Called 11 times
Total time:   0.085733
 Self time:   0.000867

count  total (s)   self (s)
                              " unfortunate interaction -- debugging calls can't be used here;
                              " the BufEnter event causes triggering when attempts to write to
                              " the DBG buffer are made.
   11              0.000035   if !exists("s:vimentered")
                               return
                              endif
                            "  call Decho("s:LocalBrowse(dirname<".a:dirname.">){")
                            "  echomsg "dirname<".a:dirname.">"
   11              0.000045   if has("amiga")
                               " The check against '' is made for the Amiga, where the empty
                               " string is the current directory and not checking would break
                               " things such as the help command.
                            "   call Decho("(LocalBrowse) dirname<".a:dirname.">  (amiga)")
                               if a:dirname != '' && isdirectory(a:dirname)
                                sil! call netrw#LocalBrowseCheck(a:dirname)
                               endif
                              elseif isdirectory(a:dirname)
                            "   echomsg "dirname<".dirname."> isdir"
                            "   call Decho("(LocalBrowse) dirname<".a:dirname.">  (not amiga)")
    2   0.085396   0.000530    sil! call netrw#LocalBrowseCheck(a:dirname)
    2              0.000002   endif
                              " not a directory, ignore it
                            "  call Decho("|return s:LocalBrowse }")

FUNCTION  <SNR>139_NetrwInit()
Called 68 times
Total time:   0.001689
 Self time:   0.001689

count  total (s)   self (s)
                            " call Decho("varname<".a:varname."> value=".a:value)
   68              0.000194   if !exists(a:varname)
   67              0.000134    if type(a:value) == 0
   29              0.000179     exe "let ".a:varname."=".a:value
   29              0.000052    elseif type(a:value) == 1 && a:value =~ '^[{[]'
    1              0.000010     exe "let ".a:varname."=".a:value
    1              0.000002    elseif type(a:value) == 1
   37              0.000242     exe "let ".a:varname."="."'".a:value."'"
   37              0.000026    else
                                exe "let ".a:varname."=".a:value
                               endif
   67              0.000034   endif

FUNCTION  25()
Called 10 times
Total time:   0.000526
 Self time:   0.000114

count  total (s)   self (s)
   10   0.000143   0.000049     call syntastic#log#debug(g:SyntasticDebugNotifications, 'autoloclist: refresh')
   10   0.000372   0.000054     call g:SyntasticAutoloclistNotifier.AutoToggle(a:loclist)

FUNCTION  26()
Called 10 times
Total time:   0.000318
 Self time:   0.000200

count  total (s)   self (s)
   10   0.000130   0.000048     call syntastic#log#debug(g:SyntasticDebugNotifications, 'autoloclist: toggle')
   10   0.000074   0.000038     if a:loclist.hasErrorsOrWarningsToDisplay()
                                    if g:syntastic_auto_loc_list == 1
                                        call a:loclist.show()
                                    endif
                                else
   10              0.000014         if g:syntastic_auto_loc_list > 0
                            
                                        "TODO: this will close the loc list window if one was opened by
                                        "something other than syntastic
   10              0.000011             lclose
   10              0.000008         endif
   10              0.000004     endif

FUNCTION  28()
Called 20 times
Total time:   0.000130
 Self time:   0.000130

count  total (s)   self (s)
   20              0.000120     return has('balloon_eval') && (exists('b:syntastic_enable_balloons') ? b:syntastic_enable_balloons : g:syntastic_enable_balloons)

FUNCTION  29()
Called 10 times
Total time:   0.000421
 Self time:   0.000324

count  total (s)   self (s)
   10              0.000027     let b:syntastic_balloons = {}
   10   0.000160   0.000063     if self.enabled() && a:loclist.hasErrorsOrWarningsToDisplay()
                                    call syntastic#log#debug(g:SyntasticDebugNotifications, 'balloons: refresh')
                                    let buf = bufnr('')
                                    let issues = filter(a:loclist.filteredRaw(), 'v:val["bufnr"] == buf')
                                    if !empty(issues)
                                        for i in issues
                                            if has_key(b:syntastic_balloons, i['lnum'])
                                                let b:syntastic_balloons[i['lnum']] .= "\n" . i['text']
                                            else
                                                let b:syntastic_balloons[i['lnum']] = i['text']
                                            endif
                                        endfor
                                        set beval bexpr=SyntasticBalloonsExprNotifier()
                                    endif
                                endif

FUNCTION  neobundle#config#search()
Called 13 times
Total time:   0.005321
 Self time:   0.004297

count  total (s)   self (s)
                              " For infinite loop.
   13              0.000038   let self = get(a:000, 0, [])
                            
   13              0.000015   let _ = []
   19   0.002841   0.002723   for bundle in copy(filter(neobundle#config#get_neobundles(), 'index(self, v:val.name) < 0 &&       index(a:bundle_names, v:val.name) >= 0'))
    6              0.000017     call add(self, bundle.name)
                            
    6              0.000034     let _ += neobundle#config#search( map(copy(bundle.depends), 'v:val.name'), self)
    6              0.000014     call add(_, bundle)
    6              0.000003   endfor
                            
   13   0.000670   0.000054   return neobundle#util#uniq(_)

FUNCTION  110()
Called 10 times
Total time:   0.000569
 Self time:   0.000432

count  total (s)   self (s)
   10              0.000023     let loclist = a:loclist
   10   0.000172   0.000035     if loclist.hasErrorsOrWarningsToDisplay()
                            
                                    " errors some first, so that they are not masked by warnings
                                    let buf = bufnr('')
                                    let issues = copy(loclist.errors())
                                    if !loclist.quietWarnings()
                                        call extend(issues, loclist.warnings())
                                    endif
                                    call filter(issues, 'v:val["bufnr"] == buf')
                                    let seen = {}
                            
                                    for i in issues
                                        if !has_key(seen, i['lnum'])
                                            let seen[i['lnum']] = 1
                            
                                            let sign_severity = i['type'] ==? 'W' ? 'Warning' : 'Error'
                                            let sign_subtype = get(i, 'subtype', '')
                                            let sign_type = 'Syntastic' . sign_subtype . sign_severity
                            
                                            execute "sign place " . s:next_sign_id . " line=" . i['lnum'] . " name=" . sign_type . " buffer=" . i['bufnr']
                                            call add(self._bufSignIds(), s:next_sign_id)
                                            let s:next_sign_id += 1
                                        endif
                                    endfor
                                endif

FUNCTION  111()
Called 10 times
Total time:   0.000130
 Self time:   0.000130

count  total (s)   self (s)
   10              0.000033     if has('signs')
   10              0.000019         for i in a:ids
                                        execute "sign unplace " . i
                                        call remove(self._bufSignIds(), index(self._bufSignIds(), i))
                                    endfor
   10              0.000007     endif

FUNCTION  112()
Called 10 times
Total time:   0.000101
 Self time:   0.000101

count  total (s)   self (s)
   10              0.000033     if !exists("b:syntastic_sign_ids")
   10              0.000024         let b:syntastic_sign_ids = []
   10              0.000008     endif
   10              0.000016     return b:syntastic_sign_ids

FUNCTION  117()
Called 65 times
Total time:   0.000519
 Self time:   0.000519

count  total (s)   self (s)
   65              0.000119   let self._side = 0
   65              0.000333   let self._line .= '%#'.self._curgroup.'#'.(a:0 ? a:1 : '%=')

FUNCTION  119()
Called 256 times
Total time:   0.096660
 Self time:   0.024903

count  total (s)   self (s)
  256              0.000599   if self._curgroup != ''
  191              0.000442     if self._curgroup == a:group
    9              0.000036       let self._line .= self._side ? self._context.left_alt_sep : self._context.right_alt_sep
    9              0.000008     else
  182   0.073000   0.001243       call airline#highlighter#add_separator(self._curgroup, a:group, self._side)
  182              0.001302       let self._line .= '%#'.self._curgroup.'_to_'.a:group.'#'
  182              0.000752       let self._line .= self._side ? self._context.left_sep : self._context.right_sep
  182              0.000145     endif
  191              0.000128   endif
                            
  256              0.000608   if self._curgroup != a:group
  247              0.000862     let self._line .= '%#'.a:group.'#'
  247              0.000175   endif
                            
  256              0.000372   if self._context.active
  256              0.000442     let contents = []
  256              0.002157     let content_parts = split(a:contents, '__accent')
  561              0.001019     for cpart in content_parts
  305              0.002687       let accent = matchstr(cpart, '_\zs[^#]*\ze')
  305              0.001014       call add(contents, cpart)
  305              0.000297     endfor
  256              0.001081     let line = join(contents, a:group)
  256              0.002003     let line = substitute(line, '__restore__', a:group, 'g')
  256              0.000230   else
                                let line = substitute(a:contents, '%#__accent[^#]*#', '', 'g')
                                let line = substitute(line, '%#__restore__#', '', 'g')
                              endif
                            
  256              0.000605   let self._line .= line
  256              0.000532   let self._curgroup = a:group

FUNCTION  <SNR>109_create()
Called 33 times
Total time:   0.006162
 Self time:   0.005306

count  total (s)   self (s)
   33              0.000068   let _ = ''
   66              0.000190   for idx in range(len(a:parts))
   33   0.000407   0.000239     let part = airline#parts#get(a:parts[idx])
   33              0.000056     let val = ''
                            
   33              0.000109     if exists('part.function')
   33              0.000100       let func = (part.function).'()'
   33              0.000056     elseif exists('part.text')
                                  let func = '"'.(part.text).'"'
                                else
                                  if a:append > 0 && idx != 0
                                    let val .= s:spc.g:airline_left_alt_sep.s:spc
                                  endif
                                  if a:append < 0 && idx != 0
                                    let val = s:spc.g:airline_right_alt_sep.s:spc.val
                                  endif
                                  if exists('part.raw')
                                    let _ .= s:wrap_accent(part, val.(part.raw))
                                    continue
                                  else
                                    let _ .= s:wrap_accent(part, val.a:parts[idx])
                                    continue
                                  endif
                                endif
                            
   33              0.000130     let minwidth = get(part, 'minwidth', 0)
                            
   33              0.000062     if a:append > 0 && idx != 0
                                  let partval = printf('%%{airline#util#append(%s,%s)}', func, minwidth)
                                elseif a:append < 0 && idx != len(a:parts) - 1
                                  let partval = printf('%%{airline#util#prepend(%s,%s)}', func, minwidth)
                                else
   33              0.000238       let partval = printf('%%{airline#util#wrap(%s,%s)}', func, minwidth)
   33              0.000037     endif
                            
   33              0.000094     if exists('part.condition')
                                  let partval = substitute(partval, '{', '{'.(part.condition).' ? ', '')
                                  let partval = substitute(partval, '}', ' : ""}', '')
                                endif
                            
   33   0.000930   0.000242     let val .= s:wrap_accent(part, partval)
   33              0.000165     let _ .= val
   33              0.000033   endfor
   33              0.000051   return _

FUNCTION  <SNR>46_repo_dir()
Called 20 times
Total time:   0.000177
 Self time:   0.000177

count  total (s)   self (s)
   20              0.000163   return join([self.git_dir]+a:000,'/')

FUNCTION  ctrlp#mrufiles#cachefile()
Called 2 times
Total time:   0.000028
 Self time:   0.000028

count  total (s)   self (s)
    2              0.000010 	if !exists('s:cadir') || !exists('s:cafile')
                            		let s:cadir = ctrlp#utils#cachedir().ctrlp#utils#lash().'mru'
                            		let s:cafile = s:cadir.ctrlp#utils#lash().'cache.txt'
                            	en
    2              0.000002 	retu s:cafile

FUNCTION  120()
Called 24 times
Total time:   0.000087
 Self time:   0.000087

count  total (s)   self (s)
   24              0.000064   let self._line .= a:text

FUNCTION  121()
Called 65 times
Total time:   0.000524
 Self time:   0.000524

count  total (s)   self (s)
   65              0.000125   if !self._context.active
                                let self._line = substitute(self._line, '%#.\{-}\ze#', '\0_inactive', 'g')
                              endif
   65              0.000099   return self._line

FUNCTION  <SNR>139_NetrwGetBuffer()
Called 12 times
Total time:   0.080533
 Self time:   0.008522

count  total (s)   self (s)
                            "  call Dfunc("s:NetrwGetBuffer(islocal=".a:islocal." dirname<".a:dirname.">) liststyle=".g:netrw_liststyle)
                            "  call Decho("(NetrwGetBuffer) modiable=".&mod." modifiable=".&ma." readonly=".&ro)
   12              0.000037   let dirname= a:dirname
                            
                              " re-use buffer if possible {{{3
                            "  call Decho("(NetrwGetBuffer) --re-use a buffer if possible--")
   12              0.000060   if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST
                               " find NetrwTreeList buffer if there is one
                            "   call Decho("(NetrwGetBuffer) case liststyle=treelist: find NetrwTreeList buffer if there is one")
                               if exists("w:netrw_treebufnr") && w:netrw_treebufnr > 0
                            "    call Decho("(NetrwGetBuffer)   re-using w:netrw_treebufnr=".w:netrw_treebufnr)
                                setl mod
                                sil! keepj %d
                                let eikeep= &ei
                                set ei=all
                                exe "sil! keepalt b ".w:netrw_treebufnr
                                let &ei= eikeep
                            "    call Dret("s:NetrwGetBuffer 0<buffer cleared> : bufnum#".w:netrw_treebufnr."<NetrwTreeListing>")
                                return 0
                               endif
                               let bufnum= -1
                            "   call Decho("(NetrwGetBuffer)   liststyle=TREE but w:netrw_treebufnr doesn't exist")
                            
                              else
                               " find buffer number of buffer named precisely the same as dirname {{{3
                            "   call Decho("(NetrwGetBuffer) case listtyle not treelist: find buffer numnber of buffer named precisely the same as dirname--")
                            
                               " get dirname and associated buffer number
   12              0.001046    let bufnum  = bufnr(escape(dirname,'\'))
                            "   call Decho("(NetrwGetBuffer)   find buffer<".dirname.">'s number ")
                            "   call Decho("(NetrwGetBuffer)   bufnr(dirname<".escape(dirname,'\').">)=".bufnum)
                            
   12              0.000066    if bufnum < 0 && dirname !~ '/$'
                                " try appending a trailing /
                            "    call Decho("(NetrwGetBuffer)   try appending a trailing / to dirname<".dirname.">")
                                let bufnum= bufnr(escape(dirname.'/','\'))
                                if bufnum > 0
                                 let dirname= dirname.'/'
                                endif
                               endif
                            
   12              0.000040    if bufnum < 0 && dirname =~ '/$'
                                " try removing a trailing /
                            "    call Decho("(NetrwGetBuffer)   try removing a trailing / from dirname<".dirname.">")
    6              0.000734     let bufnum= bufnr(escape(substitute(dirname,'/$','',''),'\'))
    6              0.000013     if bufnum > 0
                                 let dirname= substitute(dirname,'/$','','')
                                endif
    6              0.000005    endif
                            
                            "   call Decho("(NetrwGetBuffer)   findbuf1: bufnum=bufnr('".dirname."')=".bufnum." bufname(".bufnum.")<".bufname(bufnum)."> (initial)")
                               " note: !~ was used just below, but that means using ../ to go back would match (ie. abc/def/  and abc/ matches)
   12              0.000053    if bufnum > 0 && bufname(bufnum) != dirname && bufname(bufnum) != '.'
                                " handle approximate matches
                            "    call Decho("(NetrwGetBuffer)   handling approx match: bufnum#".bufnum.">0 AND bufname<".bufname(bufnum).">!=dirname<".dirname."> AND bufname(".bufnum.")!='.'")
    3              0.000007     let ibuf    = 1
    3              0.000009     let buflast = bufnr("$")
                            "    call Decho("(NetrwGetBuffer)   findbuf2: buflast=bufnr($)=".buflast)
   15              0.000028     while ibuf <= buflast
   14              0.000104      let bname= substitute(bufname(ibuf),'\\','/','g')
   14              0.000127      let bname= substitute(bname,'.\zs/$','','')
                            "     call Decho("(NetrwGetBuffer)   findbuf3: while [ibuf=",ibuf."]<=[buflast=".buflast."]: dirname<".dirname."> bname=bufname(".ibuf.")<".bname.">")
   14              0.000127      if bname != '' && dirname =~ '/'.bname.'/\=$' && dirname !~ '^/'
                                  " bname is not empty
                                  " dirname ends with bname,
                                  " dirname doesn't start with /, so its not a absolute path
                            "      call Decho("(NetrwGetBuffer)   findbuf3a: passes test 1 : dirname<".dirname.'> =~ /'.bname.'/\=$ && dirname !~ ^/')
                                  break
                                 endif
   14              0.000128      if bname =~ '^'.dirname.'/\=$'
                                  " bname begins with dirname
                            "      call Decho('  findbuf3b: passes test 2 : bname<'.bname.'>=~^'.dirname.'/\=$')
                                  break
                                 endif
   14              0.000109      if dirname =~ '^'.bname.'/$'
                            "      call Decho('  findbuf3c: passes test 3 : dirname<'.dirname.'>=~^'.bname.'/$')
    2              0.000002       break
                                 endif
   12              0.000096      if bname != '' && dirname =~ '/'.bname.'$' && bname == bufname("%") && line("$") == 1
                            "      call Decho('  findbuf3d: passes test 4 : dirname<'.dirname.'>=~ /'.bname.'$')
                                  break
                                 endif
   12              0.000044      let ibuf= ibuf + 1
   12              0.000013     endwhile
    3              0.000004     if ibuf > buflast
    1              0.000002      let bufnum= -1
    1              0.000001     else
    2              0.000004      let bufnum= ibuf
    2              0.000002     endif
                            "    call Decho("(NetrwGetBuffer)   findbuf4: bufnum=".bufnum." (ibuf=".ibuf." buflast=".buflast.")")
    3              0.000003    endif
   12              0.000011   endif
                            
                              " get enew buffer and name it -or- re-use buffer {{{3
                            "  call Decho("(NetrwGetBuffer)   get enew buffer and name it OR re-use buffer")
   12              0.000028   sil! keepj keepalt mark '
   12              0.000036   if bufnum < 0 || !bufexists(bufnum)
                            "   call Decho("(NetrwGetBuffer) --get enew buffer and name it  (bufnum#".bufnum."<0 OR bufexists(".bufnum.")=".bufexists(bufnum)."==0)")
    7   0.064681   0.000083    call s:NetrwEnew(dirname)
                            "   call Decho("(NetrwGetBuffer)   got enew buffer#".bufnr("%")." (altbuf<".expand("#").">)")
                               " name the buffer
    7              0.000042    if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST
                                " Got enew buffer; transform into a NetrwTreeListing
                            "    call Decho("(NetrwGetBuffer) --transform enew buffer#".bufnr("%")." into a NetrwTreeListing --")
                                if !exists("s:netrw_treelistnum")
                                 let s:netrw_treelistnum= 1
                                else
                                 let s:netrw_treelistnum= s:netrw_treelistnum + 1
                                endif
                                let w:netrw_treebufnr= bufnr("%")
                            "    call Decho("(NetrwGetBuffer)   exe sil! keepalt file NetrwTreeListing ".fnameescape(s:netrw_treelistnum))
                                exe 'sil! keepalt file NetrwTreeListing\ '.fnameescape(s:netrw_treelistnum)
                                set bt=nofile noswf
                                nnoremap <silent> <buffer> [	:sil call <SID>TreeListMove('[')<cr>
                                nnoremap <silent> <buffer> ]	:sil call <SID>TreeListMove(']')<cr>
                                nnoremap <silent> <buffer> [[       :sil call <SID>TreeListMove('[')<cr>
                                nnoremap <silent> <buffer> ]]       :sil call <SID>TreeListMove(']')<cr>
                            "    call Decho("(NetrwGetBuffer)   tree listing#".s:netrw_treelistnum." bufnr=".w:netrw_treebufnr)
                               else
                            "    let v:errmsg= "" " Decho
    7              0.000070     let escdirname= fnameescape(dirname)
                            "    call Decho("(NetrwGetBuffer)   errmsg<".v:errmsg."> bufnr(escdirname<".escdirname.">)=".bufnr(escdirname)." bufname()<".bufname(bufnr(escdirname)).">")
                            "    call Decho('  exe sil! keepalt file '.escdirname)
                            "    let v:errmsg= "" " Decho
    7   0.001787   0.000779     exe 'sil! keepalt file '.escdirname
                            "    call Decho("(NetrwGetBuffer)   errmsg<".v:errmsg."> bufnr(".escdirname.")=".bufnr(escdirname)."<".bufname(bufnr(escdirname)).">")
    7              0.000008    endif
                            "   call Decho("(NetrwGetBuffer)   named enew buffer#".bufnr("%")."<".bufname("%").">")
                            
    7              0.000007   else " Re-use the buffer
                            "   call Decho("(NetrwGetBuffer) --re-use buffer#".bufnum." (bufnum#".bufnum.">=0 AND bufexists(".bufnum.")=".bufexists(bufnum)."!=0)")
    5              0.000030    let eikeep= &ei
    5              0.000030    set ei=all
    5              0.000086    if getline(2) =~ '^" Netrw Directory Listing'
                            "    call Decho("(NetrwGetBuffer)   getline(2)<".getline(2).'> matches "Netrw Directory Listing" : using keepalt b '.bufnum)
    4              0.000094     exe "sil! keepalt b ".bufnum
    4              0.000005    else
                            "    call Decho("(NetrwGetBuffer)   getline(2)<".getline(2).'> does not match "Netrw Directory Listing" : using b '.bufnum)
    1              0.000006     exe "sil! keepalt b ".bufnum
    1              0.000000    endif
    5              0.000017    if bufname("%") == '.'
                            "    call Decho("(NetrwGetBuffer) exe sil! keepalt file ".fnameescape(getcwd()))
    1              0.000135     exe "sil! keepalt file ".fnameescape(getcwd())
    1              0.000001    endif
    5              0.000026    let &ei= eikeep
    5              0.000015    if line("$") <= 1
    1   0.000298   0.000011     keepj call s:NetrwListSettings(a:islocal)
                            "    call Dret("s:NetrwGetBuffer 0<buffer empty> : re-using buffer#".bufnr("%").", but its empty, so refresh it")
    1              0.000001     return 0
                               elseif g:netrw_fastbrowse == 0 || (a:islocal && g:netrw_fastbrowse == 1)
    4   0.001620   0.000034     keepj call s:NetrwListSettings(a:islocal)
    4              0.001054     sil keepj %d
                            "    call Dret("s:NetrwGetBuffer 0<cleared buffer> : re-using buffer#".bufnr("%").", but refreshing due to g:netrw_fastbrowse=".g:netrw_fastbrowse)
    4              0.000011     return 0
                               elseif exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST
                            "    call Decho("(NetrwGetBuffer) --re-use tree listing--")
                            "    call Decho("(NetrwGetBuffer)   clear buffer<".expand("%")."> with :%d")
                                sil keepj %d
                                keepj call s:NetrwListSettings(a:islocal)
                            "    call Dret("s:NetrwGetBuffer 0<cleared buffer> : re-using buffer#".bufnr("%").", but treelist mode always needs a refresh")
                                return 0
                               else
                            "    call Dret("s:NetrwGetBuffer 1<buffer not cleared> : buf#".bufnr("%"))
                                return 1
                               endif
                              endif
                            
                              " do netrw settings: make this buffer not-a-file, modifiable, not line-numbered, etc {{{3
                              "     fastbrowse  Local  Remote   Hiding a buffer implies it may be re-used (fast)
                              "  slow   0         D      D      Deleting a buffer implies it will not be re-used (slow)
                              "  med    1         D      H
                              "  fast   2         H      H
                            "  call Decho("(NetrwGetBuffer) --do netrw settings: make this buffer#".bufnr("%")." not-a-file, modifiable, not line-numbered, etc--")
    7              0.000026   let fname= expand("%")
    7   0.002769   0.000048   keepj call s:NetrwListSettings(a:islocal)
                            "  call Decho("(NetrwGetBuffer) exe sil! keepalt file ".fnameescape(fname))
    7   0.002537   0.000726   exe "sil! keepj keepalt file ".fnameescape(fname)
                            
                              " delete all lines from buffer {{{3
                            "  call Decho("(NetrwGetBuffer) --delete all lines from buffer--")
                            "  call Decho("(NetrwGetBuffer)   clear buffer<".expand("%")."> with :%d")
    7              0.000018   sil! keepalt keepj %d
                            
                            "  call Dret("s:NetrwGetBuffer 0<cleared buffer> : tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> modified=".&modified." modifiable=".&modifiable." readonly=".&readonly)
    7              0.000009   return 0

FUNCTION  42()
Called 20 times
Total time:   0.000103
 Self time:   0.000103

count  total (s)   self (s)
   20              0.000089     return exists('b:syntastic_echo_current_error') ? b:syntastic_echo_current_error : g:syntastic_echo_current_error

FUNCTION  43()
Called 10 times
Total time:   0.000246
 Self time:   0.000160

count  total (s)   self (s)
   10   0.000145   0.000059     if self.enabled() && a:loclist.hasErrorsOrWarningsToDisplay()
                                    call syntastic#log#debug(g:SyntasticDebugNotifications, 'cursor: refresh')
                                    let b:syntastic_messages = copy(a:loclist.messages(bufnr('')))
                                    let b:oldLine = -1
                                    autocmd! syntastic CursorMoved
                                    autocmd syntastic CursorMoved * call g:SyntasticRefreshCursor()
                                endif

FUNCTION  46()
Called 20 times
Total time:   0.000139
 Self time:   0.000139

count  total (s)   self (s)
   20              0.000129     return s:has_highlighting && (exists('b:syntastic_enable_highlighting') ? b:syntastic_enable_highlighting : g:syntastic_enable_highlighting)

FUNCTION  48()
Called 10 times
Total time:   0.000277
 Self time:   0.000186

count  total (s)   self (s)
   10              0.000017     if s:has_highlighting
   10   0.000142   0.000051         call syntastic#log#debug(g:SyntasticDebugNotifications, 'highlighting: reset')
   10              0.000030         for match in getmatches()
                                        if stridx(match['group'], 'Syntastic') == 0
                                            call matchdelete(match['id'])
                                        endif
                                    endfor
   10              0.000005     endif

FUNCTION  49()
Called 10 times
Total time:   0.000405
 Self time:   0.000405

count  total (s)   self (s)
   10              0.000132     let newObj = copy(self)
   10              0.000033     let newObj._quietWarnings = g:syntastic_quiet_warnings
                            
   10              0.000050     let llist = filter(copy(a:rawLoclist), 'v:val["valid"] == 1')
                            
   10              0.000019     for e in llist
                                    if empty(e['type'])
                                        let e['type'] = 'E'
                                    endif
                                endfor
                            
   10              0.000022     let newObj._rawLoclist = llist
   10              0.000023     let newObj._hasErrorsOrWarningsToDisplay = -1
                            
   10              0.000019     let newObj._name = ''
                            
   10              0.000011     return newObj

FUNCTION  <SNR>46_diff_window_count()
Called 21 times
Total time:   0.000459
 Self time:   0.000459

count  total (s)   self (s)
   21              0.000050   let c = 0
   42              0.000130   for nr in range(1,winnr('$'))
   21              0.000103     let c += getwinvar(nr,'&diff')
   21              0.000021   endfor
   21              0.000026   return c

FUNCTION  neobundle#util#uniq()
Called 15 times
Total time:   0.000985
 Self time:   0.000985

count  total (s)   self (s)
   15              0.000064   let list = a:0 ? map(copy(a:list), printf('[v:val, %s]', a:1)) : copy(a:list)
   15              0.000018   let i = 0
   15              0.000020   let seen = {}
   27              0.000046   while i < len(list)
   12              0.000467     let key = string(a:0 ? list[i][1] : list[i])
   12              0.000049     if has_key(seen, key)
                                  call remove(list, i)
                                else
   12              0.000067       let seen[key] = 1
   12              0.000012       let i += 1
   12              0.000008     endif
   12              0.000008   endwhile
   15              0.000028   return a:0 ? map(list, 'v:val[0]') : list

FUNCTION  <SNR>139_NetrwTreeListing()
Called 12 times
Total time:   0.000515
 Self time:   0.000515

count  total (s)   self (s)
   12              0.000029   if w:netrw_liststyle == s:TREELIST
                            "   call Dfunc("NetrwTreeListing() bufname<".expand("%").">")
                            "   call Decho("curdir<".a:dirname.">")
                            "   call Decho("win#".winnr().": w:netrw_treetop ".(exists("w:netrw_treetop")? "exists" : "doesn't exit")." w:netrw_treedict ".(exists("w:netrw_treedict")? "exists" : "doesn't exit"))
                            
                               " update the treetop
                            "   call Decho("update the treetop")
                               if !exists("w:netrw_treetop")
                                let w:netrw_treetop= a:dirname
                            "    call Decho("w:netrw_treetop<".w:netrw_treetop."> (reusing)")
                               elseif (w:netrw_treetop =~ ('^'.a:dirname) && s:Strlen(a:dirname) < s:Strlen(w:netrw_treetop)) || a:dirname !~ ('^'.w:netrw_treetop)
                                let w:netrw_treetop= a:dirname
                            "    call Decho("w:netrw_treetop<".w:netrw_treetop."> (went up)")
                               endif
                            
                               " insure that we have at least an empty treedict
                               if !exists("w:netrw_treedict")
                                let w:netrw_treedict= {}
                               endif
                            
                               " update the directory listing for the current directory
                            "   call Decho("updating dictionary with ".a:dirname.":[..directory listing..]")
                            "   call Decho("bannercnt=".w:netrw_bannercnt." line($)=".line("$"))
                               exe "sil! keepj ".w:netrw_bannercnt.',$g@^\.\.\=/$@d'
                               let w:netrw_treedict[a:dirname]= getline(w:netrw_bannercnt,line("$"))
                            "   call Decho("w:treedict[".a:dirname."]= ".string(w:netrw_treedict[a:dirname]))
                               exe "sil! keepj ".w:netrw_bannercnt.",$d"
                            
                               " if past banner, record word
                               if exists("w:netrw_bannercnt") && line(".") > w:netrw_bannercnt
                                let fname= expand("<cword>")
                               else
                                let fname= ""
                               endif
                            "   call Decho("fname<".fname.">")
                            
                               " display from treetop on down
                               keepj call s:NetrwTreeDisplay(w:netrw_treetop,"")
                            
                            "   call Dret("NetrwTreeListing : bufname<".expand("%").">")
                               return
                              endif

FUNCTION  50()
Called 30 times
Total time:   0.000780
 Self time:   0.000375

count  total (s)   self (s)
   30              0.000129     if !exists("b:syntastic_loclist")
   10   0.000477   0.000072         let b:syntastic_loclist = g:SyntasticLoclist.New([])
   10              0.000007     endif
   30              0.000046     return b:syntastic_loclist

FUNCTION  53()
Called 30 times
Total time:   0.000169
 Self time:   0.000169

count  total (s)   self (s)
   30              0.000146     return copy(self._quietWarnings ? self.errors() : self._rawLoclist)

FUNCTION  56()
Called 20 times
Total time:   0.000067
 Self time:   0.000067

count  total (s)   self (s)
   20              0.000053     return len(self._rawLoclist)

FUNCTION  <SNR>63_savetofile()
Called 2 times
Total time:   0.000777
 Self time:   0.000019

count  total (s)   self (s)
    2   0.000776   0.000018 	cal ctrlp#utils#writecache(a:mrufs, s:cadir, s:cafile)

FUNCTION  <SNR>136_wrap_name()
Called 66 times
Total time:   0.001140
 Self time:   0.001140

count  total (s)   self (s)
   66              0.000262   let _ = s:buf_nr_show ? printf(s:buf_nr_format, a:bufnr) : ''
   66              0.000192   let _ .= a:buffer_name
   66              0.000320   if getbufvar(a:bufnr, '&modified') == 1
                                let _ .= s:buf_modified_symbol
                              endif
   66              0.000075   return _

FUNCTION  <SNR>46_buffer_spec()
Called 74 times
Total time:   0.002028
 Self time:   0.001301

count  total (s)   self (s)
   74              0.000277     let bufname = bufname(self['#'])
   74   0.001697   0.000970     return s:shellslash(bufname == '' ? '' : fnamemodify(bufname,':p'))

FUNCTION  <SNR>105_check_in_path()
Called 20 times
Total time:   0.002671
 Self time:   0.002671

count  total (s)   self (s)
   20              0.000078   if !exists('b:airline_branch_path')
   20              0.000114     let root = get(b:, 'git_dir', get(b:, 'mercurial_dir', ''))
   20              0.000892     let bufferpath = resolve(fnamemodify(expand('%'), ':p:h'))
                            
   20              0.000135     if !filereadable(root) "not a file
                                  " if .git is a directory, it's the old submodule format
   20              0.000216       if match(root, '\.git$') >= 0
   20              0.000738         let root = expand(fnamemodify(root, ':h'))
   20              0.000029       else
                                    " else it's the newer format, and we need to guesstimate
                                    let pattern = '\.git\(\\\|\/\)modules\(\\\|\/\)'
                                    if match(root, pattern) >= 0
                                      let root = substitute(root, pattern, '', '')
                                    endif
                                endif
                            
   20              0.000106     let b:airline_file_in_root = stridx(bufferpath, root) > -1
   20              0.000015   endif
   20              0.000042   return b:airline_file_in_root

FUNCTION  neobundle#util#join_rtp()
Called 6 times
Total time:   0.000135
 Self time:   0.000135

count  total (s)   self (s)
    6              0.000133   return (a:runtimepath !~ '\\' && a:rtp !~ ',') ? join(a:list, ',') : join(map(copy(a:list), 's:escape(v:val)'), ',')

FUNCTION  neobundle#autoload#filetype()
Called 35 times
Total time:   0.158536
 Self time:   0.004144

count  total (s)   self (s)
   35   0.006794   0.001934   let bundles = filter(neobundle#config#get_autoload_bundles(), "has_key(v:val.autoload, 'filetypes')")
   70   0.000837   0.000305   for filetype in neobundle#util#get_filetypes()
   35   0.065548   0.064236     call neobundle#config#source_bundles(filter(copy(bundles)," index(neobundle#util#convert2list(     v:val.autoload.filetypes), filetype) >= 0"))
   35              0.000047   endfor

FUNCTION  60()
Called 60 times
Total time:   0.000341
 Self time:   0.000341

count  total (s)   self (s)
   60              0.000107     if self._hasErrorsOrWarningsToDisplay >= 0
   50              0.000071         return self._hasErrorsOrWarningsToDisplay
                                endif
   10              0.000050     let self._hasErrorsOrWarningsToDisplay = empty(self._rawLoclist) ? 0 : (!self._quietWarnings || len(self.errors()))
   10              0.000015     return self._hasErrorsOrWarningsToDisplay

FUNCTION  <SNR>82_BufReadPostHook()
Called 2 times
Total time:   0.000023
 Self time:   0.000023

count  total (s)   self (s)
    2              0.000004     if g:syntastic_check_on_open
                                    call syntastic#log#debug(g:SyntasticDebugAutocommands, 'autocmd: BufReadPost, buffer ' . bufnr("") . ' = ' . string(bufname(str2nr(bufnr("")))))
                                    call s:UpdateErrors(1)
                                endif

FUNCTION  <SNR>82_BufWinEnterHook()
Called 10 times
Total time:   0.006425
 Self time:   0.000332

count  total (s)   self (s)
   10   0.000264   0.000161     call syntastic#log#debug(g:SyntasticDebugAutocommands, 'autocmd: BufWinEnter, buffer ' . bufnr("") . ' = ' . string(bufname(str2nr(bufnr("")))) . ', &buftype = ' . string(&buftype))
   10              0.000023     if empty(&buftype)
   10   0.000613   0.000060         let loclist = g:SyntasticLoclist.current()
   10   0.005503   0.000066         call s:notifiers.refresh(loclist)
   10              0.000006     endif

FUNCTION  airline#section#create()
Called 33 times
Total time:   0.006426
 Self time:   0.000264

count  total (s)   self (s)
   33   0.006409   0.000247   return s:create(a:parts, 0)

FUNCTION  <SNR>115_add_section()
Called 183 times
Total time:   0.083507
 Self time:   0.004745

count  total (s)   self (s)
                                " i have no idea why the warning section needs special treatment, but it's
                                " needed to prevent separators from showing up
  183              0.000411     if a:key == 'warning'
   12   0.000101   0.000053       call a:builder.add_raw('%(')
   12              0.000010     endif
  183   0.081048   0.002373     call a:builder.add_section('airline_'.a:key, s:get_section(a:context.winnr, a:key))
  183              0.000424     if a:key == 'warning'
   12   0.000097   0.000058       call a:builder.add_raw('%)')
   12              0.000008     endif

FUNCTION  airline#extensions#default#apply()
Called 45 times
Total time:   0.091267
 Self time:   0.002206

count  total (s)   self (s)
   45              0.000123   let winnr = a:context.winnr
   45              0.000108   let active = a:context.active
                            
   45   0.000510   0.000285   if airline#util#getwinvar(winnr, 'airline_render_left', active || (!active && !g:airline_inactive_collapse))
   45   0.060329   0.000332     call <sid>build_sections(a:builder, a:context, s:layout[0])
   45              0.000034   else
                                call a:builder.add_section('airline_c'.(a:context.bufnr), ' %f%m ')
                              endif
                            
   45   0.002535   0.000468   call a:builder.split(s:get_section(winnr, 'gutter', '', ''))
                            
   45   0.000384   0.000212   if airline#util#getwinvar(winnr, 'airline_render_right', 1)
   12   0.026679   0.000079     call <sid>build_sections(a:builder, a:context, s:layout[1])
   12              0.000008   endif
                            
   45              0.000035   return 1

FUNCTION  <SNR>139_Strlen()
Called 12 times
Total time:   0.000669
 Self time:   0.000669

count  total (s)   self (s)
                            "  call Dfunc("s:Strlen(x<".a:x.">")
   12              0.000024   if g:netrw_xstrlen == 1
                               " number of codepoints (Latin a + combining circumflex is two codepoints)
                               " (comment from TM, solution from NW)
   12              0.000315    let ret= strlen(substitute(a:x,'.','c','g'))
                            
   12              0.000019   elseif g:netrw_xstrlen == 2
                               " number of spacing codepoints (Latin a + combining circumflex is one spacing 
                               " codepoint; a hard tab is one; wide and narrow CJK are one each; etc.)
                               " (comment from TM, solution from TM)
                               let ret=strlen(substitute(a:x, '.\Z', 'x', 'g')) 
                            
                              elseif g:netrw_xstrlen == 3
                               " virtual length (counting, for instance, tabs as anything between 1 and 
                               " 'tabstop', wide CJK as 2 rather than 1, Arabic alif as zero when immediately 
                               " preceded by lam, one otherwise, etc.)
                               " (comment from TM, solution from me)
                               let modkeep= &mod
                               exe "keepj norm! o\<esc>"
                               call setline(line("."),a:x)
                               let ret= virtcol("$") - 1
                               keepj d
                               keepj norm! k
                               let &mod= modkeep
                            
                              else
                               " at least give a decent default
                               let ret= strlen(a:x)
                              endif
                            "  call Dret("s:Strlen ".ret)
   12              0.000015   return ret

FUNCTION  <SNR>139_NetrwBookmarkMenu()
Called 14 times
Total time:   0.007836
 Self time:   0.007836

count  total (s)   self (s)
   14              0.000051   if !exists("s:netrw_menucnt")
                               return
                              endif
                            "  call Dfunc("NetrwBookmarkMenu()  histcnt=".g:netrw_dirhist_cnt." menucnt=".s:netrw_menucnt)
                            
                              " the following test assures that gvim is running, has menus available, and has menus enabled.
   14              0.000194   if has("gui") && has("menu") && has("gui_running") && &go =~# 'm' && g:netrw_menu
   14              0.000048    if exists("g:NetrwTopLvlMenu")
                            "    call Decho("removing ".g:NetrwTopLvlMenu."Bookmarks menu item(s)")
   14              0.000223     exe 'sil! unmenu '.g:NetrwTopLvlMenu.'Bookmarks'
   14              0.000147     exe 'sil! unmenu '.g:NetrwTopLvlMenu.'Bookmarks\ and\ History.Bookmark\ Delete'
   14              0.000015    endif
   14              0.000048    if !exists("s:netrw_initbookhist")
                                call s:NetrwBookHistRead()
                               endif
                            
                               " show bookmarked places
   14              0.000056    if exists("g:netrw_bookmarklist") && g:netrw_bookmarklist != [] && g:netrw_dirhistmax > 0
                                let cnt= 1
                                for bmd in g:netrw_bookmarklist
                                 let ebmd= escape(bmd,g:netrw_menu_escape)
                            "     call Decho('sil! menu '.g:NetrwMenuPriority.".2.".cnt." ".g:NetrwTopLvlMenu.'Bookmark.'.ebmd.'	:e '.bmd)
                            
                                 " show bookmarks for goto menu
                                 exe 'sil! menu '.g:NetrwMenuPriority.".2.".cnt." ".g:NetrwTopLvlMenu.'Bookmarks.'.ebmd.'	:e '.bmd."\<cr>"
                            
                                 " show bookmarks for deletion menu
                                 exe 'sil! menu '.g:NetrwMenuPriority.".8.2.".cnt." ".g:NetrwTopLvlMenu.'Bookmarks\ and\ History.Bookmark\ Delete.'.ebmd.'	'.cnt."mB"
                                 let cnt= cnt + 1
                                endfor
                            
                               endif
                            
                               " show directory browsing history
   14              0.000023    if g:netrw_dirhistmax > 0
   14              0.000038     let cnt     = g:netrw_dirhist_cnt
   14              0.000022     let first   = 1
   14              0.000021     let histcnt = 0
  154              0.000264     while ( first || cnt != g:netrw_dirhist_cnt )
  140              0.000292      let histcnt  = histcnt + 1
  140              0.000318      let priority = g:netrw_dirhist_cnt + histcnt
  140              0.000604      if exists("g:netrw_dirhist_{cnt}")
   93              0.000610       let histdir= escape(g:netrw_dirhist_{cnt},g:netrw_menu_escape)
                            "     call Decho('sil! menu '.g:NetrwMenuPriority.".3.".priority." ".g:NetrwTopLvlMenu.'History.'.histdir.'	:e '.histdir)
   93              0.002508       exe 'sil! menu '.g:NetrwMenuPriority.".3.".priority." ".g:NetrwTopLvlMenu.'History.'.histdir.'	:e '.histdir."\<cr>"
   93              0.000077      endif
  140              0.000202      let first = 0
  140              0.000355      let cnt   = ( cnt - 1 ) % g:netrw_dirhistmax
  140              0.000192      if cnt < 0
   14              0.000030       let cnt= cnt + g:netrw_dirhistmax
   14              0.000010      endif
  140              0.000091     endwhile
   14              0.000008    endif
                            
   14              0.000005   endif
                            "  call Dret("NetrwBookmarkMenu")

FUNCTION  <SNR>109_wrap_accent()
Called 33 times
Total time:   0.000688
 Self time:   0.000539

count  total (s)   self (s)
   33              0.000118   if exists('a:part.accent')
   33   0.000348   0.000199     call airline#highlighter#add_accent(a:part.accent)
   33              0.000170     return '%#__accent_'.(a:part.accent).'#'.a:value.'%#__restore__#'
                              endif
                              return a:value

FUNCTION  airline#util#wrap()
Called 279 times
Total time:   0.002084
 Self time:   0.002084

count  total (s)   self (s)
  279              0.000894   if a:minwidth > 0 && winwidth(0) < a:minwidth
                                return ''
                              endif
  279              0.000366   return a:text

FUNCTION  <SNR>139_NetrwOptionSave()
Called 31 times
Total time:   0.009069
 Self time:   0.009069

count  total (s)   self (s)
                            "  call Dfunc("s:NetrwOptionSave(vt<".a:vt.">) win#".winnr()." buf#".bufnr("%")."<".bufname(bufnr("%")).">"." winnr($)=".winnr("$")." mod=".&mod." ma=".&ma)
                            "  call Decho(a:vt."netrw_optionsave".(exists("{a:vt}netrw_optionsave")? ("=".{a:vt}netrw_optionsave) : " doesn't exist"))
                            
   31              0.000187   if !exists("{a:vt}netrw_optionsave")
   31              0.000187    let {a:vt}netrw_optionsave= 1
   31              0.000028   else
                            "   call Dret("s:NetrwOptionSave : options already saved")
                               return
                              endif
                            "  call Decho("fo=".&fo.(exists("+acd")? " acd=".&acd : " acd doesn't exist")." diff=".&l:diff)
                            
                              " Save current settings and current directory
                            "  call Decho("saving current settings and current directory")
   31              0.000099   let s:yykeep          = @@
   31              0.000453   if exists("&l:acd")|let {a:vt}netrw_acdkeep  = &l:acd|endif
   31              0.000196   let {a:vt}netrw_aikeep    = &l:ai
   31              0.000190   let {a:vt}netrw_awkeep    = &l:aw
   31              0.000189   let {a:vt}netrw_bhkeep    = &l:bh
   31              0.000175   let {a:vt}netrw_blkeep    = &l:bl
   31              0.000186   let {a:vt}netrw_btkeep    = &l:bt
   31              0.000129   let {a:vt}netrw_bombkeep  = &l:bomb
   31              0.000112   let {a:vt}netrw_cedit     = &cedit
   31              0.000178   let {a:vt}netrw_cikeep    = &l:ci
   31              0.000181   let {a:vt}netrw_cinkeep   = &l:cin
   31              0.000190   let {a:vt}netrw_cinokeep  = &l:cino
   31              0.000192   let {a:vt}netrw_comkeep   = &l:com
   31              0.000213   let {a:vt}netrw_cpokeep   = &l:cpo
   31              0.000113   let {a:vt}netrw_diffkeep  = &l:diff
   31              0.000175   let {a:vt}netrw_fenkeep   = &l:fen
   31              0.000167   let {a:vt}netrw_ffkeep    = &l:ff
   31              0.000198   let {a:vt}netrw_fokeep    = &l:fo           " formatoptions
   31              0.000160   let {a:vt}netrw_gdkeep    = &l:gd           " gdefault
   31              0.000115   let {a:vt}netrw_hidkeep   = &l:hidden
   31              0.000171   let {a:vt}netrw_imkeep    = &l:im
   31              0.000174   let {a:vt}netrw_iskkeep   = &l:isk
   31              0.000159   let {a:vt}netrw_lskeep    = &l:ls
   31              0.000165   let {a:vt}netrw_makeep    = &l:ma
   31              0.000134   let {a:vt}netrw_magickeep = &l:magic
   31              0.000199   let {a:vt}netrw_modkeep   = &l:mod
   31              0.000148   let {a:vt}netrw_nukeep    = &l:nu
   31              0.000107   let {a:vt}netrw_repkeep   = &l:report
   31              0.000145   let {a:vt}netrw_rokeep    = &l:ro
   31              0.000147   let {a:vt}netrw_selkeep   = &l:sel
   31              0.000131   let {a:vt}netrw_spellkeep = &l:spell
   31              0.000139   let {a:vt}netrw_tskeep    = &l:ts
   31              0.000140   let {a:vt}netrw_twkeep    = &l:tw           " textwidth
   31              0.000138   let {a:vt}netrw_wigkeep   = &l:wig          " wildignore
   31              0.000120   let {a:vt}netrw_wrapkeep  = &l:wrap
   31              0.000122   let {a:vt}netrw_writekeep = &l:write
   31              0.000112   if g:netrw_use_noswf && has("win32") && !has("win95")
                               let {a:vt}netrw_swfkeep   = &l:swf
                              endif
                            
                              " save a few selected netrw-related variables
                            "  call Decho("saving a few selected netrw-related variables")
   31              0.000047   if g:netrw_keepdir
   31              0.001090    let {a:vt}netrw_dirkeep  = getcwd()
   31              0.000045   endif
   31              0.000177   if has("win32") && !has("win95")
                               let {a:vt}netrw_swfkeep  = &l:swf          " swapfile
                              endif
   31              0.000302   if &go =~# 'a' | sil! let {a:vt}netrw_regstar = @* | endif
   31              0.000151   sil! let {a:vt}netrw_regslash= @/
                            
                            "  call Dret("s:NetrwOptionSave : tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")." modified=".&modified." modifiable=".&modifiable." readonly=".&readonly)

FUNCTION  airline#parts#get()
Called 33 times
Total time:   0.000168
 Self time:   0.000168

count  total (s)   self (s)
   33              0.000149   return get(s:parts, a:key, {})

FUNCTION  86()
Called 10 times
Total time:   0.005437
 Self time:   0.001597

count  total (s)   self (s)
   10   0.000148   0.000055     call syntastic#log#debug(g:SyntasticDebugNotifications, 'notifiers: refresh')
   60              0.000095     for type in self._enabled_types
   50              0.000514         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
   50   0.000739   0.000456         if !has_key(g:{class}, 'enabled') || self._notifier[type].enabled()
   50   0.003747   0.000283             call self._notifier[type].refresh(a:loclist)
   50              0.000037         endif
   50              0.000026     endfor

FUNCTION  <SNR>46_define_commands()
Called 24 times
Total time:   0.006823
 Self time:   0.006823

count  total (s)   self (s)
  576              0.000739   for command in s:commands
  552              0.005434     exe 'command! -buffer '.command
  552              0.000397   endfor

FUNCTION  sy#start()
Called 2 times
Total time:   2.275659
 Self time:   0.322073

count  total (s)   self (s)
    2              0.000048   if &diff || !filereadable(a:path) || (exists('g:signify_skip_filetype') && has_key(g:signify_skip_filetype, &ft)) || (exists('g:signify_skip_filename') && has_key(g:signify_skip_filename, a:path))
                                return
                              endif
                            
                              " new buffer.. add to list of registered files
    2              0.000006   if !has_key(g:sy, a:path)
    2              0.000006     if get(g:, 'signify_disable_by_default')
                                  " register file as inactive
                                  let g:sy[a:path] = { 'active': 0, 'type': 'unknown', 'hunks': [], 'id_top': g:id_top, 'stats': [-1, -1, -1] }
                                  return
                                endif
                            
    2   0.078779   0.000083     let [ diff, type ] = sy#repo#detect(a:path)
    2              0.000009     if type == 'unknown'
                                  " register file as active with no found VCS
                                  let g:sy[a:path] = { 'active': 1, 'type': 'unknown', 'hunks': [], 'id_top': g:id_top, 'stats': [0, 0, 0] }
                                  return
                                endif
                            
                                " register file as active with found VCS
    2              0.000045     let g:sy[a:path] = { 'active': 1, 'type': type, 'hunks': [], 'id_top': g:id_top, 'stats': [0, 0, 0] }
                            
    2              0.000016     let dir = fnamemodify(a:path, ':h')
    2              0.000009     if !has_key(g:sy_cache, dir)
    2              0.000006       let g:sy_cache[dir] = type
    2              0.000001     endif
                            
    2              0.000031     if empty(diff)
                                  " no changes found
                                  return
                                endif
                            
                              " inactive buffer.. bail out
    2              0.000005   elseif !g:sy[a:path].active
                                return
                            
                              " retry detecting VCS
                              elseif g:sy[a:path].type == 'unknown'
                                let [ diff, type ] = sy#repo#detect(a:path)
                                if type == 'unknown'
                                  " no VCS found
                                  return
                                endif
                                let g:sy[a:path].type = type
                            
                              " update signs
                              else
                                let diff = sy#repo#get_diff_{g:sy[a:path].type}(a:path)[1]
                                if empty(diff)
                                  call sy#sign#remove_all(a:path)
                                  return
                                endif
                                let g:sy[a:path].id_top = g:id_top
                              endif
                            
    2              0.000006   if get(g:, 'signify_line_highlight')
                                  call sy#highlight#line_enable()
                              else
    2   0.000795   0.000063       call sy#highlight#line_disable()
    2              0.000002   endif
                            
    2              0.315084   execute 'sign place 99999 line=1 name=SignifyPlaceholder file='. a:path
    2   0.000622   0.000560   call sy#sign#remove_all(a:path)
                            
    2              0.000003   if !g:signify_sign_overwrite
    2   0.000387   0.000017     call sy#sign#get_others(a:path)
    2              0.000002   endif
                            
    2   1.873795   0.000069   call sy#repo#process_diff(a:path, diff)
    2              0.005858   sign unplace 99999
                            
    2              0.000012   let g:sy[a:path].id_top = (g:id_top - 1)

FUNCTION  sy#stop()
Called 18 times
Total time:   0.000114
 Self time:   0.000114

count  total (s)   self (s)
   18              0.000071   if !has_key(g:sy, a:path)
   18              0.000018     return
                              endif
                            
                              call sy#sign#remove_all(a:path)
                            
                              silent! nunmap <buffer> ]c
                              silent! nunmap <buffer> [c
                            
                              augroup signify
                                autocmd! * <buffer>
                              augroup END

FUNCTION  <SNR>39_invoke_funcrefs()
Called 45 times
Total time:   0.113000
 Self time:   0.001964

count  total (s)   self (s)
   45   0.001695   0.000257   let builder = airline#builder#new(a:context)
   45   0.109778   0.000536   let err = airline#util#exec_funcrefs(a:funcrefs + s:core_funcrefs, builder, a:context)
   45              0.000066   if err == 1
   45   0.000607   0.000251     let a:context.line = builder.build()
   45              0.000305     let s:contexts[a:context.winnr] = a:context
   45              0.000418     call setwinvar(a:context.winnr, '&statusline', '%!airline#statusline('.a:context.winnr.')')
   45              0.000044   endif

FUNCTION  airline#extensions#tabline#get()
Called 20 times
Total time:   0.038923
 Self time:   0.000378

count  total (s)   self (s)
   20              0.000130   if s:show_buffers && tabpagenr('$') == 1
   20   0.038755   0.000210     return s:get_buffers()
                              else
                                return s:get_tabs()
                              endif

FUNCTION  <SNR>31_LoadIndent()
Called 35 times
Total time:   0.015341
 Self time:   0.014552

count  total (s)   self (s)
   35              0.000151     if exists("b:undo_indent")
                                  exe b:undo_indent
                                  unlet! b:undo_indent b:did_indent
                                endif
   35              0.000147     let s = expand("<amatch>")
   35              0.000079     if s != ""
   35              0.000096       if exists("b:did_indent")
    1              0.000002 	unlet b:did_indent
    1              0.000001       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
   70              0.000291       for name in split(s, '\.')
   35   0.014064   0.013275 	exe 'runtime! indent/' . name . '.vim'
   35              0.000048       endfor
   35              0.000027     endif

FUNCTION  <SNR>46_shellslash()
Called 110 times
Total time:   0.001074
 Self time:   0.001074

count  total (s)   self (s)
  110              0.000403   if exists('+shellslash') && !&shellslash
                                return s:gsub(a:path,'\\','/')
                              else
  110              0.000141     return a:path
                              endif

FUNCTION  airline#extensions#apply_left_override()
Called 33 times
Total time:   0.007088
 Self time:   0.000662

count  total (s)   self (s)
   33              0.000117   let w:airline_section_a = a:section1
   33              0.000086   let w:airline_section_b = a:section2
   33   0.006669   0.000243   let w:airline_section_c = airline#section#create(['readonly'])
   33              0.000087   let w:airline_render_left = 1
   33              0.000081   let w:airline_render_right = 0

FUNCTION  airline#util#getwinvar()
Called 318 times
Total time:   0.001439
 Self time:   0.001439

count  total (s)   self (s)
  318              0.001252     return getwinvar(a:winnr, a:key, a:def)

FUNCTION  airline#extensions#whitespace#check()
Called 20 times
Total time:   0.006239
 Self time:   0.006239

count  total (s)   self (s)
   20              0.000069   if &readonly || !&modifiable || !s:enabled
                                return ''
                              endif
                            
   20              0.000081   if !exists('b:airline_whitespace_check')
    4              0.000010     let b:airline_whitespace_check = ''
    4              0.000018     let checks = get(g:, 'airline#extensions#whitespace#checks', s:default_checks)
                            
    4              0.000007     let trailing = 0
    4              0.000014     if index(checks, 'trailing') > -1
    4              0.004734       let trailing = search(' $', 'nw')
    4              0.000005     endif
                            
    4              0.000008     let mixed = 0
    4              0.000011     if index(checks, 'indent') > -1
    4              0.000385       let indents = [search('^ \{2,}', 'nb'), search('^ \{2,}', 'n'), search('^\t', 'nb'), search('^\t', 'n')]
    4              0.000019       let mixed = indents[0] != 0 && indents[1] != 0 && indents[2] != 0 && indents[3] != 0
    4              0.000003     endif
                            
    4              0.000008     if trailing != 0 || mixed
                                  let b:airline_whitespace_check = s:symbol
                                  if s:show_message
                                    if trailing != 0
                                      let b:airline_whitespace_check .= (g:airline_symbols.space).printf(s:trailing_format, trailing)
                                    endif
                                    if mixed
                                      let mixnr = indents[0] == indents[1] ? indents[0] : indents[2]
                                      let b:airline_whitespace_check .= (g:airline_symbols.space).printf(s:mixed_indent_format, mixnr)
                                    endif
                                  endif
                                endif
    4              0.000003   endif
   20              0.000041   return b:airline_whitespace_check

FUNCTION  <SNR>33_SynSet()
Called 35 times
Total time:   0.089321
 Self time:   0.043897

count  total (s)   self (s)
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
   35              0.000940   syn clear
   35              0.000127   if exists("b:current_syntax")
                                unlet b:current_syntax
                              endif
                            
   35              0.000125   let s = expand("<amatch>")
   35              0.000090   if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
                              elseif s == "OFF"
                                let s = ""
                              endif
                            
   35              0.000055   if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.
   70              0.000309     for name in split(s, '\.')
   35   0.086804   0.041380       exe "runtime! syntax/" . name . ".vim syntax/" . name . "/*.vim"
   35              0.000060     endfor
   35              0.000032   endif

FUNCTION  <SNR>110_exec_separator()
Called 182 times
Total time:   0.068050
 Self time:   0.007399

count  total (s)   self (s)
  182   0.026000   0.001231   let l:from = airline#themes#get_highlight(a:from.a:suffix)
  182   0.023948   0.001150   let l:to = airline#themes#get_highlight(a:to.a:suffix)
  182              0.000799   let group = a:from.'_to_'.a:to.a:suffix
  182              0.000270   if a:inverse
  114              0.000703     let colors = [ l:from[1], l:to[1], l:from[3], l:to[3] ]
  114              0.000097   else
   68              0.000417     let colors = [ l:to[1], l:from[1], l:to[3], l:from[3] ]
   68              0.000058   endif
  182              0.000603   let a:dict[group] = colors
  182   0.014157   0.001073   call airline#highlighter#exec(group, colors)

FUNCTION  neobundle#config#rtp_rm()
Called 6 times
Total time:   0.000243
 Self time:   0.000243

count  total (s)   self (s)
    6              0.000137   execute 'set rtp-='.fnameescape(a:bundle.rtp)
    6              0.000043   if isdirectory(a:bundle.rtp.'/after')
    2              0.000045     execute 'set rtp-='.fnameescape(a:bundle.rtp.'/after')
    2              0.000002   endif

FUNCTION  <SNR>99_sync_active_winnr()
Called 107 times
Total time:   0.001389
 Self time:   0.001389

count  total (s)   self (s)
  107              0.000842   if exists('#airline') && winnr() != s:active_winnr
                                call airline#update_statusline()
                              endif

FUNCTION  airline#extensions#tagbar#currenttag()
Called 20 times
Total time:   0.001174
 Self time:   0.000244

count  total (s)   self (s)
   20              0.000075   if get(w:, 'airline_active', 0)
   20   0.001074   0.000144     return tagbar#currenttag('%s', '', s:flags)
                              endif
                              return ''

FUNCTION  <SNR>28_BMHash()
Called 10 times
Total time:   0.000498
 Self time:   0.000498

count  total (s)   self (s)
                              " Make name all upper case, so that chars are between 32 and 96
   10              0.000138   let nm = substitute(a:name, ".*", '\U\0', "")
   10              0.000046   if has("ebcdic")
                                " HACK: Replace all non alphabetics with 'Z'
                                "       Just to make it work for now.
                                let nm = substitute(nm, "[^A-Z]", 'Z', "g")
                                let sp = char2nr('A') - 1
                              else
   10              0.000028     let sp = char2nr(' ')
   10              0.000008   endif
                              " convert first six chars into a number for sorting:
   10              0.000180   return (char2nr(nm[0]) - sp) * 0x800000 + (char2nr(nm[1]) - sp) * 0x20000 + (char2nr(nm[2]) - sp) * 0x1000 + (char2nr(nm[3]) - sp) * 0x80 + (char2nr(nm[4]) - sp) * 0x20 + (char2nr(nm[5]) - sp)

FUNCTION  AutoPairsInit()
Called 10 times
Total time:   0.006321
 Self time:   0.003265

count  total (s)   self (s)
   10              0.000030   let b:autopairs_loaded  = 1
   10              0.000021   let b:autopairs_enabled = 1
   10              0.000027   let b:AutoPairsClosedPairs = {}
                            
   10              0.000029   if !exists('b:AutoPairs')
   10              0.000028     let b:AutoPairs = g:AutoPairs
   10              0.000007   end
                            
                              " buffer level map pairs keys
   70              0.000224   for [open, close] in items(b:AutoPairs)
   60   0.002403   0.000306     call AutoPairsMap(open)
   60              0.000138     if open != close
   30   0.001098   0.000139       call AutoPairsMap(close)
   30              0.000023     end
   60              0.000216     let b:AutoPairsClosedPairs[close] = open
   60              0.000050   endfor
                            
                              " Still use <buffer> level mapping for <BS> <SPACE>
   10              0.000014   if g:AutoPairsMapBS
                                " Use <C-R> instead of <expr> for issue #14 sometimes press BS output strange words
   10              0.000149     execute 'inoremap <buffer> <silent> <BS> <C-R>=AutoPairsDelete()<CR>'
   10              0.000133     execute 'inoremap <buffer> <silent> <C-H> <C-R>=AutoPairsDelete()<CR>'
   10              0.000008   end
                            
   10              0.000014   if g:AutoPairsMapSpace
                                " Try to respect abbreviations on a <SPACE>
   10              0.000016     let do_abbrev = ""
   10              0.000033     if v:version == 703 && has("patch489") || v:version > 703
   10              0.000020       let do_abbrev = "<C-]>"
   10              0.000007     endif
   10              0.000159     execute 'inoremap <buffer> <silent> <SPACE> '.do_abbrev.'<C-R>=AutoPairsSpace()<CR>'
   10              0.000008   end
                            
   10              0.000024   if g:AutoPairsShortcutFastWrap != ''
   10              0.000159     execute 'inoremap <buffer> <silent> '.g:AutoPairsShortcutFastWrap.' <C-R>=AutoPairsFastWrap()<CR>'
   10              0.000007   end
                            
   10              0.000021   if g:AutoPairsShortcutBackInsert != ''
   10              0.000165     execute 'inoremap <buffer> <silent> '.g:AutoPairsShortcutBackInsert.' <C-R>=AutoPairsBackInsert()<CR>'
   10              0.000005   end
                            
   10              0.000020   if g:AutoPairsShortcutToggle != ''
                                " use <expr> to ensure showing the status when toggle
   10              0.000151     execute 'inoremap <buffer> <silent> <expr> '.g:AutoPairsShortcutToggle.' AutoPairsToggle()'
   10              0.000181     execute 'noremap <buffer> <silent> '.g:AutoPairsShortcutToggle.' :call AutoPairsToggle()<CR>'
   10              0.000007   end
                            
   10              0.000020   if g:AutoPairsShortcutJump != ''
   10              0.000169     execute 'inoremap <buffer> <silent> ' . g:AutoPairsShortcutJump. ' <ESC>:call AutoPairsJump()<CR>a'
   10              0.000163     execute 'noremap <buffer> <silent> ' . g:AutoPairsShortcutJump. ' :call AutoPairsJump()<CR>'
   10              0.000010   end
                            

FUNCTION  <SNR>142_updateConfig()
Called 1 time
Total time:   0.000108
 Self time:   0.000058

count  total (s)   self (s)
    1              0.000002   if empty(a:value)
                                return a:value
                              endif
                            
    1              0.000006   let config = deepcopy(a:value)
                            
    4              0.000006   for type in ['js', 'css', 'html']
    3              0.000007     if has_key(config, type)
    3   0.000068   0.000018       call s:treatConfig(config[type])
    3              0.000002     endif
    3              0.000000   endfor
                            
                              " Делаем копию объекта
    1              0.000002   let b:config_Beautifier = config
                            
    1              0.000001   return b:config_Beautifier

FUNCTION  sy#repo#get_diff_git()
Called 2 times
Total time:   0.078471
 Self time:   0.000980

count  total (s)   self (s)
    2              0.000009   let diffoptions = has_key(g:signify_diffoptions, 'git') ? g:signify_diffoptions.git : ''
    2   0.078281   0.000790   let diff = system('cd '. sy#util#escape(fnamemodify(a:path, ':h')) .' && git diff --no-color --no-ext-diff -U0 '. diffoptions .' -- '. sy#util#escape(a:path))
                            
    2              0.000162   return v:shell_error ? [0, ''] : [1, diff]

FUNCTION  airline#util#append()
Called 40 times
Total time:   0.000584
 Self time:   0.000584

count  total (s)   self (s)
   40              0.000114   if a:minwidth > 0 && winwidth(0) < a:minwidth
                                return ''
                              endif
   40              0.000199   let prefix = s:spc == "\ua0" ? s:spc : s:spc.s:spc
   40              0.000163   return empty(a:text) ? '' : prefix.g:airline_left_alt_sep.s:spc.a:text

FUNCTION  fugitive#extract_git_dir()
Called 18 times
Total time:   0.006779
 Self time:   0.003695

count  total (s)   self (s)
   18   0.000363   0.000185   if s:shellslash(a:path) =~# '^fugitive://.*//'
                                return matchstr(s:shellslash(a:path), '\C^fugitive://\zs.\{-\}\ze//')
                              endif
   18   0.000576   0.000407   let root = s:shellslash(simplify(fnamemodify(a:path, ':p:s?[\/]$??')))
   18              0.000035   let previous = ""
   65              0.000134   while root !=# previous
   55   0.000920   0.000361     let dir = s:sub(root, '[\/]$', '') . '/.git'
   55              0.000348     let type = getftype(dir)
   55   0.000469   0.000184     if type ==# 'dir' && fugitive#is_git_dir(dir)
    8              0.000012       return dir
                                elseif type ==# 'link' && fugitive#is_git_dir(dir)
                                  return resolve(dir)
                                elseif type !=# '' && filereadable(dir)
                                  let line = get(readfile(dir, '', 1), 0, '')
                                  if line =~# '^gitdir: \.' && fugitive#is_git_dir(root.'/'.line[8:-1])
                                    return simplify(root.'/'.line[8:-1])
                                  elseif line =~# '^gitdir: ' && fugitive#is_git_dir(line[8:-1])
                                    return line[8:-1]
                                  endif
                                elseif fugitive#is_git_dir(root)
                                  return root
                                endif
   47              0.000087     let previous = root
   47              0.000175     let root = fnamemodify(root, ':h')
   47              0.000044   endwhile
   10              0.000009   return ''

FUNCTION  <SNR>63_chop()
Called 2 times
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
    2              0.000016 	if len(a:mrufs) > {s:max} | cal remove(a:mrufs, {s:max}, -1) | en
    2              0.000003 	retu a:mrufs

FUNCTION  ctrlp#utils#mkdir()
Called 2 times
Total time:   0.000030
 Self time:   0.000030

count  total (s)   self (s)
    2              0.000018 	if exists('*mkdir') && !isdirectory(a:dir)
                            		sil! cal mkdir(a:dir, 'p')
                            	en
    2              0.000002 	retu a:dir

FUNCTION  <SNR>139_PerformListing()
Called 12 times
Total time:   0.287134
 Self time:   0.006334

count  total (s)   self (s)
                            "  call Dfunc("s:PerformListing(islocal=".a:islocal.") bufnr(%)=".bufnr("%")."<".bufname("%").">")
                            
                              " set up syntax highlighting {{{3
                            "  call Decho("(PerformListing) set up syntax highlighting")
   12              0.000055   if has("syntax")
   12              0.000042    if !exists("g:syntax_on") || !g:syntax_on
                            "    call Decho("(PerformListing) but g:syntax_on".(exists("g:syntax_on")? "=".g:syntax_on : "<doesn't exist>"))
                                setl ft=
                               elseif &ft != "netrw"
    8   0.062120   0.000056     setl ft=netrw
    8              0.000005    endif
   12              0.000009   endif
                            
   12   0.089343   0.000102   keepj call s:NetrwSafeOptions()
   12              0.000075   set noro ma
                            "  call Decho("(PerformListing) setl noro ma bh=".&bh)
                            
                            "  if exists("g:netrw_silent") && g:netrw_silent == 0 && &ch >= 1	" Decho
                            "   call Decho("(PerformListing) (netrw) Processing your browsing request...")
                            "  endif								" Decho
                            
                            "  call Decho('w:netrw_liststyle='.(exists("w:netrw_liststyle")? w:netrw_liststyle : 'n/a'))
   12              0.000067   if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST && exists("w:netrw_treedict")
                               " force a refresh for tree listings
                            "   call Decho("(PerformListing) force refresh for treelisting: clear buffer<".expand("%")."> with :%d")
                               sil! keepj %d
                              endif
                            
                              " save current directory on directory history list
   12   0.017457   0.000089   keepj call s:NetrwBookHistHandler(3,b:netrw_curdir)
                            
                              " Set up the banner {{{3
   12              0.000025   if g:netrw_banner
                            "   call Decho("(PerformListing) set up banner")
   12              0.000117    keepj call setline(1,'" ============================================================================')
   12              0.000129    keepj call setline(2,'" Netrw Directory Listing                                        (netrw '.g:loaded_netrw.')')
   12              0.000043    if exists("g:netrw_bannerbackslash") && g:netrw_bannerbackslash
                                keepj call setline(3,'"   '.substitute(b:netrw_curdir,'/','\\','g'))
                               else
   12              0.000063     keepj call setline(3,'"   '.b:netrw_curdir)
   12              0.000010    endif
   12              0.000026    let w:netrw_bannercnt= 3
   12              0.000063    keepj exe "sil! keepj ".w:netrw_bannercnt
   12              0.000008   else
                               keepj 1
                               let w:netrw_bannercnt= 1
                              endif
                            
   12              0.000026   let sortby= g:netrw_sort_by
   12              0.000085   if g:netrw_sort_direction =~ "^r"
                               let sortby= sortby." reversed"
                              endif
                            
                              " Sorted by... {{{3
   12              0.000013   if g:netrw_banner
                            "   call Decho("(PerformListing) handle specified sorting: g:netrw_sort_by<".g:netrw_sort_by.">")
   12              0.000061    if g:netrw_sort_by =~ "^n"
                            "   call Decho("(PerformListing) directories will be sorted by name")
                                " sorted by name
   12              0.000159     keepj put ='\"   Sorted by      '.sortby
   12              0.000094     keepj put ='\"   Sort sequence: '.g:netrw_sort_sequence
   12              0.000045     let w:netrw_bannercnt= w:netrw_bannercnt + 2
   12              0.000008    else
                            "   call Decho("(PerformListing) directories will be sorted by size or time")
                                " sorted by size or date
                                keepj put ='\"   Sorted by '.sortby
                                let w:netrw_bannercnt= w:netrw_bannercnt + 1
                               endif
   12              0.000046    exe "sil! keepj ".w:netrw_bannercnt
   12              0.000007   endif
                            
                              " show copy/move target, if any
   12              0.000014   if g:netrw_banner
   12              0.000038    if exists("s:netrwmftgt") && exists("s:netrwmftgt_islocal")
                            "    call Decho("(PerformListing) show copy/move target<".s:netrwmftgt.">")
                                keepj put =''
                                if s:netrwmftgt_islocal
                                 sil! keepj call setline(line("."),'"   Copy/Move Tgt: '.s:netrwmftgt.' (local)')
                                else
                                 sil! keepj call setline(line("."),'"   Copy/Move Tgt: '.s:netrwmftgt.' (remote)')
                                endif
                                let w:netrw_bannercnt= w:netrw_bannercnt + 1
                               else
                            "    call Decho("(PerformListing) s:netrwmftgt does not exist, don't make Copy/Move Tgt")
   12              0.000006    endif
   12              0.000042    exe "sil! keepj ".w:netrw_bannercnt
   12              0.000005   endif
                            
                              " Hiding...  -or-  Showing... {{{3
   12              0.000014   if g:netrw_banner
                            "   call Decho("(PerformListing) handle hiding/showing (g:netrw_hide=".g:netrw_list_hide." g:netrw_list_hide<".g:netrw_list_hide.">)")
   12              0.000028    if g:netrw_list_hide != "" && g:netrw_hide
                                if g:netrw_hide == 1
                                 keepj put ='\"   Hiding:        '.g:netrw_list_hide
                                else
                                 keepj put ='\"   Showing:       '.g:netrw_list_hide
                                endif
                                let w:netrw_bannercnt= w:netrw_bannercnt + 1
                               endif
   12              0.000042    exe "keepjumps ".w:netrw_bannercnt
   12              0.000095    keepj put ='\"   Quick Help: <F1>:help  -:go up dir  D:delete  R:rename  s:sort-by  x:exec'
   12              0.000089    keepj put ='\" ============================================================================'
   12              0.000040    let w:netrw_bannercnt= w:netrw_bannercnt + 2
   12              0.000011   endif
                            
                              " bannercnt should index the line just after the banner
   12              0.000013   if g:netrw_banner
   12              0.000031    let w:netrw_bannercnt= w:netrw_bannercnt + 1
   12              0.000045    exe "sil! keepj ".w:netrw_bannercnt
                            "   call Decho("(PerformListing) w:netrw_bannercnt=".w:netrw_bannercnt." (should index line just after banner) line($)=".line("$"))
   12              0.000008   endif
                            
                              " get list of files
                            "  call Decho("(PerformListing) Get list of files - islocal=".a:islocal)
   12              0.000016   if a:islocal
   12   0.047369   0.000142    keepj call s:LocalListing()
   12              0.000015   else " remote
                               keepj call s:NetrwRemoteListing()
                              endif
                            
                              " manipulate the directory listing (hide, sort) {{{3
   12              0.000039   if !exists("w:netrw_bannercnt")
                               let w:netrw_bannercnt= 0
                              endif
                            "  call Decho("(PerformListing) g:netrw_banner=".g:netrw_banner." w:netrw_bannercnt=".w:netrw_bannercnt." (banner complete)")
                            
   12              0.000041   if !g:netrw_banner || line("$") >= w:netrw_bannercnt
                            "   call Decho("(PerformListing) manipulate directory listing (hide)")
                            "   call Decho("(PerformListing) g:netrw_hide=".g:netrw_hide." g:netrw_list_hide<".g:netrw_list_hide.">")
   12              0.000030    if g:netrw_hide && g:netrw_list_hide != ""
                                keepj call s:NetrwListHide()
                               endif
   12              0.000033    if !g:netrw_banner || line("$") >= w:netrw_bannercnt
                            "    call Decho("(PerformListing) manipulate directory listing (sort) : g:netrw_sort_by<".g:netrw_sort_by.">")
                            
   12              0.000061     if g:netrw_sort_by =~ "^n"
                                 " sort by name
   12   0.048660   0.000091      keepj call s:NetrwSetSort()
                            
   12              0.000046      if !g:netrw_banner || w:netrw_bannercnt < line("$")
                            "      call Decho("(PerformListing) g:netrw_sort_direction=".g:netrw_sort_direction." (bannercnt=".w:netrw_bannercnt.")")
   12              0.000051       if g:netrw_sort_direction =~ 'n'
                                   " normal direction sorting
   12              0.000368        exe 'sil keepj '.w:netrw_bannercnt.',$sort'.' '.g:netrw_sort_options
   12              0.000011       else
                                   " reverse direction sorting
                                   exe 'sil keepj '.w:netrw_bannercnt.',$sort!'.' '.g:netrw_sort_options
                                  endif
   12              0.000006      endif
                                 " remove priority pattern prefix
                            "     call Decho("(PerformListing) remove priority pattern prefix")
   12              0.000692      exe 'sil! keepj '.w:netrw_bannercnt.',$s/^\d\{3}'.g:netrw_sepchr.'//e'
   12              0.000044      keepj call histdel("/",-1)
                            
   12              0.000013     elseif a:islocal
                                 if !g:netrw_banner || w:netrw_bannercnt < line("$")
                            "      call Decho("(PerformListing) g:netrw_sort_direction=".g:netrw_sort_direction)
                                  if g:netrw_sort_direction =~ 'n'
                            "       call Decho('exe sil keepjumps '.w:netrw_bannercnt.',$sort')
                                   exe 'sil! keepj '.w:netrw_bannercnt.',$sort'.' '.g:netrw_sort_options
                                  else
                            "       call Decho('exe sil keepjumps '.w:netrw_bannercnt.',$sort!')
                                   exe 'sil! keepj '.w:netrw_bannercnt.',$sort!'.' '.g:netrw_sort_options
                                  endif
                                 exe 'sil! keepj '.w:netrw_bannercnt.',$s/^\d\{-}\///e'
                                 keepj call histdel("/",-1)
                                 endif
                                endif
                            
   12              0.000014    elseif g:netrw_sort_direction =~ 'r'
                            "    call Decho('reverse the sorted listing')
                                if !g:netrw_banner || w:netrw_bannercnt < line('$')
                                 exe 'sil! keepj '.w:netrw_bannercnt.',$g/^/m '.w:netrw_bannercnt
                                 call histdel("/",-1)
                                endif
                               endif
   12              0.000009   endif
                            
                              " convert to wide/tree listing {{{3
                            "  call Decho("(PerformListing) modify display if wide/tree listing style")
   12   0.001398   0.000080   keepj call s:NetrwWideListing()
   12   0.000594   0.000079   keepj call s:NetrwTreeListing(b:netrw_curdir)
                            
   12              0.000066   if exists("w:netrw_bannercnt") && (line("$") > w:netrw_bannercnt || !g:netrw_banner)
                               " place cursor on the top-left corner of the file listing
                            "   call Decho("(PerformListing) place cursor on top-left corner of file listing")
   12              0.000057    exe 'sil! keepj '.w:netrw_bannercnt
   12              0.000147    sil! keepj norm! 0
   12              0.000012   endif
                            
                              " record previous current directory
   12              0.000039   let w:netrw_prvdir= b:netrw_curdir
                            "  call Decho("(PerformListing) record netrw_prvdir<".w:netrw_prvdir.">")
                            
                              " save certain window-oriented variables into buffer-oriented variables {{{3
   12   0.000637   0.000068   keepj call s:SetBufWinVars()
   12   0.013151   0.000079   keepj call s:NetrwOptionRestore("w:")
                            
                              " set display to netrw display settings
                            "  call Decho("(PerformListing) set display to netrw display settings (".g:netrw_bufsettings.")")
   12   0.001063   0.000206   exe "setl ".g:netrw_bufsettings
   12              0.000037   if g:netrw_liststyle == s:LONGLIST
                            "   call Decho("(PerformListing) exe setl ts=".(g:netrw_maxfilenamelen+1))
                               exe "setl ts=".(g:netrw_maxfilenamelen+1)
                              endif
   12              0.000031   if exists("s:treecurpos")
                            
                               keepj call netrw#NetrwRestorePosn(s:treecurpos)
                               unlet s:treecurpos
                              endif
                            
                            "  call Dret("s:PerformListing : curpos<".string(getpos(".")).">")

FUNCTION  BeautifierApplyConfig()
Called 1 time
Total time:   0.000860
 Self time:   0.000111

count  total (s)   self (s)
                            
                              " Получаем путь который нам передали
    1              0.000004   let l:filepath = get(a:000, 0)
                            
                              " Проходимся по дефолтным путям только если
                              " оказалось что нам не передали путь
                              "
                              " Если нам передали путь то не стоит его
                              " тут проверять на сушествование
    1              0.000003   if empty(l:filepath)
    1              0.000033     let l:filepath = get(filter(copy(s:paths_Editorconfig),'filereadable(v:val)'), 0)
    1              0.000001   endif
                            
    1              0.000009   if !filereadable(l:filepath)
                                " File doesn't exist then return '1'
                                call WarningMsg('Can not find global .editorconfig file!')
                                return 1
                              endif
                            
                            
    1              0.000024   let l:content = readfile(l:filepath)
                            
                              " Process .editorconfig file
    1   0.000655   0.000014   let opts = s:processingEditconfigFile(l:content)
                            
    1              0.000002   let g:config_Beautifier = opts
    1   0.000116   0.000008   call s:updateConfig(opts)
                            
                              " All Ok! return '0'
    1              0.000001   return 0

FUNCTION  neobundle#autoload#function()
Called 2 times
Total time:   0.000630
 Self time:   0.000393

count  total (s)   self (s)
    2              0.000010   let function = expand('<amatch>')
    2              0.000020   let function_prefix = get(split(function, '#'), 0, '') . '#'
                            
    2   0.000565   0.000345   let bundles = filter(neobundle#config#get_autoload_bundles(), "get(v:val.autoload, 'function_prefix', '').'#' ==# function_prefix ||  (has_key(v:val.autoload, 'functions') &&    index(neobundle#util#convert2list(     v:val.autoload.functions), function) >= 0)")
    2   0.000033   0.000016   call neobundle#config#source_bundles(bundles)

FUNCTION  <SNR>46_repo_head()
Called 20 times
Total time:   0.003342
 Self time:   0.000850

count  total (s)   self (s)
   20   0.002266   0.000190     let head = s:repo().head_ref()
                            
   20              0.000222     if head =~# '^ref: '
   20   0.000603   0.000187       let branch = s:sub(head,'^ref: %(refs/%(heads/|remotes/|tags/)=)=','')
   20              0.000040     elseif head =~# '^\x\{40\}$'
                                  " truncate hash to a:1 characters if we're in detached head mode
                                  let len = a:0 ? a:1 : 0
                                  let branch = len ? head[0:len-1] : ''
                                endif
                            
   20              0.000031     return branch

FUNCTION  <SNR>110_get_syn()
Called 728 times
Total time:   0.026415
 Self time:   0.026415

count  total (s)   self (s)
                              " need to pass in mode, known to break on 7.3.547
  728              0.003783   let mode = has('gui_running') ? 'gui' : 'cterm'
  728              0.008321   let color = synIDattr(synIDtrans(hlID(a:group)), a:what, mode)
  728              0.002188   if empty(color) || color == -1
                                let color = synIDattr(synIDtrans(hlID('Normal')), a:what, mode)
                              endif
  728              0.001745   if empty(color) || color == -1
                                if has('gui_running')
                                  let color = a:what ==# 'fg' ? '#000000' : '#FFFFFF'
                                else
                                  let color = a:what ==# 'fg' ? 0 : 1
                                endif
                              endif
  728              0.000815   return color

FUNCTION  <SNR>28_BMAdd()
Called 50 times
Total time:   0.006649
 Self time:   0.002070

count  total (s)   self (s)
   50              0.000138   if s:bmenu_wait == 0
                                " when adding too many buffers, redraw in short format
   50              0.000151     if s:bmenu_count == &menuitems && s:bmenu_short == 0
    1   0.001203   0.000013       call s:BMShow()
    1              0.000001     else
   49   0.004522   0.001133       call <SID>BMFilename(expand("<afile>"), expand("<abuf>"))
   49              0.000193       let s:bmenu_count = s:bmenu_count + 1
   49              0.000048     endif
   50              0.000029   endif

FUNCTION  neobundle#config#source_bundles()
Called 37 times
Total time:   0.148020
 Self time:   0.000367

count  total (s)   self (s)
   37              0.000106   if !empty(a:bundles)
    1              0.012293     call neobundle#config#source(map(copy(a:bundles), "type(v:val) == type({}) ? v:val.name : v:val"))
    1              0.000001   endif

FUNCTION  airline#parts#ffenc()
Called 20 times
Total time:   0.000355
 Self time:   0.000355

count  total (s)   self (s)
   20              0.000342   return printf('%s%s', &fenc, strlen(&ff) > 0 ? '['.&ff.']' : '')

FUNCTION  <SNR>28_BMTruncName()
Called 17 times
Total time:   0.001034
 Self time:   0.001034

count  total (s)   self (s)
   17              0.000041   let name = a:fname
   17              0.000025   if g:bmenu_max_pathlen < 5
                                let name = ""
                              else
   17              0.000050     let len = strlen(name)
   17              0.000029     if len > g:bmenu_max_pathlen
    2              0.000006       let amountl = (g:bmenu_max_pathlen / 2) - 2
    2              0.000005       let amountr = g:bmenu_max_pathlen - amountl - 3
    2              0.000009       let pattern = '^\(.\{,' . amountl . '}\).\{-}\(.\{,' . amountr . '}\)$'
    2              0.000279       let left = substitute(name, pattern, '\1', '')
    2              0.000227       let right = substitute(name, pattern, '\2', '')
    2              0.000010       if strlen(left) + strlen(right) < len
    2              0.000007 	let name = left . '...' . right
    2              0.000001       endif
    2              0.000002     endif
   17              0.000007   endif
   17              0.000025   return name

FUNCTION  tagbar#currenttag()
Called 20 times
Total time:   0.000930
 Self time:   0.000832

count  total (s)   self (s)
                                " Indicate that the statusline functionality is being used. This prevents
                                " the CloseWindow() function from removing the autocommands.
   20              0.000067     let s:statusline_in_use = 1
                            
   20              0.000027     if a:0 > 0
                                    " also test for non-zero value for backwards compatibility
   20              0.000181         let longsig   = a:1 =~# 's' || (type(a:1) == type(0) && a:1 != 0)
   20              0.000084         let fullpath  = a:1 =~# 'f'
   20              0.000076         let prototype = a:1 =~# 'p'
   20              0.000020     else
                                    let longsig   = 0
                                    let fullpath  = 0
                                    let prototype = 0
                                endif
                            
   20   0.000224   0.000126     if !s:Init(1)
   20              0.000032         return a:default
                                endif
                            
                                let tag = s:GetNearbyTag(0, 1)
                            
                                if !empty(tag)
                                    if prototype
                                        return tag.getPrototype(1)
                                    else
                                        return printf(a:fmt, tag.str(longsig, fullpath))
                                    endif
                                else
                                    return a:default
                                endif

FUNCTION  AutoPairsMap()
Called 90 times
Total time:   0.003056
 Self time:   0.003056

count  total (s)   self (s)
                              " | is special key which separate map command from text
   90              0.000196   let key = a:key
   90              0.000178   if key == '|'
                                let key = '<BAR>'
                              end
   90              0.000563   let escaped_key = substitute(key, "'", "''", 'g')
                              " use expr will cause search() doesn't work
   90              0.001691   execute 'inoremap <buffer> <silent> '.key." <C-R>=AutoPairsInsert('".escaped_key."')<CR>"

FUNCTION  <SNR>46_buffer_type()
Called 24 times
Total time:   0.004347
 Self time:   0.002557

count  total (s)   self (s)
   24   0.000207   0.000120   if self.getvar('fugitive_type') != ''
                                let type = self.getvar('fugitive_type')
                              elseif fnamemodify(self.spec(),':p') =~# '.\git/refs/\|\.git/\w*HEAD$'
                                let type = 'head'
                              elseif self.getline(1) =~ '^tree \x\{40\}$' && self.getline(2) == ''
                                let type = 'tree'
                              elseif self.getline(1) =~ '^\d\{6\} \w\{4\} \x\{40\}\>\t'
                                let type = 'tree'
                              elseif self.getline(1) =~ '^\d\{6\} \x\{40\}\> \d\t'
                                let type = 'index'
                              elseif isdirectory(self.spec())
   22              0.000050     let type = 'directory'
   22              0.000040   elseif self.spec() == ''
                                let type = 'null'
                              else
    2              0.000002     let type = 'file'
    2              0.000001   endif
   24              0.000024   if a:0
   24              0.000232     return !empty(filter(copy(a:000),'v:val ==# type'))
                              else
                                return type
                              endif

FUNCTION  <SNR>46_buffer_commit()
Called 24 times
Total time:   0.001021
 Self time:   0.000304

count  total (s)   self (s)
   24   0.001006   0.000289   return matchstr(self.spec(),'^fugitive://.\{-\}//\zs\w*')

FUNCTION  sy#highlight#line_disable()
Called 2 times
Total time:   0.000732
 Self time:   0.000732

count  total (s)   self (s)
    2              0.000082   execute 'sign define SignifyAdd text='. s:sign_add ' texthl=SignifySignAdd linehl='
                            
    2              0.000037   execute 'sign define SignifyChange text='. s:sign_change ' texthl=SignifySignChange linehl='
    2              0.000028   execute 'sign define SignifyChangeDelete1 text='. s:sign_change .'1 texthl=SignifySignChange linehl='
    2              0.000029   execute 'sign define SignifyChangeDelete2 text='. s:sign_change .'2 texthl=SignifySignChange linehl='
    2              0.000028   execute 'sign define SignifyChangeDelete3 text='. s:sign_change .'3 texthl=SignifySignChange linehl='
    2              0.000028   execute 'sign define SignifyChangeDelete4 text='. s:sign_change .'4 texthl=SignifySignChange linehl='
    2              0.000024   execute 'sign define SignifyChangeDelete5 text='. s:sign_change .'5 texthl=SignifySignChange linehl='
    2              0.000028   execute 'sign define SignifyChangeDelete6 text='. s:sign_change .'6 texthl=SignifySignChange linehl='
    2              0.000028   execute 'sign define SignifyChangeDelete7 text='. s:sign_change .'7 texthl=SignifySignChange linehl='
    2              0.000026   execute 'sign define SignifyChangeDelete8 text='. s:sign_change .'8 texthl=SignifySignChange linehl='
    2              0.000026   execute 'sign define SignifyChangeDelete9 text='. s:sign_change .'9 texthl=SignifySignChange linehl='
    2              0.000031   execute 'sign define SignifyChangeDeleteMore text='. s:sign_change .'> texthl=SignifySignChange linehl='
                            
    2              0.000025   execute 'sign define SignifyDelete1 text='. s:sign_delete .'1 texthl=SignifySignDelete linehl='
    2              0.000025   execute 'sign define SignifyDelete2 text='. s:sign_delete .'2 texthl=SignifySignDelete linehl='
    2              0.000029   execute 'sign define SignifyDelete3 text='. s:sign_delete .'3 texthl=SignifySignDelete linehl='
    2              0.000028   execute 'sign define SignifyDelete4 text='. s:sign_delete .'4 texthl=SignifySignDelete linehl='
    2              0.000025   execute 'sign define SignifyDelete5 text='. s:sign_delete .'5 texthl=SignifySignDelete linehl='
    2              0.000030   execute 'sign define SignifyDelete6 text='. s:sign_delete .'6 texthl=SignifySignDelete linehl='
    2              0.000027   execute 'sign define SignifyDelete7 text='. s:sign_delete .'7 texthl=SignifySignDelete linehl='
    2              0.000026   execute 'sign define SignifyDelete8 text='. s:sign_delete .'8 texthl=SignifySignDelete linehl='
    2              0.000025   execute 'sign define SignifyDelete9 text='. s:sign_delete .'9 texthl=SignifySignDelete linehl='
    2              0.000025   execute 'sign define SignifyDeleteMore text='. s:sign_delete .'> texthl=SignifySignDelete linehl='
                            
    2              0.000041   execute 'sign define SignifyDeleteFirstLine text='. s:sign_delete_first_line ' texthl=SignifySignDelete linehl='
                            
    2              0.000005   let g:signify_line_highlight = 0

FUNCTION  airline#parts#paste()
Called 20 times
Total time:   0.000098
 Self time:   0.000098

count  total (s)   self (s)
   20              0.000084   return g:airline_detect_paste && &paste ? g:airline_symbols.paste : ''

FUNCTION  airline#update_statusline()
Called 45 times
Total time:   0.116972
 Self time:   0.003972

count  total (s)   self (s)
   45              0.000412   for nr in filter(range(1, winnr('$')), 'v:val != winnr()')
                                call setwinvar(nr, 'airline_active', 0)
                                let context = { 'winnr': nr, 'active': 0, 'bufnr': winbufnr(nr) }
                                call s:invoke_funcrefs(context, s:inactive_funcrefs)
                              endfor
                            
   45              0.000132   unlet! w:airline_render_left
   45              0.000079   unlet! w:airline_render_right
  405              0.000476   for section in s:sections
  360              0.000989     unlet! w:airline_section_{section}
  360              0.000253   endfor
                            
   45              0.000108   let w:airline_active = 1
   45              0.000281   let context = { 'winnr': winnr(), 'active': 1, 'bufnr': winbufnr(winnr()) }
   45   0.113437   0.000437   call s:invoke_funcrefs(context, g:airline_statusline_funcrefs)

FUNCTION  neobundle#autoload#explorer()
Called 41 times
Total time:   0.003814
 Self time:   0.001682

count  total (s)   self (s)
   41              0.000298   if bufnr('%') != expand('<abuf>') || a:path == ''
   25              0.000032     return
                              endif
                            
   16              0.000037   let path = a:path
                              " For ":edit ~".
   16              0.000062   if fnamemodify(path, ':t') ==# '~'
                                let path = '~'
                              endif
                            
   16   0.000516   0.000104   let path = s:expand(path)
   16              0.000215   if !(isdirectory(path) || (!filereadable(path) && path =~ '^\h\w\+://'))
    4              0.000004     return
                              endif
                            
   12   0.002358   0.000638   let bundles = filter(neobundle#config#get_autoload_bundles(), "get(v:val.autoload, 'explorer', 0)")
   12              0.000033   if !empty(bundles)
                                call neobundle#config#source_bundles(bundles)
                                execute 'doautocmd' a:event
                              endif

FUNCTION  <SNR>46_repo()
Called 40 times
Total time:   0.001271
 Self time:   0.001271

count  total (s)   self (s)
   40              0.000321   let dir = a:0 ? a:1 : (exists('b:git_dir') && b:git_dir !=# '' ? b:git_dir : fugitive#extract_git_dir(expand('%:p')))
   40              0.000077   if dir !=# ''
   40              0.000124     if has_key(s:repos, dir)
   39              0.000126       let repo = get(s:repos, dir)
   39              0.000036     else
    1              0.000002       let repo = {'git_dir': dir}
    1              0.000002       let s:repos[dir] = repo
    1              0.000000     endif
   40              0.000310     return extend(extend(repo, s:repo_prototype, 'keep'), s:abstract_prototype, 'keep')
                              endif
                              call s:throw('not a git repository: '.expand('%:p'))

FUNCTION  neobundle#call_hook()
Called 7 times
Total time:   0.000442
 Self time:   0.000314

count  total (s)   self (s)
    7   0.000083   0.000051   let bundles = neobundle#util#convert2list( (empty(a:000) ? neobundle#config#get_neobundles() : a:1))
    7              0.000086   let bundles = filter(copy(bundles), 'has_key(v:val.hooks, a:hook_name) &&  !has_key(v:val.called_hooks, a:hook_name)')
                            
    7              0.000018   if a:hook_name ==# 'on_source' || a:hook_name ==# 'on_post_source'
    7   0.000175   0.000079     let bundles = filter(neobundle#config#tsort(filter(bundles, 'neobundle#config#is_sourced(v:val.name) &&  neobundle#config#is_installed(v:val.name)')), 'has_key(v:val.hooks, a:hook_name)  && !has_key(v:val.called_hooks, a:hook_name)')
    7              0.000008   endif
                            
    7              0.000015   for bundle in bundles
                                call call(bundle.hooks[a:hook_name], [bundle], bundle)
                                let bundle.called_hooks[a:hook_name] = 1
                              endfor

FUNCTION  airline#parts#readonly()
Called 139 times
Total time:   0.000682
 Self time:   0.000682

count  total (s)   self (s)
  139              0.000562   return &readonly ? g:airline_symbols.readonly : ''

FUNCTION  <SNR>139_NetrwOptionRestore()
Called 45 times
Total time:   0.030911
 Self time:   0.025785

count  total (s)   self (s)
                            "  call Dfunc("s:NetrwOptionRestore(vt<".a:vt.">) win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> winnr($)=".winnr("$"))
   45              0.000232   if !exists("{a:vt}netrw_optionsave")
   14              0.000078    if exists("s:nbcd_curpos_{bufnr('%')}")
                            "    call Decho("(NetrwOptionRestore) restoring previous position  (s:nbcd_curpos_".bufnr('%')." exists)")
                                keepj call netrw#NetrwRestorePosn(s:nbcd_curpos_{bufnr('%')})
                            "    call Decho("(NetrwOptionRestore) win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> winnr($)=".winnr("$"))
                            "    call Decho("(NetrwOptionRestore) unlet s:nbcd_curpos_".bufnr('%'))
                                unlet s:nbcd_curpos_{bufnr('%')}
                               else
                            "    call Decho("(NetrwOptionRestore) no previous position")
   14              0.000010    endif
                            "   call Decho("(NetrwOptionRestore) ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
                            "   call Dret("s:NetrwOptionRestore : ".a:vt."netrw_optionsave doesn't exist")
   14              0.000012    return
                              endif
   31              0.000101   unlet {a:vt}netrw_optionsave
                            
   31              0.000160   if exists("+acd")
   31              0.000127    if exists("{a:vt}netrw_acdkeep")
                            "    call Decho("(NetrwOptionRestore) g:netrw_keepdir=".g:netrw_keepdir.": getcwd<".getcwd()."> acd=".&acd)
   31              0.000690     let curdir = getcwd()
   31              0.000273     let &l:acd = {a:vt}netrw_acdkeep
   31              0.000103     unlet {a:vt}netrw_acdkeep
   31              0.000107     if &l:acd
                            "     call Decho("exe keepj lcd ".fnameescape(curdir))  " NOTE: was g:netrw_fname_escape for some reason
                                 try
                                  if !exists("&l:acd") && !&l:acd
                                   exe 'keepj lcd '.fnameescape(curdir)
                                  endif
                                 catch /^Vim\%((\a\+)\)\=:E472/
                                  call netrw#ErrorMsg(s:ERROR,"unable to change directory to <".curdir."> (permissions?)",61)
                                 endtry
                                endif
   31              0.000013    endif
   31              0.000014   endif
   31              0.000442   if exists("{a:vt}netrw_aikeep")   |let &l:ai     = {a:vt}netrw_aikeep      |unlet {a:vt}netrw_aikeep   |endif
   31              0.000398   if exists("{a:vt}netrw_awkeep")   |let &l:aw     = {a:vt}netrw_awkeep      |unlet {a:vt}netrw_awkeep   |endif
   31              0.000070   if g:netrw_liststyle != s:TREELIST
   31              0.000419    if exists("{a:vt}netrw_bhkeep")  |let &l:bh     = {a:vt}netrw_bhkeep      |unlet {a:vt}netrw_bhkeep   |endif
   31              0.000018   endif
   31   0.004250   0.000408   if exists("{a:vt}netrw_blkeep")   |let &l:bl     = {a:vt}netrw_blkeep      |unlet {a:vt}netrw_blkeep   |endif
   31              0.000386   if exists("{a:vt}netrw_btkeep")   |let &l:bt     = {a:vt}netrw_btkeep      |unlet {a:vt}netrw_btkeep   |endif
   31              0.000343   if exists("{a:vt}netrw_bombkeep") |let &l:bomb   = {a:vt}netrw_bombkeep    |unlet {a:vt}netrw_bombkeep |endif
   31              0.000317   if exists("{a:vt}netrw_cedit")    |let &cedit    = {a:vt}netrw_cedit       |unlet {a:vt}netrw_cedit    |endif
   31              0.000376   if exists("{a:vt}netrw_cikeep")   |let &l:ci     = {a:vt}netrw_cikeep      |unlet {a:vt}netrw_cikeep   |endif
   31              0.000389   if exists("{a:vt}netrw_cinkeep")  |let &l:cin    = {a:vt}netrw_cinkeep     |unlet {a:vt}netrw_cinkeep  |endif
   31              0.000401   if exists("{a:vt}netrw_cinokeep") |let &l:cino   = {a:vt}netrw_cinokeep    |unlet {a:vt}netrw_cinokeep |endif
   31              0.000427   if exists("{a:vt}netrw_comkeep")  |let &l:com    = {a:vt}netrw_comkeep     |unlet {a:vt}netrw_comkeep  |endif
   31              0.000412   if exists("{a:vt}netrw_cpokeep")  |let &l:cpo    = {a:vt}netrw_cpokeep     |unlet {a:vt}netrw_cpokeep  |endif
   31              0.000342   if exists("{a:vt}netrw_diffkeep") |let &l:diff   = {a:vt}netrw_diffkeep    |unlet {a:vt}netrw_diffkeep |endif
   31              0.000364   if exists("{a:vt}netrw_fenkeep")  |let &l:fen    = {a:vt}netrw_fenkeep     |unlet {a:vt}netrw_fenkeep  |endif
   31              0.000370   if exists("{a:vt}netrw_ffkeep")   |let &l:ff     = {a:vt}netrw_ffkeep      |unlet {a:vt}netrw_ffkeep   |endif
   31              0.000367   if exists("{a:vt}netrw_fokeep")   |let &l:fo     = {a:vt}netrw_fokeep      |unlet {a:vt}netrw_fokeep   |endif
   31              0.000352   if exists("{a:vt}netrw_gdkeep")   |let &l:gd     = {a:vt}netrw_gdkeep      |unlet {a:vt}netrw_gdkeep   |endif
   31              0.000322   if exists("{a:vt}netrw_hidkeep")  |let &l:hidden = {a:vt}netrw_hidkeep     |unlet {a:vt}netrw_hidkeep  |endif
   31              0.000338   if exists("{a:vt}netrw_imkeep")   |let &l:im     = {a:vt}netrw_imkeep      |unlet {a:vt}netrw_imkeep   |endif
   31              0.001969   if exists("{a:vt}netrw_iskkeep")  |let &l:isk    = {a:vt}netrw_iskkeep     |unlet {a:vt}netrw_iskkeep  |endif
   31              0.000379   if exists("{a:vt}netrw_lskeep")   |let &l:ls     = {a:vt}netrw_lskeep      |unlet {a:vt}netrw_lskeep   |endif
   31              0.000340   if exists("{a:vt}netrw_makeep")   |let &l:ma     = {a:vt}netrw_makeep      |unlet {a:vt}netrw_makeep   |endif
   31              0.000328   if exists("{a:vt}netrw_magickeep")|let &l:magic  = {a:vt}netrw_magickeep   |unlet {a:vt}netrw_magickeep|endif
   31              0.000358   if exists("{a:vt}netrw_modkeep")  |let &l:mod    = {a:vt}netrw_modkeep     |unlet {a:vt}netrw_modkeep  |endif
   31              0.000326   if exists("{a:vt}netrw_nukeep")   |let &l:nu     = {a:vt}netrw_nukeep      |unlet {a:vt}netrw_nukeep   |endif
   31              0.000313   if exists("{a:vt}netrw_repkeep")  |let &l:report = {a:vt}netrw_repkeep     |unlet {a:vt}netrw_repkeep  |endif
   31              0.000332   if exists("{a:vt}netrw_rokeep")   |let &l:ro     = {a:vt}netrw_rokeep      |unlet {a:vt}netrw_rokeep   |endif
   31              0.000347   if exists("{a:vt}netrw_selkeep")  |let &l:sel    = {a:vt}netrw_selkeep     |unlet {a:vt}netrw_selkeep  |endif
   31              0.000339   if exists("{a:vt}netrw_spellkeep")|let &l:spell  = {a:vt}netrw_spellkeep   |unlet {a:vt}netrw_spellkeep|endif
                              " Problem: start with liststyle=0; press <i> : result, following line resets l:ts.
                            "  if exists("{a:vt}netrw_tskeep")   |let &l:ts     = {a:vt}netrw_tskeep      |unlet {a:vt}netrw_tskeep   |endif
   31              0.000375   if exists("{a:vt}netrw_twkeep")   |let &l:tw     = {a:vt}netrw_twkeep      |unlet {a:vt}netrw_twkeep   |endif
   31              0.000348   if exists("{a:vt}netrw_wigkeep")  |let &l:wig    = {a:vt}netrw_wigkeep     |unlet {a:vt}netrw_wigkeep  |endif
   31              0.000333   if exists("{a:vt}netrw_wrapkeep") |let &l:wrap   = {a:vt}netrw_wrapkeep    |unlet {a:vt}netrw_wrapkeep |endif
   31              0.000355   if exists("{a:vt}netrw_writekeep")|let &l:write  = {a:vt}netrw_writekeep   |unlet {a:vt}netrw_writekeep|endif
   31              0.000245   if exists("s:yykeep")             |let  @@       = s:yykeep                |unlet s:yykeep             |endif
   31              0.000117   if exists("{a:vt}netrw_swfkeep")
                               if &directory == ""
                                " user hasn't specified a swapfile directory;
                                " netrw will temporarily set the swapfile directory
                                " to the current directory as returned by getcwd().
                                let &l:directory   = getcwd()
                                sil! let &l:swf = {a:vt}netrw_swfkeep
                                setl directory=
                                unlet {a:vt}netrw_swfkeep
                               elseif &l:swf != {a:vt}netrw_swfkeep
                                " following line causes a Press ENTER in windows -- can't seem to work around it!!!
                                sil! let &l:swf= {a:vt}netrw_swfkeep
                                unlet {a:vt}netrw_swfkeep
                               endif
                              endif
   31              0.000384   if exists("{a:vt}netrw_dirkeep") && isdirectory({a:vt}netrw_dirkeep) && g:netrw_keepdir
   31              0.000296    let dirkeep = substitute({a:vt}netrw_dirkeep,'\\','/','g')
   31              0.001720    if exists("{a:vt}netrw_dirkeep")  |exe "keepj lcd ".fnameescape(dirkeep)|unlet {a:vt}netrw_dirkeep  |endif
   31              0.000020   endif
   31              0.000223   if exists("{a:vt}netrw_regstar") |sil! let @*= {a:vt}netrw_regstar |unlet {a:vt}netrw_regstar |endif
   31              0.004235   if exists("{a:vt}netrw_regslash")|sil! let @/= {a:vt}netrw_regslash|unlet {a:vt}netrw_regslash|endif
   31              0.000262   if exists("s:nbcd_curpos_{bufnr('%')}")
                            "   call Decho("(NetrwOptionRestore) restoring previous position  (s:nbcd_curpos_".bufnr('%')." exists)")
   12   0.001411   0.000127    keepj call netrw#NetrwRestorePosn(s:nbcd_curpos_{bufnr('%')})
                            "   call Decho("(NetrwOptionRestore) unlet s:nbcd_curpos_".bufnr('%'))
   12              0.000076    unlet s:nbcd_curpos_{bufnr('%')}
   12              0.000010   else
                            "   call Decho("no previous position")
   19              0.000012   endif
                            
                            "  call Decho("(NetrwOptionRestore) g:netrw_keepdir=".g:netrw_keepdir.": getcwd<".getcwd()."> acd=".&acd)
                            "  call Decho("(NetrwOptionRestore) fo=".&fo.(exists("+acd")? " acd=".&acd : " acd doesn't exist"))
                            "  call Decho("(NetrwOptionRestore) ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
                            "  call Decho("(NetrwOptionRestore) diff=".&l:diff." win#".winnr()." w:netrw_diffkeep=".(exists("w:netrw_diffkeep")? w:netrw_diffkeep : "doesn't exist"))
                            "  call Decho("(NetrwOptionRestore) ts=".&l:ts)
                              " Moved the filetype detect here from NetrwGetFile() because remote files
                              " were having their filetype detect-generated settings overwritten by
                              " NetrwOptionRestore.
   31              0.000137   if &ft != "netrw"
                            "   call Decho("(NetrwOptionRestore) filetype detect  (ft=".&ft.")")
                               filetype detect
                              endif
                            "  call Dret("s:NetrwOptionRestore : tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> modified=".&modified." modifiable=".&modifiable." readonly=".&readonly)

FUNCTION  airline#highlighter#exec()
Called 182 times
Total time:   0.013084
 Self time:   0.013084

count  total (s)   self (s)
  182              0.000368   let colors = a:colors
  182              0.000258   if s:is_win32term
                                let colors[2] = s:gui2cui(get(colors, 0, ''), get(colors, 2, ''))
                                let colors[3] = s:gui2cui(get(colors, 1, ''), get(colors, 3, ''))
                              endif
  182              0.010543   exec printf('hi %s %s %s %s %s %s %s %s', a:group, get(colors, 0, '') != '' ? 'guifg='.colors[0] : '', get(colors, 1, '') != '' ? 'guibg='.colors[1] : '', get(colors, 2, '') != '' ? 'ctermfg='.colors[2] : '', get(colors, 3, '') != '' ? 'ctermbg='.colors[3] : '', get(colors, 4, '') != '' ? 'gui='.colors[4] : '', get(colors, 4, '') != '' ? 'cterm='.colors[4] : '', get(colors, 4, '') != '' ? 'term='.colors[4] : '')

FUNCTION  sy#repo#get_stats()
Called 20 times
Total time:   0.000313
 Self time:   0.000313

count  total (s)   self (s)
   20              0.000153   if !exists('g:sy_path') || !has_key(g:sy, g:sy_path)
                                return [-1, -1, -1]
                              endif
                            
   20              0.000061   return g:sy[g:sy_path].stats

FUNCTION  <SNR>63_mergelists()
Called 2 times
Total time:   0.000351
 Self time:   0.000167

count  total (s)   self (s)
    2   0.000186   0.000022 	let diskmrufs = ctrlp#utils#readfile(ctrlp#mrufiles#cachefile())
    2              0.000114 	cal filter(diskmrufs, 'index(s:mrufs, v:val) < 0')
    2              0.000016 	let mrufs = s:mrufs + diskmrufs
    2   0.000033   0.000013 	retu s:chop(mrufs)

FUNCTION  tern#Enable()
Called 3 times
Total time:   0.001073
 Self time:   0.001073

count  total (s)   self (s)
    3              0.000030   if stridx(&buftype, "nofile") > -1 || stridx(&buftype, "nowrite") > -1
                                return
                              endif
    3              0.000009   let b:ternProjectDir = ''
    3              0.000007   let b:ternLastCompletion = []
    3              0.000021   let b:ternLastCompletionPos = {'row': -1, 'start': 0, 'end': 0}
    3              0.000008   let b:ternBufferSentAt = -1
    3              0.000007   let b:ternInsertActive = 0
    3              0.000015   setlocal omnifunc=tern#Complete
    3              0.000005   if g:tern_map_keys
                                call tern#DefaultKeyMap(g:tern_map_prefix)
                              endif
    3              0.000009   augroup TernAutoCmd
    3              0.000832     autocmd! * <buffer>
    3              0.000021     autocmd BufLeave <buffer> :py tern_sendBufferIfDirty()
    3              0.000013     if g:tern_show_argument_hints == 'on_move'
                                  autocmd CursorMoved,CursorMovedI <buffer> call tern#LookupArgumentHints()
                                elseif g:tern_show_argument_hints == 'on_hold'
                                  autocmd CursorHold,CursorHoldI <buffer> call tern#LookupArgumentHints()
                                endif
    3              0.000021     autocmd InsertEnter <buffer> let b:ternInsertActive = 1
    3              0.000014     autocmd InsertLeave <buffer> let b:ternInsertActive = 0
    3              0.000004   augroup END

FUNCTION  indent_guides#init_matches()
Called 46 times
Total time:   0.000330
 Self time:   0.000330

count  total (s)   self (s)
   46              0.000294   let w:indent_guides_matches = exists('w:indent_guides_matches') ? w:indent_guides_matches : []

FUNCTION  <SNR>139_LocalFastBrowser()
Called 12 times
Total time:   0.000834
 Self time:   0.000834

count  total (s)   self (s)
                            "    call Dfunc("LocalFastBrowser() g:netrw_fastbrowse=".g:netrw_fastbrowse."  s:netrw_browser_shellcmd ".(exists("s:netrw_browser_shellcmd")? "exists" : "does not exist"))
                            
                              " initialize browselist, a list of buffer numbers that the local browser has used
   12              0.000043   if !exists("s:netrw_browselist")
                            "   call Decho("(LocalFastBrowser) initialize s:netrw_browselist")
    1              0.000002    let s:netrw_browselist= []
    1              0.000001   endif
                            
                              " append current buffer to fastbrowse list
   12              0.000073   if empty(s:netrw_browselist) || bufnr("%") > s:netrw_browselist[-1]
                            "   call Decho("(LocalFastBrowser) appendng current buffer to browselist")
    8              0.000032    call add(s:netrw_browselist,bufnr("%"))
                            "   call Decho("(LocalFastBrowser) browselist=".string(s:netrw_browselist))
    8              0.000006   endif
                            
                              " enable autocmd events to handle refreshing/removing local browser buffers
                              "    If local browse buffer is currently showing: refresh it
                              "    If local browse buffer is currently hidden : wipe it
                              "    g:netrw_fastbrowse=0 : slow   speed, never re-use directory listing
                              "                      =1 : medium speed, re-use directory listing for remote only
                              "                      =2 : fast   speed, always re-use directory listing when possible
   12              0.000049   if !exists("s:netrw_browser_shellcmd") && g:netrw_fastbrowse <= 1
                            "   call Decho("(LocalFastBrowser) setting up local-browser shell command refresh")
    1              0.000003    let s:netrw_browser_shellcmd= 1
    1              0.000002    augroup AuNetrwShellCmd
    1              0.000178     au!
    1              0.000011     if (has("win32") || has("win95") || has("win64") || has("win16"))
                            "     call Decho("(LocalFastBrowser) autocmd: ShellCmdPost * call s:LocalBrowseShellCmdRefresh()")
                                 au ShellCmdPost			*	call s:LocalBrowseShellCmdRefresh()
                                else
    1              0.000010      au ShellCmdPost,FocusGained	*	call s:LocalBrowseShellCmdRefresh()
                            "     call Decho("(LocalFastBrowser) autocmd: ShellCmdPost,FocusGained * call s:LocalBrowseShellCmdRefresh()")
    1              0.000001     endif
    1              0.000001    augroup END
    1              0.000001   endif
                            
                              " user must have changed fastbrowse to its fast setting, so remove
                              " the associated autocmd events
   12              0.000028   if g:netrw_fastbrowse > 1 && exists("s:netrw_browser_shellcmd")
                            "   call Decho("(LocalFastBrowser) remove AuNetrwShellCmd autcmd group")
                               unlet s:netrw_browser_shellcmd
                               augroup AuNetrwShellCmd
                                au!
                               augroup END
                               augroup! AuNetrwShellCmd
                              endif
                            
                            "  call Dret("LocalFastBrowser : browselist<".string(s:netrw_browselist).">")

FUNCTION  neobundle#util#split_rtp()
Called 7 times
Total time:   0.000312
 Self time:   0.000312

count  total (s)   self (s)
    7              0.000019   let rtp = a:0 ? a:1 : &runtimepath
    7              0.000022   if type(rtp) == type([])
                                return rtp
                              endif
                            
    7              0.000080   if rtp !~ '\\'
    7              0.000163     return split(rtp, ',')
                              endif
                            
                              let split = split(rtp, '\\\@<!\%(\\\\\)*\zs,')
                              return map(split,'substitute(v:val, ''\\\([\\,]\)'', "\\1", "g")')

FUNCTION  <SNR>46_sub()
Called 130 times
Total time:   0.001497
 Self time:   0.001497

count  total (s)   self (s)
  130              0.001423   return substitute(a:str,'\v\C'.a:pat,a:rep,'')

FUNCTION  indent_guides#disable()
Called 46 times
Total time:   0.001828
 Self time:   0.000364

count  total (s)   self (s)
   46              0.000128   let g:indent_guides_autocmds_enabled = 0
   46   0.001670   0.000206   call indent_guides#clear_matches()

FUNCTION  airline#highlighter#add_accent()
Called 33 times
Total time:   0.000149
 Self time:   0.000149

count  total (s)   self (s)
   33              0.000124   let s:accents[a:accent] = 1

FUNCTION  airline#extensions#tabline#formatters#default()
Called 66 times
Total time:   0.006477
 Self time:   0.005337

count  total (s)   self (s)
   66              0.000127   let _ = ''
                            
   66              0.000210   let name = bufname(a:bufnr)
   66              0.000151   if empty(name)
                                let _ .= '[No Name]'
                              else
   66              0.000101     if s:fnamecollapse
   66              0.003499       let _ .= substitute(fnamemodify(name, s:fmod), '\v\w\zs.{-}\ze(\\|/)', '', 'g')
   66              0.000093     else
                                  let _ .= fnamemodify(name, s:fmod)
                                endif
   66              0.000047   endif
                            
   66   0.001613   0.000473   return s:wrap_name(a:bufnr, _)

FUNCTION  <SNR>69_UpdateList()
Called 11 times
Total time:   0.000939
 Self time:   0.000939

count  total (s)   self (s)
                              " Function to update the window list with info about the current buffer
   11              0.000044   if !exists('w:BufKillList')
                                let w:BufKillList = []
                              endif
   11              0.000035   if !exists('w:BufKillColumnList')
                                let w:BufKillColumnList = []
                              endif
   11              0.000028   if !exists('w:BufKillIndex')
                                let w:BufKillIndex = -1
                              endif
   11              0.000033   if !exists('w:BufKillLastCmd')
                                let w:BufKillLastCmd = ''
                              endif
   11              0.000038   let bufferNum = bufnr('%')
                            
   11              0.000067   if (w:BufKillLastCmd=~'bufchange')
                                " When stepping through files, the w:BufKillList should not be changed
                                " here, only by the GotoBuffer command since the files must already
                                " exist in the list to jump to them.
                              else
                                " Increment index
   11              0.000041     let w:BufKillIndex += 1
   11              0.000039     if w:BufKillIndex < len(w:BufKillList)
                                  " The branch is diverging, remove the end of the list
                                  call remove(w:BufKillList, w:BufKillIndex, -1)
                                  " Same for column list
                                  if w:BufKillIndex < len(w:BufKillColumnList)
                                    call remove(w:BufKillColumnList, w:BufKillIndex, -1)
                                  endif
                                endif
                                " Now remove any pre-existing instances of the buffer in the list
   11              0.000051     let existingIndex = index(w:BufKillList, bufferNum)
   11              0.000018     if existingIndex != -1
    1              0.000011       call remove(w:BufKillList, existingIndex)
    1              0.000004       let w:BufKillIndex -= 1
    1              0.000005       if existingIndex < len(w:BufKillColumnList)
    1              0.000015         call remove(w:BufKillColumnList, existingIndex)
    1              0.000001       endif
    1              0.000001     endif
                                " Now add the buffer to the list, at the end
   11              0.000043     let w:BufKillList += [bufferNum]
   11              0.000009   endif
                            
                              " Reset since command processed
   11              0.000028   let w:BufKillLastCmd = ''
                            

FUNCTION  <SNR>28_BMMunge()
Called 17 times
Total time:   0.002085
 Self time:   0.001051

count  total (s)   self (s)
   17              0.000041   let name = a:fname
   17              0.000032   if name == ''
   14              0.000046     if !exists("g:menutrans_no_file")
                                  let g:menutrans_no_file = "[No file]"
                                endif
   14              0.000023     let name = g:menutrans_no_file
   14              0.000010   else
    3              0.000045     let name = fnamemodify(name, ':p:~')
    3              0.000003   endif
                              " detach file name and separate it out:
   17              0.000064   let name2 = fnamemodify(name, ':t')
   17              0.000030   if a:bnum >= 0
   17              0.000074     let name2 = name2 . ' (' . a:bnum . ')'
   17              0.000014   endif
   17   0.001212   0.000178   let name = name2 . "\t" . <SID>BMTruncName(fnamemodify(name,':h'))
   17              0.000086   let name = escape(name, "\\. \t|")
   17              0.000108   let name = substitute(name, "&", "&&", "g")
   17              0.000104   let name = substitute(name, "\n", "^@", "g")
   17              0.000024   return name

FUNCTION  <SNR>30_LoadFTPlugin()
Called 35 times
Total time:   0.140671
 Self time:   0.077343

count  total (s)   self (s)
   35              0.000136     if exists("b:undo_ftplugin")
    1              0.000024       exe b:undo_ftplugin
    1              0.000003       unlet! b:undo_ftplugin b:did_ftplugin
    1              0.000000     endif
                            
   35              0.000158     let s = expand("<amatch>")
   35              0.000077     if s != ""
   35              0.000286       if &cpo =~# "S" && exists("b:did_ftplugin")
                            	" In compatible mode options are reset to the global values, need to
                            	" set the local values also when a plugin was already used.
                            	unlet b:did_ftplugin
                                  endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "aaa" and then "bbb".
   70              0.000292       for name in split(s, '\.')
   35   0.138950   0.075622 	exe 'runtime! ftplugin/' . name . '.vim ftplugin/' . name . '_*.vim ftplugin/' . name . '/*.vim'
   35              0.000093       endfor
   35              0.000030     endif

FUNCTION  <SNR>46_buffer_getvar()
Called 136 times
Total time:   0.000590
 Self time:   0.000590

count  total (s)   self (s)
  136              0.000528   return getbufvar(self['#'],a:var)

FUNCTION  <SNR>28_BMShow()
Called 1 time
Total time:   0.001190
 Self time:   0.000966

count  total (s)   self (s)
    1              0.000002   let s:bmenu_wait = 1
    1              0.000001   let s:bmenu_short = 1
    1              0.000001   let s:bmenu_count = 0
                              "
                              " get new priority, if exists
    1              0.000001   if a:0 == 1
                                let g:bmenu_priority = a:1
                              endif
                            
                              " remove old menu, if exists; keep one entry to avoid a torn off menu to
                              " disappear.
    1              0.000004   silent! unmenu &Buffers
    1              0.000051   exe 'noremenu ' . g:bmenu_priority . ".1 &Buffers.Dummy l"
    1              0.000186   silent! unmenu! &Buffers
                            
                              " create new menu; set 'cpo' to include the <CR>
    1              0.000006   let cpo_save = &cpo
    1              0.000006   set cpo&vim
    1              0.000045   exe 'an <silent> ' . g:bmenu_priority . ".2 &Buffers.&Refresh\\ menu :call <SID>BMShow()<CR>"
    1              0.000038   exe 'an ' . g:bmenu_priority . ".4 &Buffers.&Delete :confirm bd<CR>"
    1              0.000037   exe 'an ' . g:bmenu_priority . ".6 &Buffers.&Alternate :confirm b #<CR>"
    1              0.000036   exe 'an ' . g:bmenu_priority . ".7 &Buffers.&Next :confirm bnext<CR>"
    1              0.000036   exe 'an ' . g:bmenu_priority . ".8 &Buffers.&Previous :confirm bprev<CR>"
    1              0.000034   exe 'an ' . g:bmenu_priority . ".9 &Buffers.-SEP- :"
    1              0.000007   let &cpo = cpo_save
    1              0.000020   unmenu &Buffers.Dummy
                            
                              " figure out how many buffers there are
    1              0.000003   let buf = 1
    9              0.000019   while buf <= bufnr('$')
    8              0.000049     if bufexists(buf) && !isdirectory(bufname(buf)) && buflisted(buf)
    1              0.000003       let s:bmenu_count = s:bmenu_count + 1
    1              0.000001     endif
    8              0.000015     let buf = buf + 1
    8              0.000006   endwhile
    1              0.000002   if s:bmenu_count <= &menuitems
    1              0.000001     let s:bmenu_short = 0
    1              0.000000   endif
                            
                              " iterate through buffer list, adding each buffer to the menu:
    1              0.000001   let buf = 1
    9              0.000017   while buf <= bufnr('$')
    8              0.000045     if bufexists(buf) && !isdirectory(bufname(buf)) && buflisted(buf)
    1   0.000231   0.000007       call <SID>BMFilename(bufname(buf), buf)
    1              0.000001     endif
    8              0.000015     let buf = buf + 1
    8              0.000007   endwhile
    1              0.000001   let s:bmenu_wait = 0
    1              0.000001   aug buffer_list
    1              0.000172   au!
    1              0.000009   au BufCreate,BufFilePost * call <SID>BMAdd()
    1              0.000005   au BufDelete,BufFilePre * call <SID>BMRemove()
    1              0.000001   aug END

FUNCTION  neobundle#get_neobundle_dir()
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000002   return s:neobundle_dir

FUNCTION  neobundle#config#source()
Called 1 time
Total time:   0.147653
 Self time:   0.006397

count  total (s)   self (s)
    1              0.000004   let is_force = get(a:000, 0, 1)
                            
    1   0.000008   0.000004   let names = neobundle#util#convert2list(a:names)
    1   0.002246   0.000013   let bundles = empty(names) ? neobundle#config#get_neobundles() : neobundle#config#search(names)
    1   0.003204   0.000011   let not_exists = neobundle#config#check_not_exists(names)
    1              0.000002   if !empty(not_exists)
                                call neobundle#util#print_error( 'Not installed plugin-names are detected : '. string(not_exists))
                              endif
                            
    1   0.000052   0.000008   let rtps = neobundle#util#split_rtp()
    1   0.000088   0.000032   let bundles = filter(bundles, "!neobundle#config#is_sourced(v:val.name) || (v:val.rtp != '' && index(rtps, v:val.rtp) < 0)")
    1              0.000002   if empty(bundles)
                                return
                              endif
                            
    1              0.000001   let filetype_out = ''
    1              0.000004   redir => filetype_out
    1              0.000006   silent filetype
    1              0.000003   redir END
                            
    1              0.000003   redir => filetype_before
    1              0.000015   execute 'silent autocmd FileType' &filetype
    1              0.000002   redir END
                            
    1              0.000002   let reset_ftplugin = 0
    7              0.000008   for bundle in bundles
    6              0.000011     let bundle.sourced = 1
    6              0.000007     let bundle.disabled = 0
                            
    6              0.000019     if !get(s:sourced_neobundles, bundle.name, 0)
                                  " Unmap dummy mappings.
    6              0.000018       for [mode, mapping] in get(bundle, 'dummy_mappings', [])
                                    silent! execute mode.'unmap' mapping
                                  endfor
                            
                                  " Delete dummy commands.
    6              0.000016       for command in get(bundle, 'dummy_commands', [])
                                    silent! execute 'delcommand' command
                                  endfor
                            
    6              0.000019       let s:sourced_neobundles[bundle.name] = 1
    6              0.000003     endif
                            
    6              0.000011     let bundle.dummy_mappings = []
    6              0.000009     let bundle.dummy_commands = []
                            
    6   0.001063   0.000094     call neobundle#config#rtp_add(bundle)
                            
    6              0.000019     if exists('g:loaded_neobundle') || is_force
    6   0.000389   0.000045       call neobundle#call_hook('on_source', bundle)
                            
                                  " Reload script files.
   11              0.000193       for directory in filter( ['ftdetect', 'after/ftdetect', 'plugin', 'after/plugin'], "isdirectory(bundle.rtp.'/'.v:val)")
   10              0.002452         for file in split(glob(bundle.rtp.'/'.directory.'/**/*.vim'), '\n')
    5   0.003720   0.000571           silent! source `=file`
    5              0.000007         endfor
    5              0.000002       endfor
                            
    6              0.000034       if exists('#'.bundle.augroup.'#VimEnter')
                                    execute 'silent doautocmd' bundle.augroup 'VimEnter'
                            
                                    if has('gui_running') && &term ==# 'builtin_gui'
                                      execute 'silent doautocmd' bundle.augroup 'GUIEnter'
                                    endif
                                  endif
    6              0.000004     endif
                            
    6              0.000009     if !reset_ftplugin
    2              0.000007       for filetype in split(&filetype, '\.')
    2              0.000006         for directory in ['ftplugin', 'indent', 'syntax', 'after/ftplugin', 'after/indent', 'after/syntax']
    2              0.000006           let base = bundle.rtp . '/' . directory
    2              0.000056           if filereadable(base.'/'.filetype.'.vim') || (directory =~# 'ftplugin$' &&   isdirectory(base . '/' . filetype) ||   glob(base.'/'.filetype.'_*.vim') != '')
    1              0.000002             let reset_ftplugin = 1
    1              0.000001             break
                                      endif
    1              0.000001         endfor
    1              0.000001       endfor
    1              0.000001     endif
    6              0.000003   endfor
                            
    1              0.000004   redir => filetype_after
    1              0.000014   execute 'silent autocmd FileType' &filetype
    1              0.000003   redir END
                            
    1              0.000001   if reset_ftplugin
    1   0.000631   0.000370     filetype off
                            
    1              0.000007     if filetype_out =~# 'detection:ON'
    1   0.046248   0.000386       silent! filetype on
    1              0.000001     endif
                            
    1              0.000007     if filetype_out =~# 'plugin:ON'
    1   0.000843   0.000778       silent! filetype plugin on
    1              0.000001     endif
                            
    1              0.000006     if filetype_out =~# 'indent:ON'
    1   0.000803   0.000734       silent! filetype indent on
    1              0.000001     endif
                            
                                " Reload filetype plugins.
    1   0.084917   0.000008     let &l:filetype = &l:filetype
    1              0.000002   elseif filetype_before !=# filetype_after
                                execute 'doautocmd FileType' &filetype
                              endif
                            
    1              0.000004   if exists('g:loaded_neobundle')
    1   0.000107   0.000009     call neobundle#call_hook('on_post_source', bundles)
    1              0.000001   endif

FUNCTION  <SNR>139_NetrwEnew()
Called 7 times
Total time:   0.064598
 Self time:   0.007722

count  total (s)   self (s)
                            "  call Dfunc("s:NetrwEnew() a:0=".a:0." bufnr($)=".bufnr("$"))
                            "  call Decho("curdir<".((a:0>0)? a:1 : "")."> buf#".bufnr("%")."<".bufname("%").">")
                            
                              " grab a function-local-variable copy of buffer variables
                            "  call Decho("make function-local copy of netrw variables")
    7              0.000053   if exists("b:netrw_bannercnt")      |let netrw_bannercnt       = b:netrw_bannercnt      |endif
    7              0.000047   if exists("b:netrw_browser_active") |let netrw_browser_active  = b:netrw_browser_active |endif
    7              0.000031   if exists("b:netrw_cpf")            |let netrw_cpf             = b:netrw_cpf            |endif
    7              0.000040   if exists("b:netrw_curdir")         |let netrw_curdir          = b:netrw_curdir         |endif
    7              0.000034   if exists("b:netrw_explore_bufnr")  |let netrw_explore_bufnr   = b:netrw_explore_bufnr  |endif
    7              0.000033   if exists("b:netrw_explore_indx")   |let netrw_explore_indx    = b:netrw_explore_indx   |endif
    7              0.000031   if exists("b:netrw_explore_line")   |let netrw_explore_line    = b:netrw_explore_line   |endif
    7              0.000032   if exists("b:netrw_explore_list")   |let netrw_explore_list    = b:netrw_explore_list   |endif
    7              0.000034   if exists("b:netrw_explore_listlen")|let netrw_explore_listlen = b:netrw_explore_listlen|endif
    7              0.000031   if exists("b:netrw_explore_mtchcnt")|let netrw_explore_mtchcnt = b:netrw_explore_mtchcnt|endif
    7              0.000029   if exists("b:netrw_fname")          |let netrw_fname           = b:netrw_fname          |endif
    7              0.000031   if exists("b:netrw_lastfile")       |let netrw_lastfile        = b:netrw_lastfile       |endif
    7              0.000040   if exists("b:netrw_liststyle")      |let netrw_liststyle       = b:netrw_liststyle      |endif
    7              0.000029   if exists("b:netrw_method")         |let netrw_method          = b:netrw_method         |endif
    7              0.000027   if exists("b:netrw_option")         |let netrw_option          = b:netrw_option         |endif
    7              0.000041   if exists("b:netrw_prvdir")         |let netrw_prvdir          = b:netrw_prvdir         |endif
                            
    7   0.006067   0.000048   keepj call s:NetrwOptionRestore("w:")
                            "  call Decho("generate a buffer with keepjumps keepalt enew!")
    7              0.000023   let netrw_keepdiff= &l:diff
    7   0.048380   0.000812   keepj keepalt enew!
    7              0.000028   let &l:diff= netrw_keepdiff
                            "  call Decho("bufnr($)=".bufnr("$"))
    7   0.001798   0.000045   keepj call s:NetrwOptionSave("w:")
                            
                              " copy function-local-variables to buffer variable equivalents
                            "  call Decho("copy function-local variables back to buffer netrw variables")
    7              0.000048   if exists("netrw_bannercnt")      |let b:netrw_bannercnt       = netrw_bannercnt      |endif
    7              0.000041   if exists("netrw_browser_active") |let b:netrw_browser_active  = netrw_browser_active |endif
    7              0.000030   if exists("netrw_cpf")            |let b:netrw_cpf             = netrw_cpf            |endif
    7              0.000035   if exists("netrw_curdir")         |let b:netrw_curdir          = netrw_curdir         |endif
    7              0.000028   if exists("netrw_explore_bufnr")  |let b:netrw_explore_bufnr   = netrw_explore_bufnr  |endif
    7              0.000030   if exists("netrw_explore_indx")   |let b:netrw_explore_indx    = netrw_explore_indx   |endif
    7              0.000026   if exists("netrw_explore_line")   |let b:netrw_explore_line    = netrw_explore_line   |endif
    7              0.000026   if exists("netrw_explore_list")   |let b:netrw_explore_list    = netrw_explore_list   |endif
    7              0.000026   if exists("netrw_explore_listlen")|let b:netrw_explore_listlen = netrw_explore_listlen|endif
    7              0.000027   if exists("netrw_explore_mtchcnt")|let b:netrw_explore_mtchcnt = netrw_explore_mtchcnt|endif
    7              0.000025   if exists("netrw_fname")          |let b:netrw_fname           = netrw_fname          |endif
    7              0.000027   if exists("netrw_lastfile")       |let b:netrw_lastfile        = netrw_lastfile       |endif
    7              0.000035   if exists("netrw_liststyle")      |let b:netrw_liststyle       = netrw_liststyle      |endif
    7              0.000026   if exists("netrw_method")         |let b:netrw_method          = netrw_method         |endif
    7              0.000026   if exists("netrw_option")         |let b:netrw_option          = netrw_option         |endif
    7              0.000035   if exists("netrw_prvdir")         |let b:netrw_prvdir          = netrw_prvdir         |endif
                            
    7              0.000010   if a:0 > 0
    7              0.000016    let b:netrw_curdir= a:1
    7              0.000047    if b:netrw_curdir =~ '/$'
    6              0.000025     if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST
                                 file NetrwTreeListing
                                 set bt=nowrite noswf bh=hide
                                 nno <silent> <buffer> [	:sil call <SID>TreeListMove('[')<cr>
                                 nno <silent> <buffer> ]	:sil call <SID>TreeListMove(']')<cr>
                                else
    6   0.006940   0.005404      exe "sil! keepalt file ".fnameescape(b:netrw_curdir)
    6              0.000005     endif
    6              0.000003    endif
    7              0.000007   endif
                            
                            "  call Dret("s:NetrwEnew : buf#".bufnr("%")."<".bufname("%")."> expand(%)<".expand("%")."> expand(#)<".expand("#")."> bh=".&bh)

FUNCTION  <SNR>139_NetrwMenu()
Called 14 times
Total time:   0.017068
 Self time:   0.013739

count  total (s)   self (s)
                            
   14              0.000045   if !exists("g:NetrwMenuPriority")
    1              0.000002    let g:NetrwMenuPriority= 80
    1              0.000001   endif
                            
   14              0.000173   if has("menu") && has("gui_running") && &go =~# 'm' && g:netrw_menu
                            "   call Dfunc("NetrwMenu(domenu=".a:domenu.")")
                            
   14              0.000051    if !exists("s:netrw_menu_enabled") && a:domenu
                            "    call Decho("initialize menu")
    2              0.000006     let s:netrw_menu_enabled= 1
    2              0.000335     exe 'sil! menu '.g:NetrwMenuPriority.'.1      '.g:NetrwTopLvlMenu.'Help<tab><F1>	<F1>'
    2              0.000131     exe 'sil! menu '.g:NetrwMenuPriority.'.5      '.g:NetrwTopLvlMenu.'-Sep1-	:'
    2              0.000128     exe 'sil! menu '.g:NetrwMenuPriority.'.6      '.g:NetrwTopLvlMenu.'Go\ Up\ Directory<tab>-	-'
    2              0.000129     exe 'sil! menu '.g:NetrwMenuPriority.'.7      '.g:NetrwTopLvlMenu.'Apply\ Special\ Viewer<tab>x	x'
    2              0.000008     if g:netrw_dirhistmax > 0
    2              0.000213      exe 'sil! menu '.g:NetrwMenuPriority.'.8.1   '.g:NetrwTopLvlMenu.'Bookmarks\ and\ History.Bookmark\ Current\ Directory<tab>mb	mb'
    2              0.000134      exe 'sil! menu '.g:NetrwMenuPriority.'.8.4   '.g:NetrwTopLvlMenu.'Bookmarks\ and\ History.Goto\ Prev\ Dir\ (History)<tab>u	u'
    2              0.000133      exe 'sil! menu '.g:NetrwMenuPriority.'.8.5   '.g:NetrwTopLvlMenu.'Bookmarks\ and\ History.Goto\ Next\ Dir\ (History)<tab>U	U'
    2              0.000125      exe 'sil! menu '.g:NetrwMenuPriority.'.8.6   '.g:NetrwTopLvlMenu.'Bookmarks\ and\ History.List<tab>qb	qb'
    2              0.000003     else
                                 exe 'sil! menu '.g:NetrwMenuPriority.'.8     '.g:NetrwTopLvlMenu.'Bookmarks\ and\ History	:echo "(disabled)"'."\<cr>"
                                endif
    2              0.000183     exe 'sil! menu '.g:NetrwMenuPriority.'.9.1    '.g:NetrwTopLvlMenu.'Browsing\ Control.Horizontal\ Split<tab>o	o'
    2              0.000126     exe 'sil! menu '.g:NetrwMenuPriority.'.9.2    '.g:NetrwTopLvlMenu.'Browsing\ Control.Vertical\ Split<tab>v	v'
    2              0.000121     exe 'sil! menu '.g:NetrwMenuPriority.'.9.3    '.g:NetrwTopLvlMenu.'Browsing\ Control.New\ Tab<tab>t	t'
    2              0.000124     exe 'sil! menu '.g:NetrwMenuPriority.'.9.4    '.g:NetrwTopLvlMenu.'Browsing\ Control.Preview<tab>p	p'
    2              0.000123     exe 'sil! menu '.g:NetrwMenuPriority.'.9.5    '.g:NetrwTopLvlMenu.'Browsing\ Control.Edit\ File\ Hiding\ List<tab><ctrl-h>'."	\<c-h>'"
    2              0.000121     exe 'sil! menu '.g:NetrwMenuPriority.'.9.6    '.g:NetrwTopLvlMenu.'Browsing\ Control.Edit\ Sorting\ Sequence<tab>S	S'
    2              0.000125     exe 'sil! menu '.g:NetrwMenuPriority.'.9.7    '.g:NetrwTopLvlMenu.'Browsing\ Control.Quick\ Hide/Unhide\ Dot\ Files<tab>'."gh	gh"
    2              0.000123     exe 'sil! menu '.g:NetrwMenuPriority.'.9.8    '.g:NetrwTopLvlMenu.'Browsing\ Control.Refresh\ Listing<tab>'."<ctrl-l>	\<c-l>"
    2              0.000136     exe 'sil! menu '.g:NetrwMenuPriority.'.9.9    '.g:NetrwTopLvlMenu.'Browsing\ Control.Settings/Options<tab>:NetrwSettings	'.":NetrwSettings\<cr>"
    2              0.000128     exe 'sil! menu '.g:NetrwMenuPriority.'.10     '.g:NetrwTopLvlMenu.'Delete\ File/Directory<tab>D	D'
    2              0.000181     exe 'sil! menu '.g:NetrwMenuPriority.'.11.1   '.g:NetrwTopLvlMenu.'Edit\ File/Dir.Create\ New\ File<tab>%	%'
    2              0.000122     exe 'sil! menu '.g:NetrwMenuPriority.'.11.1   '.g:NetrwTopLvlMenu.'Edit\ File/Dir.In\ Current\ Window<tab><cr>	'."\<cr>"
    2              0.000112     exe 'sil! menu '.g:NetrwMenuPriority.'.11.2   '.g:NetrwTopLvlMenu.'Edit\ File/Dir.Preview\ File/Directory<tab>p	p'
    2              0.000115     exe 'sil! menu '.g:NetrwMenuPriority.'.11.3   '.g:NetrwTopLvlMenu.'Edit\ File/Dir.In\ Previous\ Window<tab>P	P'
    2              0.000115     exe 'sil! menu '.g:NetrwMenuPriority.'.11.4   '.g:NetrwTopLvlMenu.'Edit\ File/Dir.In\ New\ Window<tab>o	o'
    2              0.000119     exe 'sil! menu '.g:NetrwMenuPriority.'.11.5   '.g:NetrwTopLvlMenu.'Edit\ File/Dir.In\ New\ Vertical\ Window<tab>v	v'
    2              0.000170     exe 'sil! menu '.g:NetrwMenuPriority.'.12.1   '.g:NetrwTopLvlMenu.'Explore.Directory\ Name	:Explore '
    2              0.000132     exe 'sil! menu '.g:NetrwMenuPriority.'.12.2   '.g:NetrwTopLvlMenu.'Explore.Filenames\ Matching\ Pattern\ (curdir\ only)<tab>:Explore\ */	:Explore */'
    2              0.000122     exe 'sil! menu '.g:NetrwMenuPriority.'.12.2   '.g:NetrwTopLvlMenu.'Explore.Filenames\ Matching\ Pattern\ (+subdirs)<tab>:Explore\ **/	:Explore **/'
    2              0.000123     exe 'sil! menu '.g:NetrwMenuPriority.'.12.3   '.g:NetrwTopLvlMenu.'Explore.Files\ Containing\ String\ Pattern\ (curdir\ only)<tab>:Explore\ *//	:Explore *//'
    2              0.000125     exe 'sil! menu '.g:NetrwMenuPriority.'.12.4   '.g:NetrwTopLvlMenu.'Explore.Files\ Containing\ String\ Pattern\ (+subdirs)<tab>:Explore\ **//	:Explore **//'
    2              0.000129     exe 'sil! menu '.g:NetrwMenuPriority.'.12.4   '.g:NetrwTopLvlMenu.'Explore.Next\ Match<tab>:Nexplore	:Nexplore<cr>'
    2              0.000136     exe 'sil! menu '.g:NetrwMenuPriority.'.12.4   '.g:NetrwTopLvlMenu.'Explore.Prev\ Match<tab>:Pexplore	:Pexplore<cr>'
    2              0.000112     exe 'sil! menu '.g:NetrwMenuPriority.'.13     '.g:NetrwTopLvlMenu.'Make\ Subdirectory<tab>d	d'
    2              0.000165     exe 'sil! menu '.g:NetrwMenuPriority.'.14.1   '.g:NetrwTopLvlMenu.'Marked\ Files.Mark\ File<tab>mf	mf'
    2              0.000119     exe 'sil! menu '.g:NetrwMenuPriority.'.14.2   '.g:NetrwTopLvlMenu.'Marked\ Files.Mark\ Files\ by\ Regexp<tab>mr	mr'
    2              0.000112     exe 'sil! menu '.g:NetrwMenuPriority.'.14.3   '.g:NetrwTopLvlMenu.'Marked\ Files.Hide-Show-List\ Control<tab>a	a'
    2              0.000121     exe 'sil! menu '.g:NetrwMenuPriority.'.14.4   '.g:NetrwTopLvlMenu.'Marked\ Files.Copy\ To\ Target<tab>mc	mc'
    2              0.000108     exe 'sil! menu '.g:NetrwMenuPriority.'.14.5   '.g:NetrwTopLvlMenu.'Marked\ Files.Delete<tab>D	D'
    2              0.000108     exe 'sil! menu '.g:NetrwMenuPriority.'.14.6   '.g:NetrwTopLvlMenu.'Marked\ Files.Diff<tab>md	md'
    2              0.000107     exe 'sil! menu '.g:NetrwMenuPriority.'.14.7   '.g:NetrwTopLvlMenu.'Marked\ Files.Edit<tab>me	me'
    2              0.000115     exe 'sil! menu '.g:NetrwMenuPriority.'.14.8   '.g:NetrwTopLvlMenu.'Marked\ Files.Exe\ Cmd<tab>mx	mx'
    2              0.000112     exe 'sil! menu '.g:NetrwMenuPriority.'.14.9   '.g:NetrwTopLvlMenu.'Marked\ Files.Move\ To\ Target<tab>mm	mm'
    2              0.000110     exe 'sil! menu '.g:NetrwMenuPriority.'.14.10  '.g:NetrwTopLvlMenu.'Marked\ Files.Obtain<tab>O	O'
    2              0.000120     exe 'sil! menu '.g:NetrwMenuPriority.'.14.11  '.g:NetrwTopLvlMenu.'Marked\ Files.Print<tab>mp	mp'
    2              0.000125     exe 'sil! menu '.g:NetrwMenuPriority.'.14.12  '.g:NetrwTopLvlMenu.'Marked\ Files.Replace<tab>R	R'
    2              0.000123     exe 'sil! menu '.g:NetrwMenuPriority.'.14.13  '.g:NetrwTopLvlMenu.'Marked\ Files.Set\ Target<tab>mt	mt'
    2              0.000122     exe 'sil! menu '.g:NetrwMenuPriority.'.14.14  '.g:NetrwTopLvlMenu.'Marked\ Files.Tag<tab>mT	mT'
    2              0.000114     exe 'sil! menu '.g:NetrwMenuPriority.'.14.15  '.g:NetrwTopLvlMenu.'Marked\ Files.Zip/Unzip/Compress/Uncompress<tab>mz	mz'
    2              0.000103     exe 'sil! menu '.g:NetrwMenuPriority.'.15     '.g:NetrwTopLvlMenu.'Obtain\ File<tab>O	O'
    2              0.000237     exe 'sil! menu '.g:NetrwMenuPriority.'.16.1.1 '.g:NetrwTopLvlMenu.'Style.Listing.thin<tab>i	:let w:netrw_liststyle=0<cr><c-L>'
    2              0.000121     exe 'sil! menu '.g:NetrwMenuPriority.'.16.1.1 '.g:NetrwTopLvlMenu.'Style.Listing.long<tab>i	:let w:netrw_liststyle=1<cr><c-L>'
    2              0.000123     exe 'sil! menu '.g:NetrwMenuPriority.'.16.1.1 '.g:NetrwTopLvlMenu.'Style.Listing.wide<tab>i	:let w:netrw_liststyle=2<cr><c-L>'
    2              0.000121     exe 'sil! menu '.g:NetrwMenuPriority.'.16.1.1 '.g:NetrwTopLvlMenu.'Style.Listing.tree<tab>i	:let w:netrw_liststyle=3<cr><c-L>'
    2              0.000178     exe 'sil! menu '.g:NetrwMenuPriority.'.16.2.1 '.g:NetrwTopLvlMenu.'Style.Normal-Hide-Show.Show\ All<tab>a	:let g:netrw_hide=0<cr><c-L>'
    2              0.000121     exe 'sil! menu '.g:NetrwMenuPriority.'.16.2.3 '.g:NetrwTopLvlMenu.'Style.Normal-Hide-Show.Normal<tab>a	:let g:netrw_hide=1<cr><c-L>'
    2              0.000121     exe 'sil! menu '.g:NetrwMenuPriority.'.16.2.2 '.g:NetrwTopLvlMenu.'Style.Normal-Hide-Show.Hidden\ Only<tab>a	:let g:netrw_hide=2<cr><c-L>'
    2              0.000121     exe 'sil! menu '.g:NetrwMenuPriority.'.16.3   '.g:NetrwTopLvlMenu.'Style.Reverse\ Sorting\ Order<tab>'."r	r"
    2              0.000191     exe 'sil! menu '.g:NetrwMenuPriority.'.16.4.1 '.g:NetrwTopLvlMenu.'Style.Sorting\ Method.Name<tab>s       :let g:netrw_sort_by="name"<cr><c-L>'
    2              0.000123     exe 'sil! menu '.g:NetrwMenuPriority.'.16.4.2 '.g:NetrwTopLvlMenu.'Style.Sorting\ Method.Time<tab>s       :let g:netrw_sort_by="time"<cr><c-L>'
    2              0.000125     exe 'sil! menu '.g:NetrwMenuPriority.'.16.4.3 '.g:NetrwTopLvlMenu.'Style.Sorting\ Method.Size<tab>s       :let g:netrw_sort_by="size"<cr><c-L>'
    2              0.000105     exe 'sil! menu '.g:NetrwMenuPriority.'.17     '.g:NetrwTopLvlMenu.'Rename\ File/Directory<tab>R	R'
    2              0.000117     exe 'sil! menu '.g:NetrwMenuPriority.'.18     '.g:NetrwTopLvlMenu.'Set\ Current\ Directory<tab>c	c'
    2              0.000015     let s:netrw_menucnt= 28
    2   0.001820   0.000031     call s:NetrwBookmarkMenu() " provide some history!  uses priorities 2,3, reserves 4, 8.2.x
    2   0.001568   0.000028     call s:NetrwTgtMenu()      " let bookmarks and history be easy targets
                            
    2              0.000003    elseif !a:domenu
    2              0.000004     let s:netrwcnt = 0
    2              0.000004     let curwin     = winnr()
    2              0.000029     windo if getline(2) =~ "Netrw" | let s:netrwcnt= s:netrwcnt + 1 | endif
    2              0.000013     exe curwin."wincmd w"
                            
    2              0.000004     if s:netrwcnt <= 1
                            "     call Decho("clear menus")
    2              0.003112      exe 'sil! unmenu '.g:NetrwTopLvlMenu
                            "     call Decho('exe sil! unmenu '.g:NetrwTopLvlMenu.'*')
    2              0.000006      sil! unlet s:netrw_menu_enabled
    2              0.000002     endif
    2              0.000002    endif
                            "   call Dret("NetrwMenu")
   14              0.000023    return
                              endif
                            

FUNCTION  <SNR>142_treatConfig()
Called 3 times
Total time:   0.000050
 Self time:   0.000050

count  total (s)   self (s)
    3              0.000006   let config = a:config
                            
    3              0.000007   if has_key(config, 'indent_style')
    3              0.000007     if config["indent_style"] == 'space'
    3              0.000006       let config["indent_char"] = ' '
    3              0.000004     elseif config["indent_style"] == 'tab'
                                  let config["indent_char"] = '\t'
                                  " When the indent_char is tab, we always want to use 1 tab
                                  let config["indent_size"] = 1
                                endif
    3              0.000001   endif
                            
    3              0.000003   return config

FUNCTION  <SNR>46_buffer()
Called 72 times
Total time:   0.002156
 Self time:   0.001830

count  total (s)   self (s)
   72              0.000420   let buffer = {'#': bufnr(a:0 ? a:1 : '%')}
   72              0.000797   call extend(extend(buffer,s:buffer_prototype,'keep'),s:abstract_prototype,'keep')
   72   0.000739   0.000413   if buffer.getvar('git_dir') !=# ''
   72              0.000097     return buffer
                              endif
                              call s:throw('not a git repository: '.expand('%:p'))

FUNCTION  <SNR>139_SetRexDir()
Called 22 times
Total time:   0.000181
 Self time:   0.000181

count  total (s)   self (s)
                            "  call Dfunc("s:SetRexDir(islocal=".a:islocal." dirname<".a:dirname.">)")
   22              0.000076   let w:netrw_rexdir   = a:dirname
   22              0.000051   let w:netrw_rexlocal = a:islocal
                            "  call Dret("s:SetRexDir : win#".winnr()." ".(a:islocal? "local" : "remote")." dir: ".a:dirname)

FUNCTION  fugitive#is_git_dir()
Called 55 times
Total time:   0.002178
 Self time:   0.001656

count  total (s)   self (s)
   55   0.000881   0.000359   let path = s:sub(a:path, '[\/]$', '') . '/'
   55              0.001256   return isdirectory(path.'objects') && isdirectory(path.'refs') && getfsize(path.'HEAD') > 10

FUNCTION  47()
Called 10 times
Total time:   0.001003
 Self time:   0.000527

count  total (s)   self (s)
   10   0.000096   0.000034     if self.enabled()
   10   0.000313   0.000036         call self.reset(a:loclist)
   10   0.000143   0.000058         call syntastic#log#debug(g:SyntasticDebugNotifications, 'highlighting: refresh')
   10              0.000029         let buf = bufnr('')
   10   0.000115   0.000063         let issues = filter(a:loclist.filteredRaw(), 'v:val["bufnr"] == buf')
   10              0.000019         for item in issues
                                        let group = item['type'] ==? 'E' ? 'SyntasticError' : 'SyntasticWarning'
                            
                                        " The function `Syntastic_{filetype}_{checker}_GetHighlightRegex` is
                                        " used to override default highlighting.
                                        if has_key(item, 'hl')
                                            call matchadd(group, '\%' . item['lnum'] . 'l' . item['hl'])
                                        elseif get(item, 'col')
                                            let lastcol = col([item['lnum'], '$'])
                                            let lcol = min([lastcol, item['col']])
                            
                                            " a bug in vim can sometimes cause there to be no 'vcol' key,
                                            " so check for its existence
                                            let coltype = has_key(item, 'vcol') && item['vcol'] ? 'v' : 'c'
                            
                                            call matchadd(group, '\%' . item['lnum'] . 'l\%' . lcol . coltype)
                                        endif
                                    endfor
   10              0.000006     endif

FUNCTION  airline#parts#mode()
Called 20 times
Total time:   0.000109
 Self time:   0.000109

count  total (s)   self (s)
   20              0.000090   return get(w:, 'airline_current_mode', '')

FUNCTION  <SNR>103_get_hunks()
Called 20 times
Total time:   0.001060
 Self time:   0.000490

count  total (s)   self (s)
   20              0.000075   if empty(s:source_func)
                                if get(g:, 'loaded_signify', 0)
                                  let s:source_func = 's:get_hunks_signify'
                                elseif exists('*GitGutterGetHunkSummary')
                                  let s:source_func = 's:get_hunks_gitgutter'
                                else
                                  let s:source_func = 's:get_hunks_empty'
                                endif
                              endif
   20   0.000750   0.000180   return {s:source_func}()

FUNCTION  <SNR>46_buffer_setvar()
Called 16 times
Total time:   0.000098
 Self time:   0.000098

count  total (s)   self (s)
   16              0.000088   return setbufvar(self['#'],a:var,a:value)

FUNCTION  airline#extensions#quickfix#apply()
Called 45 times
Total time:   0.000568
 Self time:   0.000568

count  total (s)   self (s)
   45              0.000146   if &buftype == 'quickfix'
                                let w:airline_section_a = s:get_text()
                                let w:airline_section_b = '%{get(w:, "quickfix_title", "")}'
                                let w:airline_section_c = ''
                                let w:airline_section_x = ''
                              endif

FUNCTION  <SNR>103_get_hunks_signify()
Called 20 times
Total time:   0.000570
 Self time:   0.000257

count  total (s)   self (s)
   20   0.000453   0.000140   let hunks = sy#repo#get_stats()
   20              0.000064   if hunks[0] >= 0
   20              0.000026     return hunks
                              endif
                              return []

FUNCTION  <SNR>38_on_window_changed()
Called 45 times
Total time:   0.118597
 Self time:   0.000676

count  total (s)   self (s)
   45              0.000125   if pumvisible()
                                return
                              endif
   45   0.001148   0.000199   call <sid>init()
   45   0.117181   0.000209   call airline#update_statusline()

FUNCTION  airline#highlighter#add_separator()
Called 182 times
Total time:   0.071757
 Self time:   0.003707

count  total (s)   self (s)
  182              0.001347   let s:separators[a:from.a:to] = [a:from, a:to, a:inverse]
  182   0.070255   0.002205   call <sid>exec_separator({}, a:from, a:to, a:inverse, '')

FUNCTION  fugitive#head()
Called 20 times
Total time:   0.004448
 Self time:   0.000392

count  total (s)   self (s)
   20              0.000073   if !exists('b:git_dir')
                                return ''
                              endif
                            
   20   0.004312   0.000256   return s:repo().head(a:0 ? a:1 : 0)

FUNCTION  <SNR>139_NetrwMaps()
Called 12 times
Total time:   0.030436
 Self time:   0.030329

count  total (s)   self (s)
                            "  call Dfunc("s:NetrwMaps(islocal=".a:islocal.") b:netrw_curdir<".b:netrw_curdir.">")
                            
                              " set up Rexplore and [ 2-leftmouse-click -or- c-leftmouse ]
                            "  call Decho("(NetrwMaps) set up Rexplore command")
   12              0.000282   com! Rexplore if exists("w:netrw_rexlocal")|call s:NetrwRexplore(w:netrw_rexlocal,exists("w:netrw_rexdir")? w:netrw_rexdir : ".")|else|call netrw#ErrorMsg(s:WARNING,"not a former netrw window",79)|endif
   12              0.000029   if g:netrw_mousemaps && g:netrw_retmap
                            "   call Decho("(NetrwMaps) set up Rexplore 2-leftmouse")
                               if !hasmapto("<Plug>NetrwReturn")
                                if maparg("<2-leftmouse>","n") == "" || maparg("<2-leftmouse>","n") =~ '^-$'
                            "     call Decho("(NetrwMaps) making map for 2-leftmouse")
                                 nmap <unique> <silent> <2-leftmouse>	<Plug>NetrwReturn
                                elseif maparg("<c-leftmouse>","n") == ""
                            "     call Decho("(NetrwMaps) making map for c-leftmouse")
                                 nmap <unique> <silent> <c-leftmouse>	<Plug>NetrwReturn
                                endif
                               endif
                               nno <silent> <Plug>NetrwReturn	:Rexplore<cr>
                            "   call Decho("(NetrwMaps) made <Plug>NetrwReturn map")
                              endif
                            
   12              0.000014   if a:islocal
                            "   call Decho("(NetrwMaps) make local maps")
                               " local normal-mode maps
   12              0.000495    nnoremap <buffer> <silent> a		:call <SID>NetrwHide(1)<cr>
   12              0.000178    nnoremap <buffer> <silent> %		:call <SID>NetrwOpenFile(1)<cr>
   12              0.000172    nnoremap <buffer> <silent> c		:exe "keepjumps lcd ".fnameescape(b:netrw_curdir)<cr>
   12              0.000149    nnoremap <buffer> <silent> C		:let g:netrw_chgwin= winnr()<cr>
   12              0.000207    nnoremap <buffer> <silent> <cr>	:call netrw#LocalBrowseCheck(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord()))<cr>
   12              0.000155    nnoremap <buffer> <silent> d		:call <SID>NetrwMakeDir("")<cr>
   12              0.000200    nnoremap <buffer> <silent> -		:exe "norm! 0"<bar>call netrw#LocalBrowseCheck(<SID>NetrwBrowseChgDir(1,'../'))<cr>
   12              0.000208    nnoremap <buffer> <silent> gb	:<c-u>call <SID>NetrwBookHistHandler(1,b:netrw_curdir)<cr>
   12              0.000186    nnoremap <buffer> <silent> gd	:<c-u>call <SID>NetrwForceChgDir(1,<SID>NetrwGetWord())<cr>
   12              0.000176    nnoremap <buffer> <silent> gf	:<c-u>call <SID>NetrwForceFile(1,<SID>NetrwGetWord())<cr>
   12              0.000149    nnoremap <buffer> <silent> gh	:<c-u>call <SID>NetrwHidden(1)<cr>
   12              0.000168    nnoremap <buffer> <silent> gp	:<c-u>call <SID>NetrwChgPerm(1,b:netrw_curdir)<cr>
   12              0.000160    nnoremap <buffer> <silent> I		:call <SID>NetrwBannerCtrl(1)<cr>
   12              0.000144    nnoremap <buffer> <silent> i		:call <SID>NetrwListStyle(1)<cr>
   12              0.000170    nnoremap <buffer> <silent> mb	:<c-u>call <SID>NetrwBookHistHandler(0,b:netrw_curdir)<cr>
   12              0.000169    nnoremap <buffer> <silent> mB	:<c-u>call <SID>NetrwBookHistHandler(6,b:netrw_curdir)<cr>
   12              0.000151    nnoremap <buffer> <silent> mc	:<c-u>call <SID>NetrwMarkFileCopy(1)<cr>
   12              0.000145    nnoremap <buffer> <silent> md	:<c-u>call <SID>NetrwMarkFileDiff(1)<cr>
   12              0.000144    nnoremap <buffer> <silent> me	:<c-u>call <SID>NetrwMarkFileEdit(1)<cr>
   12              0.000168    nnoremap <buffer> <silent> mf	:<c-u>call <SID>NetrwMarkFile(1,<SID>NetrwGetWord())<cr>
   12              0.000166    nnoremap <buffer> <silent> mF	:<c-u>call <SID>NetrwUnmarkList(bufnr("%"),b:netrw_curdir)<cr>
   12              0.000145    nnoremap <buffer> <silent> mg	:<c-u>call <SID>NetrwMarkFileGrep(1)<cr>
   12              0.000144    nnoremap <buffer> <silent> mh	:<c-u>call <SID>NetrwMarkHideSfx(1)<cr>
   12              0.000152    nnoremap <buffer> <silent> mm	:<c-u>call <SID>NetrwMarkFileMove(1)<cr>
   12              0.000148    nnoremap <buffer> <silent> mp	:<c-u>call <SID>NetrwMarkFilePrint(1)<cr>
   12              0.000162    nnoremap <buffer> <silent> mr	:<c-u>call <SID>NetrwMarkFileRegexp(1)<cr>
   12              0.000146    nnoremap <buffer> <silent> ms	:<c-u>call <SID>NetrwMarkFileSource(1)<cr>
   12              0.000145    nnoremap <buffer> <silent> mt	:<c-u>call <SID>NetrwMarkFileTgt(1)<cr>
   12              0.000143    nnoremap <buffer> <silent> mT	:<c-u>call <SID>NetrwMarkFileTag(1)<cr>
   12              0.000147    nnoremap <buffer> <silent> mu	:<c-u>call <SID>NetrwUnMarkFile(1)<cr>
   12              0.000143    nnoremap <buffer> <silent> mx	:<c-u>call <SID>NetrwMarkFileExe(1)<cr>
   12              0.000171    nnoremap <buffer> <silent> mX	:<c-u>call <SID>NetrwMarkFileVimCmd(1)<cr>
   12              0.000148    nnoremap <buffer> <silent> mz	:<c-u>call <SID>NetrwMarkFileCompress(1)<cr>
   12              0.000148    nnoremap <buffer> <silent> O		:call <SID>NetrwObtain(1)<cr>
   12              0.000141    nnoremap <buffer> <silent> o		:call <SID>NetrwSplit(3)<cr>
   12              0.000193    nnoremap <buffer> <silent> p		:call <SID>NetrwPreview(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord(),1))<cr>
   12              0.000149    nnoremap <buffer> <silent> P		:call <SID>NetrwPrevWinOpen(1)<cr>
   12              0.000179    nnoremap <buffer> <silent> qb	:<c-u>call <SID>NetrwBookHistHandler(2,b:netrw_curdir)<cr>
   12              0.000172    nnoremap <buffer> <silent> qf	:<c-u>call <SID>NetrwFileInfo(1,<SID>NetrwGetWord())<cr>
   12              0.000163    nnoremap <buffer> <silent> qF	:<c-u>call <SID>NetrwMarkFileQFEL(1,getqflist())<cr>
   12              0.000284    nnoremap <buffer> <silent> r		:let g:netrw_sort_direction= (g:netrw_sort_direction =~ 'n')? 'r' : 'n'<bar>exe "norm! 0"<bar>call <SID>NetrwRefresh(1,<SID>NetrwBrowseChgDir(1,'./'))<cr>
   12              0.000146    nnoremap <buffer> <silent> s		:call <SID>NetrwSortStyle(1)<cr>
   12              0.000146    nnoremap <buffer> <silent> S		:call <SID>NetSortSequence(1)<cr>
   12              0.000139    nnoremap <buffer> <silent> t		:call <SID>NetrwSplit(4)<cr>
   12              0.000166    nnoremap <buffer> <silent> Tb	:<c-u>call <SID>NetrwSetTgt('b',v:count1)<cr>
   12              0.000153    nnoremap <buffer> <silent> Th	:<c-u>call <SID>NetrwSetTgt('h',v:count)<cr>
   12              0.000169    nnoremap <buffer> <silent> u		:<c-u>call <SID>NetrwBookHistHandler(4,expand("%"))<cr>
   12              0.000172    nnoremap <buffer> <silent> U		:<c-u>call <SID>NetrwBookHistHandler(5,expand("%"))<cr>
   12              0.000147    nnoremap <buffer> <silent> v		:call <SID>NetrwSplit(5)<cr>
   12              0.000204    nnoremap <buffer> <silent> x		:call netrw#NetrwBrowseX(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord(),0),0)"<cr>
   12              0.000188    nnoremap <buffer> <silent> X		:call <SID>NetrwLocalExecute(expand("<cword>"))"<cr>
                               " local insert-mode maps
   12              0.000191    inoremap <buffer> <silent> a		<c-o>:call <SID>NetrwHide(1)<cr>
   12              0.000190    inoremap <buffer> <silent> c		<c-o>:exe "keepjumps lcd ".fnameescape(b:netrw_curdir)<cr>
   12              0.000152    inoremap <buffer> <silent> C		<c-o>:let g:netrw_chgwin= winnr()<cr>
   12              0.000160    inoremap <buffer> <silent> %		<c-o>:call <SID>NetrwOpenFile(1)<cr>
   12              0.000213    inoremap <buffer> <silent> -		<c-o>:exe "norm! 0"<bar>call netrw#LocalBrowseCheck(<SID>NetrwBrowseChgDir(1,'../'))<cr>
   12              0.000202    inoremap <buffer> <silent> <cr>	<c-o>:call netrw#LocalBrowseCheck(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord()))<cr>
   12              0.000155    inoremap <buffer> <silent> d		<c-o>:call <SID>NetrwMakeDir("")<cr>
   12              0.000177    inoremap <buffer> <silent> gb	<c-o>:<c-u>call <SID>NetrwBookHistHandler(1,b:netrw_curdir)<cr>
   12              0.000160    inoremap <buffer> <silent> gh	<c-o>:<c-u>call <SID>NetrwHidden(1)<cr>
   12              0.000163    inoremap <buffer> <silent> gp	<c-o>:<c-u>call <SID>NetrwChgPerm(1,b:netrw_curdir)<cr>
   12              0.000149    inoremap <buffer> <silent> I		<c-o>:call <SID>NetrwBannerCtrl(1)<cr>
   12              0.000141    inoremap <buffer> <silent> i		<c-o>:call <SID>NetrwListStyle(1)<cr>
   12              0.000166    inoremap <buffer> <silent> mb	<c-o>:<c-u>call <SID>NetrwBookHistHandler(0,b:netrw_curdir)<cr>
   12              0.000193    inoremap <buffer> <silent> mB	<c-o>:<c-u>call <SID>NetrwBookHistHandler(6,b:netrw_curdir)<cr>
   12              0.000153    inoremap <buffer> <silent> mc	<c-o>:<c-u>call <SID>NetrwMarkFileCopy(1)<cr>
   12              0.000148    inoremap <buffer> <silent> md	<c-o>:<c-u>call <SID>NetrwMarkFileDiff(1)<cr>
   12              0.000161    inoremap <buffer> <silent> me	<c-o>:<c-u>call <SID>NetrwMarkFileEdit(1)<cr>
   12              0.000171    inoremap <buffer> <silent> mf	<c-o>:<c-u>call <SID>NetrwMarkFile(1,<SID>NetrwGetWord())<cr>
   12              0.000155    inoremap <buffer> <silent> mg	<c-o>:<c-u>call <SID>NetrwMarkFileGrep(1)<cr>
   12              0.000173    inoremap <buffer> <silent> mh	<c-o>:<c-u>call <SID>NetrwMarkHideSfx(1)<cr>
   12              0.000146    inoremap <buffer> <silent> mm	<c-o>:<c-u>call <SID>NetrwMarkFileMove(1)<cr>
   12              0.000152    inoremap <buffer> <silent> mp	<c-o>:<c-u>call <SID>NetrwMarkFilePrint(1)<cr>
   12              0.000157    inoremap <buffer> <silent> mr	<c-o>:<c-u>call <SID>NetrwMarkFileRegexp(1)<cr>
   12              0.000153    inoremap <buffer> <silent> ms	<c-o>:<c-u>call <SID>NetrwMarkFileSource(1)<cr>
   12              0.000157    inoremap <buffer> <silent> mT	<c-o>:<c-u>call <SID>NetrwMarkFileTag(1)<cr>
   12              0.000157    inoremap <buffer> <silent> mt	<c-o>:<c-u>call <SID>NetrwMarkFileTgt(1)<cr>
   12              0.000163    inoremap <buffer> <silent> mu	<c-o>:<c-u>call <SID>NetrwUnMarkFile(1)<cr>
   12              0.000153    inoremap <buffer> <silent> mx	<c-o>:<c-u>call <SID>NetrwMarkFileExe(1)<cr>
   12              0.000154    inoremap <buffer> <silent> mX	<c-o>:<c-u>call <SID>NetrwMarkFileVimCmd(1)<cr>
   12              0.000151    inoremap <buffer> <silent> mz	<c-o>:<c-u>call <SID>NetrwMarkFileCompress(1)<cr>
   12              0.000144    inoremap <buffer> <silent> O		<c-o>:call <SID>NetrwObtain(1)<cr>
   12              0.000144    inoremap <buffer> <silent> o		<c-o>:call <SID>NetrwSplit(3)<cr>
   12              0.000201    inoremap <buffer> <silent> p		<c-o>:call <SID>NetrwPreview(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord(),1))<cr>
   12              0.000145    inoremap <buffer> <silent> P		<c-o>:call <SID>NetrwPrevWinOpen(1)<cr>
   12              0.000180    inoremap <buffer> <silent> qb	<c-o>:<c-u>call <SID>NetrwBookHistHandler(2,b:netrw_curdir)<cr>
   12              0.000166    inoremap <buffer> <silent> qf	<c-o>:<c-u>call <SID>NetrwFileInfo(1,<SID>NetrwGetWord())<cr>
   12              0.000170    inoremap <buffer> <silent> qF	:<c-u>call <SID>NetrwMarkFileQFEL(1,getqflist())<cr>
   12              0.000273    inoremap <buffer> <silent> r		<c-o>:let g:netrw_sort_direction= (g:netrw_sort_direction =~ 'n')? 'r' : 'n'<bar>exe "norm! 0"<bar>call <SID>NetrwRefresh(1,<SID>NetrwBrowseChgDir(1,'./'))<cr>
   12              0.000155    inoremap <buffer> <silent> s		<c-o>:call <SID>NetrwSortStyle(1)<cr>
   12              0.000141    inoremap <buffer> <silent> S		<c-o>:call <SID>NetSortSequence(1)<cr>
   12              0.000147    inoremap <buffer> <silent> t		<c-o>:call <SID>NetrwSplit(4)<cr>
   12              0.000160    inoremap <buffer> <silent> Tb	<c-o>:<c-u>call <SID>NetrwSetTgt('b',v:count1)<cr>
   12              0.000156    inoremap <buffer> <silent> Th	<c-o>:<c-u>call <SID>NetrwSetTgt('h',v:count)<cr>
   12              0.000175    inoremap <buffer> <silent> u		<c-o>:<c-u>call <SID>NetrwBookHistHandler(4,expand("%"))<cr>
   12              0.000161    inoremap <buffer> <silent> U		<c-o>:<c-u>call <SID>NetrwBookHistHandler(5,expand("%"))<cr>
   12              0.000138    inoremap <buffer> <silent> v		<c-o>:call <SID>NetrwSplit(5)<cr>
   12              0.000192    inoremap <buffer> <silent> x		<c-o>:call netrw#NetrwBrowseX(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord(),0),0)"<cr>
   12              0.000784    if !hasmapto('<Plug>NetrwHideEdit')
   12              0.000129     nmap <buffer> <unique> <c-h> <Plug>NetrwHideEdit
   12              0.000160     imap <buffer> <unique> <c-h> <Plug>NetrwHideEdit
   12              0.000012    endif
   12              0.000212    nnoremap <buffer> <silent> <Plug>NetrwHideEdit	:call <SID>NetrwHideEdit(1)<cr>
   12              0.000664    if !hasmapto('<Plug>NetrwRefresh')
   12              0.000103     nmap <buffer> <unique> <c-l> <Plug>NetrwRefresh
   12              0.000145     imap <buffer> <unique> <c-l> <Plug>NetrwRefresh
   12              0.000011    endif
   12              0.000223    nnoremap <buffer> <silent> <Plug>NetrwRefresh		:call <SID>NetrwRefresh(1,<SID>NetrwBrowseChgDir(1,'./'))<cr>
   12              0.000192    if s:didstarstar || !mapcheck("<s-down>","n")
   12              0.000164     nnoremap <buffer> <silent> <s-down>	:Nexplore<cr>
   12              0.000153     inoremap <buffer> <silent> <s-down>	:Nexplore<cr>
   12              0.000008    endif
   12              0.000145    if s:didstarstar || !mapcheck("<s-up>","n")
   12              0.000149     nnoremap <buffer> <silent> <s-up>	:Pexplore<cr>
   12              0.000135     inoremap <buffer> <silent> <s-up>	:Pexplore<cr>
   12              0.000006    endif
   12              0.000097    let mapsafecurdir = escape(b:netrw_curdir, s:netrw_map_escape)
   12              0.000021    if g:netrw_mousemaps == 1
   12              0.000196     nmap <buffer> <leftmouse>   <Plug>NetrwLeftmouse
   12              0.000244     nno  <buffer> <silent>	<Plug>NetrwLeftmouse	<leftmouse>:call <SID>NetrwLeftmouse(1)<cr>
   12              0.000175     nmap <buffer> <s-rightdrag>	<Plug>NetrwRightdrag
   12              0.000211     nno  <buffer> <silent>	<Plug>NetrwRightdrag	<leftmouse>:call <SID>NetrwRightdrag(1)<cr>
   12              0.000168     nmap <buffer> <middlemouse>	<Plug>NetrwMiddlemouse
   12              0.000201     nno  <buffer> <silent>	<Plug>NetrwMiddlemouse	<leftmouse>:call <SID>NetrwPrevWinOpen(1)<cr>
   12              0.000173     nmap <buffer> <s-leftmouse>	<Plug>NetrwSLeftmouse
   12              0.000222     nno  <buffer> <silent>	<Plug>NetrwSLeftmouse   <leftmouse>:call <SID>NetrwMarkFile(1,<SID>NetrwGetWord())<cr>
   12              0.000162     nmap <buffer> <2-leftmouse>	<Plug>Netrw2Leftmouse
   12              0.000143     nmap <buffer> <silent>	<Plug>Netrw2Leftmouse	-
   12              0.000166     imap <buffer> <leftmouse>	<Plug>ILeftmouse
   12              0.000215     ino  <buffer> <silent>	<Plug>ILeftmouse	<c-o><leftmouse><c-o>:call <SID>NetrwLeftmouse(1)<cr>
   12              0.000161     imap <buffer> <middlemouse>	<Plug>IMiddlemouse
   12              0.000205     ino  <buffer> <silent>	<Plug>IMiddlemouse	<c-o><leftmouse><c-o>:call <SID>NetrwPrevWinOpen(1)<cr>
   12              0.000162     imap <buffer> <s-leftmouse>	<Plug>ISLeftmouse
   12              0.000218     ino  <buffer> <silent>	<Plug>ISLeftmouse	<c-o><leftmouse><c-o>:call <SID>NetrwMarkFile(1,<SID>NetrwGetWord())<cr>
   12              0.000296     exe 'nnoremap <buffer> <silent> <rightmouse>  <leftmouse>:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
   12              0.000292     exe 'vnoremap <buffer> <silent> <rightmouse>  <leftmouse>:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
   12              0.000278     exe 'inoremap <buffer> <silent> <rightmouse>  <c-o><leftmouse><c-o>:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
   12              0.000010    endif
   12              0.000247    exe 'nnoremap <buffer> <silent> <del>	:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
   12              0.000242    exe 'nnoremap <buffer> <silent> D		:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
   12              0.000253    exe 'nnoremap <buffer> <silent> R		:call <SID>NetrwLocalRename("'.mapsafecurdir.'")<cr>'
   12              0.000239    exe 'nnoremap <buffer> <silent> <Leader>m	:call <SID>NetrwMakeDir("")<cr>'
   12              0.000254    exe 'vnoremap <buffer> <silent> <del>	:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
   12              0.000241    exe 'vnoremap <buffer> <silent> D		:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
   12              0.000232    exe 'vnoremap <buffer> <silent> R		:call <SID>NetrwLocalRename("'.mapsafecurdir.'")<cr>'
   12              0.000252    exe 'inoremap <buffer> <silent> <del>	<c-o>:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
   12              0.000235    exe 'inoremap <buffer> <silent> D		<c-o>:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
   12              0.000235    exe 'inoremap <buffer> <silent> R		<c-o>:call <SID>NetrwLocalRename("'.mapsafecurdir.'")<cr>'
   12              0.000229    exe 'inoremap <buffer> <silent> <Leader>m	<c-o>:call <SID>NetrwMakeDir("")<cr>'
   12              0.000165    nnoremap <buffer> <F1>		:he netrw-quickhelp<cr>
                            
   12              0.000024   else " remote
                            "   call Decho("(NetrwMaps) make remote maps")
                               call s:RemotePathAnalysis(b:netrw_curdir)
                               " remote normal-mode maps
                               nnoremap <buffer> <silent> <cr>	:call <SID>NetrwBrowse(0,<SID>NetrwBrowseChgDir(0,<SID>NetrwGetWord()))<cr>
                               nnoremap <buffer> <silent> <c-l>	:call <SID>NetrwRefresh(0,<SID>NetrwBrowseChgDir(0,'./'))<cr>
                               nnoremap <buffer> <silent> -		:exe "norm! 0"<bar>call <SID>NetrwBrowse(0,<SID>NetrwBrowseChgDir(0,'../'))<cr>
                               nnoremap <buffer> <silent> a		:call <SID>NetrwHide(0)<cr>
                               nnoremap <buffer> <silent> mb	:<c-u>call <SID>NetrwBookHistHandler(0,b:netrw_curdir)<cr>
                               nnoremap <buffer> <silent> mc	:<c-u>call <SID>NetrwMarkFileCopy(0)<cr>
                               nnoremap <buffer> <silent> md	:<c-u>call <SID>NetrwMarkFileDiff(0)<cr>
                               nnoremap <buffer> <silent> me	:<c-u>call <SID>NetrwMarkFileEdit(0)<cr>
                               nnoremap <buffer> <silent> mf	:<c-u>call <SID>NetrwMarkFile(0,<SID>NetrwGetWord())<cr>
                               nnoremap <buffer> <silent> mF	:<c-u>call <SID>NetrwUnmarkList(bufnr("%"),b:netrw_curdir)<cr>
                               nnoremap <buffer> <silent> mg	:<c-u>call <SID>NetrwMarkFileGrep(0)<cr>
                               nnoremap <buffer> <silent> mh	:<c-u>call <SID>NetrwMarkHideSfx(0)<cr>
                               nnoremap <buffer> <silent> mm	:<c-u>call <SID>NetrwMarkFileMove(0)<cr>
                               nnoremap <buffer> <silent> mp	:<c-u>call <SID>NetrwMarkFilePrint(0)<cr>
                               nnoremap <buffer> <silent> mr	:<c-u>call <SID>NetrwMarkFileRegexp(0)<cr>
                               nnoremap <buffer> <silent> ms	:<c-u>call <SID>NetrwMarkFileSource(0)<cr>
                               nnoremap <buffer> <silent> mt	:<c-u>call <SID>NetrwMarkFileTgt(0)<cr>
                               nnoremap <buffer> <silent> mT	:<c-u>call <SID>NetrwMarkFileTag(0)<cr>
                               nnoremap <buffer> <silent> mu	:<c-u>call <SID>NetrwUnMarkFile(0)<cr>
                               nnoremap <buffer> <silent> mx	:<c-u>call <SID>NetrwMarkFileExe(0)<cr>
                               nnoremap <buffer> <silent> mX	:<c-u>call <SID>NetrwMarkFileVimCmd(0)<cr>
                               nnoremap <buffer> <silent> mz	:<c-u>call <SID>NetrwMarkFileCompress(0)<cr>
                               nnoremap <buffer> <silent> gb	:<c-u>call <SID>NetrwBookHistHandler(1,b:netrw_curdir)<cr>
                               nnoremap <buffer> <silent> gd	:<c-u>call <SID>NetrwForceChgDir(0,<SID>NetrwGetWord())<cr>
                               nnoremap <buffer> <silent> gf	:<c-u>call <SID>NetrwForceFile(0,<SID>NetrwGetWord())<cr>
                               nnoremap <buffer> <silent> gh	:<c-u>call <SID>NetrwHidden(0)<cr>
                               nnoremap <buffer> <silent> gp	:<c-u>call <SID>NetrwChgPerm(0,b:netrw_curdir)<cr>
                               nnoremap <buffer> <silent> C		:let g:netrw_chgwin= winnr()<cr>
                               nnoremap <buffer> <silent> i		:call <SID>NetrwListStyle(0)<cr>
                               nnoremap <buffer> <silent> I		:call <SID>NetrwBannerCtrl(1)<cr>
                               nnoremap <buffer> <silent> o		:call <SID>NetrwSplit(0)<cr>
                               nnoremap <buffer> <silent> O		:call <SID>NetrwObtain(0)<cr>
                               nnoremap <buffer> <silent> p		:call <SID>NetrwPreview(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord(),1))<cr>
                               nnoremap <buffer> <silent> P		:call <SID>NetrwPrevWinOpen(0)<cr>
                               nnoremap <buffer> <silent> qb	:<c-u>call <SID>NetrwBookHistHandler(2,b:netrw_curdir)<cr>
                               nnoremap <buffer> <silent> mB	:<c-u>call <SID>NetrwBookHistHandler(6,b:netrw_curdir)<cr>
                               nnoremap <buffer> <silent> qf	:<c-u>call <SID>NetrwFileInfo(0,<SID>NetrwGetWord())<cr>
                               nnoremap <buffer> <silent> qF	:<c-u>call <SID>NetrwMarkFileQFEL(0,getqflist())<cr>
                               nnoremap <buffer> <silent> r		:let g:netrw_sort_direction= (g:netrw_sort_direction =~ 'n')? 'r' : 'n'<bar>exe "norm! 0"<bar>call <SID>NetrwBrowse(0,<SID>NetrwBrowseChgDir(0,'./'))<cr>
                               nnoremap <buffer> <silent> s		:call <SID>NetrwSortStyle(0)<cr>
                               nnoremap <buffer> <silent> S		:call <SID>NetSortSequence(0)<cr>
                               nnoremap <buffer> <silent> t		:call <SID>NetrwSplit(1)<cr>
                               nnoremap <buffer> <silent> Tb	:<c-u>call <SID>NetrwSetTgt('b',v:count1)<cr>
                               nnoremap <buffer> <silent> Th	:<c-u>call <SID>NetrwSetTgt('h',v:count)<cr>
                               nnoremap <buffer> <silent> u		:<c-u>call <SID>NetrwBookHistHandler(4,b:netrw_curdir)<cr>
                               nnoremap <buffer> <silent> U		:<c-u>call <SID>NetrwBookHistHandler(5,b:netrw_curdir)<cr>
                               nnoremap <buffer> <silent> v		:call <SID>NetrwSplit(2)<cr>
                               nnoremap <buffer> <silent> x		:call netrw#NetrwBrowseX(<SID>NetrwBrowseChgDir(0,<SID>NetrwGetWord()),1)<cr>
                               nnoremap <buffer> <silent> %		:call <SID>NetrwOpenFile(0)<cr>
                               " remote insert-mode maps
                               inoremap <buffer> <silent> <cr>	<c-o>:call <SID>NetrwBrowse(0,<SID>NetrwBrowseChgDir(0,<SID>NetrwGetWord()))<cr>
                               inoremap <buffer> <silent> <c-l>	<c-o>:call <SID>NetrwRefresh(0,<SID>NetrwBrowseChgDir(0,'./'))<cr>
                               inoremap <buffer> <silent> -		<c-o>:exe "norm! 0"<bar>call <SID>NetrwBrowse(0,<SID>NetrwBrowseChgDir(0,'../'))<cr>
                               inoremap <buffer> <silent> a		<c-o>:call <SID>NetrwHide(0)<cr>
                               inoremap <buffer> <silent> mb	<c-o>:<c-u>call <SID>NetrwBookHistHandler(0,b:netrw_curdir)<cr>
                               inoremap <buffer> <silent> mc	<c-o>:<c-u>call <SID>NetrwMarkFileCopy(0)<cr>
                               inoremap <buffer> <silent> md	<c-o>:<c-u>call <SID>NetrwMarkFileDiff(0)<cr>
                               inoremap <buffer> <silent> me	<c-o>:<c-u>call <SID>NetrwMarkFileEdit(0)<cr>
                               inoremap <buffer> <silent> mf	<c-o>:<c-u>call <SID>NetrwMarkFile(0,<SID>NetrwGetWord())<cr>
                               inoremap <buffer> <silent> mg	<c-o>:<c-u>call <SID>NetrwMarkFileGrep(0)<cr>
                               inoremap <buffer> <silent> mh	<c-o>:<c-u>call <SID>NetrwMarkHideSfx(0)<cr>
                               inoremap <buffer> <silent> mm	<c-o>:<c-u>call <SID>NetrwMarkFileMove(0)<cr>
                               inoremap <buffer> <silent> mp	<c-o>:<c-u>call <SID>NetrwMarkFilePrint(0)<cr>
                               inoremap <buffer> <silent> mr	<c-o>:<c-u>call <SID>NetrwMarkFileRegexp(0)<cr>
                               inoremap <buffer> <silent> ms	<c-o>:<c-u>call <SID>NetrwMarkFileSource(0)<cr>
                               inoremap <buffer> <silent> mt	<c-o>:<c-u>call <SID>NetrwMarkFileTgt(0)<cr>
                               inoremap <buffer> <silent> mT	<c-o>:<c-u>call <SID>NetrwMarkFileTag(0)<cr>
                               inoremap <buffer> <silent> mu	<c-o>:<c-u>call <SID>NetrwUnMarkFile(0)<cr>
                               inoremap <buffer> <silent> mx	<c-o>:<c-u>call <SID>NetrwMarkFileExe(0)<cr>
                               inoremap <buffer> <silent> mX	<c-o>:<c-u>call <SID>NetrwMarkFileVimCmd(0)<cr>
                               inoremap <buffer> <silent> mz	<c-o>:<c-u>call <SID>NetrwMarkFileCompress(0)<cr>
                               inoremap <buffer> <silent> gb	<c-o>:<c-u>call <SID>NetrwBookHistHandler(1,b:netrw_curdir)<cr>
                               inoremap <buffer> <silent> gh	<c-o>:<c-u>call <SID>NetrwHidden(0)<cr>
                               inoremap <buffer> <silent> gp	<c-o>:<c-u>call <SID>NetrwChgPerm(0,b:netrw_curdir)<cr>
                               inoremap <buffer> <silent> C		<c-o>:let g:netrw_chgwin= winnr()<cr>
                               inoremap <buffer> <silent> i		<c-o>:call <SID>NetrwListStyle(0)<cr>
                               inoremap <buffer> <silent> I		<c-o>:call <SID>NetrwBannerCtrl(1)<cr>
                               inoremap <buffer> <silent> o		<c-o>:call <SID>NetrwSplit(0)<cr>
                               inoremap <buffer> <silent> O		<c-o>:call <SID>NetrwObtain(0)<cr>
                               inoremap <buffer> <silent> p		<c-o>:call <SID>NetrwPreview(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord(),1))<cr>
                               inoremap <buffer> <silent> P		<c-o>:call <SID>NetrwPrevWinOpen(0)<cr>
                               inoremap <buffer> <silent> qb	<c-o>:<c-u>call <SID>NetrwBookHistHandler(2,b:netrw_curdir)<cr>
                               inoremap <buffer> <silent> mB	<c-o>:<c-u>call <SID>NetrwBookHistHandler(6,b:netrw_curdir)<cr>
                               inoremap <buffer> <silent> qf	<c-o>:<c-u>call <SID>NetrwFileInfo(0,<SID>NetrwGetWord())<cr>
                               inoremap <buffer> <silent> qF	:<c-u>call <SID>NetrwMarkFileQFEL(0,getqflist())<cr>
                               inoremap <buffer> <silent> r		<c-o>:let g:netrw_sort_direction= (g:netrw_sort_direction =~ 'n')? 'r' : 'n'<bar>exe "norm! 0"<bar>call <SID>NetrwBrowse(0,<SID>NetrwBrowseChgDir(0,'./'))<cr>
                               inoremap <buffer> <silent> s		<c-o>:call <SID>NetrwSortStyle(0)<cr>
                               inoremap <buffer> <silent> S		<c-o>:call <SID>NetSortSequence(0)<cr>
                               inoremap <buffer> <silent> t		<c-o>:call <SID>NetrwSplit(1)<cr>
                               inoremap <buffer> <silent> Tb	<c-o>:<c-u>call <SID>NetrwSetTgt('b',v:count1)<cr>
                               inoremap <buffer> <silent> Th	<c-o>:<c-u>call <SID>NetrwSetTgt('h',v:count)<cr>
                               inoremap <buffer> <silent> u		<c-o>:<c-u>call <SID>NetrwBookHistHandler(4,b:netrw_curdir)<cr>
                               inoremap <buffer> <silent> U		<c-o>:<c-u>call <SID>NetrwBookHistHandler(5,b:netrw_curdir)<cr>
                               inoremap <buffer> <silent> v		<c-o>:call <SID>NetrwSplit(2)<cr>
                               inoremap <buffer> <silent> x		<c-o>:call netrw#NetrwBrowseX(<SID>NetrwBrowseChgDir(0,<SID>NetrwGetWord()),1)<cr>
                               inoremap <buffer> <silent> %		<c-o>:call <SID>NetrwOpenFile(0)<cr>
                               if !hasmapto('<Plug>NetrwHideEdit')
                                nmap <buffer> <c-h> <Plug>NetrwHideEdit
                                imap <buffer> <c-h> <Plug>NetrwHideEdit
                               endif
                               nnoremap <buffer> <silent> <Plug>NetrwHideEdit	:call <SID>NetrwHideEdit(0)<cr>
                               if !hasmapto('<Plug>NetrwRefresh')
                                nmap <buffer> <c-l> <Plug>NetrwRefresh
                                imap <buffer> <c-l> <Plug>NetrwRefresh
                               endif
                            
                               let mapsafepath     = escape(s:path, s:netrw_map_escape)
                               let mapsafeusermach = escape(s:user.s:machine, s:netrw_map_escape)
                            
                               nnoremap <buffer> <silent> <Plug>NetrwRefresh	:call <SID>NetrwRefresh(0,<SID>NetrwBrowseChgDir(0,'./'))<cr>
                               if g:netrw_mousemaps == 1
                                nmap <leftmouse>		<Plug>NetrwLeftmouse
                                nno <buffer> <silent>	<Plug>NetrwLeftmouse	<leftmouse>:call <SID>NetrwLeftmouse(0)<cr>
                                nmap <buffer> <leftdrag>	<Plug>NetrwLeftdrag
                                nno  <buffer> <silent>	<Plug>NetrwLeftdrag	:call <SID>NetrwLeftdrag(0)<cr>
                                nmap <middlemouse>		<Plug>NetrwMiddlemouse
                                nno  <buffer> <silent>	<middlemouse>		<Plug>NetrwMiddlemouse <leftmouse>:call <SID>NetrwPrevWinOpen(0)<cr>
                                nmap <buffer> <s-leftmouse>	<Plug>NetrwSLeftmouse
                                nno  <buffer> <silent>	<Plug>NetrwSLeftmouse   <leftmouse>:call <SID>NetrwMarkFile(0,<SID>NetrwGetWord())<cr>
                                nmap <buffer> <2-leftmouse>	<Plug>Netrw2Leftmouse
                                nmap <buffer> <silent>	<Plug>Netrw2Leftmouse	-
                                imap <buffer> <leftmouse>	<Plug>ILeftmouse
                                ino  <buffer> <silent>	<Plug>ILeftmouse	<c-o><leftmouse><c-o>:call <SID>NetrwLeftmouse(0)<cr>
                                imap <buffer> <middlemouse>	<Plug>IMiddlemouse
                                ino  <buffer> <silent>	<Plug>IMiddlemouse	<c-o><leftmouse><c-o>:call <SID>NetrwPrevWinOpen(0)<cr>
                                imap <buffer> <s-leftmouse>	<Plug>ISLeftmouse
                                ino  <buffer> <silent>	<Plug>ISLeftmouse	<c-o><leftmouse><c-o>:call <SID>NetrwMarkFile(0,<SID>NetrwGetWord())<cr>
                                exe 'nnoremap <buffer> <silent> <rightmouse> <leftmouse>:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
                                exe 'vnoremap <buffer> <silent> <rightmouse> <leftmouse>:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
                                exe 'inoremap <buffer> <silent> <rightmouse> <c-o><leftmouse><c-o>:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
                               endif
                               exe 'nnoremap <buffer> <silent> <del>	:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
                               exe 'nnoremap <buffer> <silent> d		:call <SID>NetrwMakeDir("'.mapsafeusermach.'")<cr>'
                               exe 'nnoremap <buffer> <silent> D		:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
                               exe 'nnoremap <buffer> <silent> R		:call <SID>NetrwRemoteRename("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
                               exe 'vnoremap <buffer> <silent> <del>	:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
                               exe 'vnoremap <buffer> <silent> D		:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
                               exe 'vnoremap <buffer> <silent> R		:call <SID>NetrwRemoteRename("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
                               exe 'inoremap <buffer> <silent> <del>	<c-o>:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
                               exe 'inoremap <buffer> <silent> d		<c-o>:call <SID>NetrwMakeDir("'.mapsafeusermach.'")<cr>'
                               exe 'inoremap <buffer> <silent> D		<c-o>:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
                               exe 'inoremap <buffer> <silent> R		<c-o>:call <SID>NetrwRemoteRename("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
                               nnoremap <buffer> <F1>			:he netrw-quickhelp<cr>
                               inoremap <buffer> <F1>			<c-o>:he netrw-quickhelp<cr>
                              endif
                            
   12   0.000226   0.000119   keepj call s:SetRexDir(a:islocal,b:netrw_curdir)
                            
                            "  call Dret("s:NetrwMaps")

FUNCTION  <SNR>139_ComposePath()
Called 34 times
Total time:   0.002957
 Self time:   0.002957

count  total (s)   self (s)
                            "  call Dfunc("s:ComposePath(base<".a:base."> subdir<".a:subdir.">)")
                            
   34              0.000147   if has("amiga")
                            "   call Decho("amiga")
                               let ec = a:base[s:Strlen(a:base)-1]
                               if ec != '/' && ec != ':'
                                let ret = a:base . "/" . a:subdir
                               else
                                let ret = a:base . a:subdir
                               endif
                            
                              elseif a:subdir =~ '^\a:[/\\][^/\\]' && (has("win32") || has("win95") || has("win64") || has("win16"))
                            "   call Decho("windows")
                               let ret= a:subdir
                            
                              elseif a:base =~ '^\a:[/\\][^/\\]' && (has("win32") || has("win95") || has("win64") || has("win16"))
                            "   call Decho("windows")
                               if a:base =~ '[/\\]$'
                                let ret= a:base.a:subdir
                               else
                                let ret= a:base."/".a:subdir
                               endif
                            
                              elseif a:base =~ '^\a\+://'
                            "   call Decho("remote linux/macos")
                               let urlbase = substitute(a:base,'^\(\a\+://.\{-}/\)\(.*\)$','\1','')
                               let curpath = substitute(a:base,'^\(\a\+://.\{-}/\)\(.*\)$','\2','')
                               if a:subdir == '../'
                                if curpath =~ '[^/]/[^/]\+/$'
                                 let curpath= substitute(curpath,'[^/]\+/$','','')
                                else
                                 let curpath=""
                                endif
                                let ret= urlbase.curpath
                               else
                                let ret= urlbase.curpath.a:subdir
                               endif
                            "   call Decho("urlbase<".urlbase.">")
                            "   call Decho("curpath<".curpath.">")
                            "   call Decho("ret<".ret.">")
                            
                              else
                            "   call Decho("local linux/macos")
   34              0.000294    let ret = substitute(a:base."/".a:subdir,"//","/","g")
   34              0.000148    if a:base =~ '^//'
                                " keeping initial '//' for the benefit of network share listing support
                                let ret= '/'.ret
                               endif
   34              0.000127    let ret= simplify(ret)
   34              0.000025   endif
                            
                            "  call Dret("s:ComposePath ".ret)
   34              0.000042   return ret

FUNCTION  sy#sign#remove_all()
Called 2 times
Total time:   0.000062
 Self time:   0.000062

count  total (s)   self (s)
    2              0.000008   if g:signify_sign_overwrite
                                execute 'sign unplace * file='. a:path
                              else
    2              0.000010     for hunk in g:sy[a:path].hunks
                                  for id in hunk.ids
                                    execute 'sign unplace' id
                                  endfor
                                endfor
    2              0.000001   endif
                            
    2              0.000010   let g:sy[a:path].hunks = []
    2              0.000008   let g:sy[a:path].stats = [0, 0, 0]

FUNCTION  neobundle#config#get_neobundles()
Called 19 times
Total time:   0.000177
 Self time:   0.000177

count  total (s)   self (s)
   19              0.000168   return values(s:neobundles)

FUNCTION  neobundle#config#get_autoload_bundles()
Called 49 times
Total time:   0.006800
 Self time:   0.006800

count  total (s)   self (s)
   49              0.006748   return filter(values(s:neobundles), "!v:val.sourced && v:val.rtp != '' && v:val.lazy")

FUNCTION  indent_guides#clear_matches()
Called 46 times
Total time:   0.001464
 Self time:   0.001134

count  total (s)   self (s)
   46   0.000533   0.000203   call indent_guides#init_matches()
   46              0.000126   if !empty(w:indent_guides_matches)
                                let l:index = 0
                                for l:match_id in w:indent_guides_matches
                                  try
                                    call matchdelete(l:match_id)
                                  catch /E803:/
                                    " Do nothing
                                  endtry
                                  call remove(w:indent_guides_matches, l:index)
                                  let l:index += l:index
                                endfor
                              endif

FUNCTION  <SNR>139_NetrwListSettings()
Called 12 times
Total time:   0.004594
 Self time:   0.002735

count  total (s)   self (s)
                            "  call Dfunc("s:NetrwListSettings(islocal=".a:islocal.")")
   12              0.000056   let fname= bufname("%")
                            "  call Decho("(NetrwListSettings) setl bt=nofile nobl ma nonu nowrap noro")
   12   0.001186   0.000259   setl bt=nofile nobl ma nonu nowrap noro
                            "  call Decho("(NetrwListSettings) exe sil! keepalt file ".fnameescape(fname))
   12   0.002294   0.001362   exe "sil! keepalt file ".fnameescape(fname)
   12              0.000026   if g:netrw_use_noswf
                               setl noswf
                              endif
                            "  call Decho("(NetrwListSettings) exe setl ts=".(g:netrw_maxfilenamelen+1))
   12              0.000122   exe "setl ts=".(g:netrw_maxfilenamelen+1)
   12              0.000686   setl isk+=.,~,-
   12              0.000032   if g:netrw_fastbrowse > a:islocal
                               setl bh=hide
                              else
   12              0.000057    setl bh=delete
   12              0.000009   endif
                            "  call Dret("s:NetrwListSettings")

FUNCTION  airline#extensions#tabline#get_buffer_name()
Called 66 times
Total time:   0.007234
 Self time:   0.000757

count  total (s)   self (s)
   66   0.007189   0.000712   return airline#extensions#tabline#formatters#{s:formatter}(a:nr, get(s:, 'current_buffer_list', []))

FUNCTION  airline#statusline()
Called 139 times
Total time:   0.002795
 Self time:   0.002795

count  total (s)   self (s)
  139              0.001203   if has_key(s:contexts, a:winnr)
  139              0.001262     return '%{airline#check_mode('.a:winnr.')}'.s:contexts[a:winnr].line
                              endif
                            
                              " in rare circumstances this happens...see #276
                              return ''

FUNCTION  fugitive#reload_status()
Called 3 times
Total time:   0.000876
 Self time:   0.000876

count  total (s)   self (s)
    3              0.000043   if exists('s:reloading_status')
                                return
                              endif
    3              0.000010   try
    3              0.000026     let s:reloading_status = 1
    3              0.000019     let mytab = tabpagenr()
    9              0.000053     for tab in [mytab] + range(1,tabpagenr('$'))
   12              0.000053       for winnr in range(1,tabpagewinnr(tab,'$'))
    6              0.000079         if getbufvar(tabpagebuflist(tab)[winnr-1],'fugitive_type') ==# 'index'
                                      execute 'tabnext '.tab
                                      if winnr != winnr()
                                        execute winnr.'wincmd w'
                                        let restorewinnr = 1
                                      endif
                                      try
                                        if !&modified
                                          call s:BufReadIndex()
                                        endif
                                      finally
                                        if exists('restorewinnr')
                                          wincmd p
                                        endif
                                        execute 'tabnext '.mytab
                                      endtry
                                    endif
    6              0.000007       endfor
    6              0.000009     endfor
    3              0.000007   finally
    3              0.000013     unlet! s:reloading_status
    3              0.000004   endtry

FUNCTION  sy#sign#get_others()
Called 2 times
Total time:   0.000370
 Self time:   0.000370

count  total (s)   self (s)
    2              0.000014   let s:other_signs_line_numbers = {}
                            
    2              0.000005   let lang = v:lang
    2              0.000053   silent! execute 'language C'
                            
    2              0.000008   redir => signlist
    2              0.000058     silent! execute 'sign place file='. a:path
    2              0.000008   redir END
                            
    4              0.000119   for line in filter(split(signlist, '\n'), 'v:val =~ "^\\s\\+line"')
    2              0.000045     let lnum = matchlist(line, '\v^\s+line\=(\d+)')[1]
    2              0.000007     let s:other_signs_line_numbers[lnum] = 1
    2              0.000003   endfor
                            
    2              0.000030   silent! execute 'language' lang

FUNCTION  neobundle#util#expand()
Called 6 times
Total time:   0.000105
 Self time:   0.000105

count  total (s)   self (s)
    6              0.000083   let path = expand(escape(a:path, '*?{}'), 1)
    6              0.000019   return (s:is_windows && path =~ '\\') ? neobundle#util#substitute_path_separator(path) : path

FUNCTION  syntastic#util#unique()
Called 11 times
Total time:   0.000190
 Self time:   0.000190

count  total (s)   self (s)
   11              0.000029     let seen = {}
   11              0.000020     let uniques = []
   11              0.000025     for e in a:list
                                    if !has_key(seen, e)
                                        let seen[e] = 1
                                        call add(uniques, e)
                                    endif
                                endfor
   11              0.000015     return uniques

FUNCTION  <SNR>8_expand()
Called 16 times
Total time:   0.000412
 Self time:   0.000326

count  total (s)   self (s)
   16   0.000400   0.000314   return neobundle#util#substitute_path_separator( (a:path =~ '^\~') ? substitute(a:path, '^\~', expand('~'), '') : (a:path =~ '^\$\h\w*') ? substitute(a:path,               '^\$\h\w*', '\=eval(submatch(0))', '') : a:path)

FUNCTION  neobundle#config#check_not_exists()
Called 1 time
Total time:   0.003193
 Self time:   0.000116

count  total (s)   self (s)
                              " For infinite loop.
    1              0.000003   let self = get(a:000, 0, [])
                            
    1   0.003066   0.000011   let _ = map(neobundle#get_not_installed_bundles(a:names), 'v:val.name')
    7              0.000037   for bundle in map(filter(copy(a:names), 'index(self, v:val) < 0 && has_key(s:neobundles, v:val)'), 's:neobundles[v:val]')
    6              0.000014     call add(self, bundle.name)
                            
    6              0.000010     if !empty(bundle.depends)
                                  let _ += neobundle#config#check_not_exists( map(copy(bundle.depends), 'v:val.name'), self)
                                endif
    6              0.000003   endfor
                            
    1   0.000026   0.000004   return neobundle#util#uniq(_)

FUNCTION  sy#repo#detect()
Called 2 times
Total time:   0.078696
 Self time:   0.000225

count  total (s)   self (s)
    2              0.000010   let dir = fnamemodify(a:path, ':h')
                            
                              " Simple cache. If there is a registered VCS-controlled file in this
                              " directory already, assume that this file is probably controlled by
                              " the same VCS. Thus we shuffle that VCS to the top of our vcs_list.
    2              0.000004   if has_key(g:sy_cache, dir)
                                let idx = index(s:vcs_list, g:sy_cache[dir])
                                if idx != -1
                                  call remove(s:vcs_list, idx)
                                  call insert(s:vcs_list, g:sy_cache[dir], 0)
                                endif
                              endif
                            
    2              0.000006   for type in s:vcs_list
    2   0.078589   0.000118     let [istype, diff] = sy#repo#get_diff_{type}(a:path)
    2              0.000009     if istype
    2              0.000035       return [ diff, type ]
                                endif
                              endfor
                            
                              return [ '', 'unknown' ]

FUNCTION  <SNR>99_is_excluded_window()
Called 45 times
Total time:   0.002568
 Self time:   0.002568

count  total (s)   self (s)
   45              0.000149   for matchft in g:airline_exclude_filetypes
                                if matchft ==# &ft
                                  return 1
                                endif
                              endfor
                            
  180              0.000264   for matchw in g:airline_exclude_filenames
  135              0.001056     if matchstr(expand('%'), matchw) ==# matchw
                                  return 1
                                endif
  135              0.000080   endfor
                            
   45              0.000084   if g:airline_exclude_preview && &previewwindow
                                return 1
                              endif
                            
   45              0.000038   return 0

FUNCTION  airline#extensions#apply()
Called 45 times
Total time:   0.013105
 Self time:   0.003449

count  total (s)   self (s)
   45              0.000145   let s:active_winnr = winnr()
                            
   45   0.002805   0.000237   if s:is_excluded_window()
                                return -1
                              endif
                            
   45              0.000089   if &buftype == 'help'
                                call airline#extensions#apply_left_override('Help', '%f')
                                let w:airline_section_x = ''
                                let w:airline_section_y = ''
                                let w:airline_render_right = 1
                              endif
                            
   45              0.000057   if &previewwindow
                                let w:airline_section_a = 'Preview'
                                let w:airline_section_b = ''
                                let w:airline_section_c = bufname(winbufnr(winnr()))
                              endif
                            
   45              0.000279   if has_key(s:filetype_overrides, &ft)
   33              0.000172     let args = s:filetype_overrides[&ft]
   33   0.007347   0.000259     call airline#extensions#apply_left_override(args[0], args[1])
   33              0.000028   endif
                            
   90              0.000263   for item in items(s:filetype_regex_overrides)
   45              0.000447     if match(&ft, item[0]) >= 0
                                  call airline#extensions#apply_left_override(item[1][0], item[1][1])
                                endif
   45              0.000030   endfor

FUNCTION  neobundle#installer#_load_install_info()
Called 1 time
Total time:   0.000116
 Self time:   0.000113

count  total (s)   self (s)
    1   0.000015   0.000012   let install_info_path = neobundle#get_neobundle_dir() . '/.neobundle/install_info'
    1              0.000004   if !exists('s:install_info')
                                let s:install_info = {}
                            
                                if filereadable(install_info_path)
                                  try
                                    let list = readfile(install_info_path)
                                    let ver = list[0]
                                    sandbox let s:install_info = eval(list[1])
                                    if ver !=# '2.0' || type(s:install_info) != type({})
                                      let s:install_info = {}
                                    endif
                                  catch
                                  endtry
                                endif
                              endif
                            
    1              0.000074   call map(a:bundles, "extend(v:val, get(s:install_info, v:val.name, { 'checked_time' : localtime(), 'updated_time' : localtime(), 'installed_uri' : v:val.uri, 'installed_path' : v:val.path,}))")
                            
    1              0.000001   return s:install_info

FUNCTION  <SNR>139_SetBufWinVars()
Called 12 times
Total time:   0.000569
 Self time:   0.000569

count  total (s)   self (s)
                            "  call Dfunc("s:SetBufWinVars() win#".winnr())
   12              0.000076   if exists("w:netrw_liststyle")      |let b:netrw_liststyle      = w:netrw_liststyle      |endif
   12              0.000059   if exists("w:netrw_bannercnt")      |let b:netrw_bannercnt      = w:netrw_bannercnt      |endif
   12              0.000048   if exists("w:netrw_method")         |let b:netrw_method         = w:netrw_method         |endif
   12              0.000062   if exists("w:netrw_prvdir")         |let b:netrw_prvdir         = w:netrw_prvdir         |endif
   12              0.000052   if exists("w:netrw_explore_indx")   |let b:netrw_explore_indx   = w:netrw_explore_indx   |endif
   12              0.000047   if exists("w:netrw_explore_listlen")|let b:netrw_explore_listlen= w:netrw_explore_listlen|endif
   12              0.000047   if exists("w:netrw_explore_mtchcnt")|let b:netrw_explore_mtchcnt= w:netrw_explore_mtchcnt|endif
   12              0.000045   if exists("w:netrw_explore_bufnr")  |let b:netrw_explore_bufnr  = w:netrw_explore_bufnr  |endif
   12              0.000042   if exists("w:netrw_explore_line")   |let b:netrw_explore_line   = w:netrw_explore_line   |endif
   12              0.000042   if exists("w:netrw_explore_list")   |let b:netrw_explore_list   = w:netrw_explore_list   |endif
                            "  call Dret("s:SetBufWinVars")

FUNCTION  <SNR>115_build_sections()
Called 57 times
Total time:   0.086597
 Self time:   0.003090

count  total (s)   self (s)
  240              0.000361   for key in a:keys
  183              0.000466     if key == 'warning' && !a:context.active
                                  continue
                                endif
  183   0.084674   0.001167     call s:add_section(a:builder, a:context, key)
  183              0.000153   endfor

FUNCTION  airline#highlighter#get_highlight()
Called 364 times
Total time:   0.044181
 Self time:   0.012705

count  total (s)   self (s)
  364   0.016267   0.002306   let fg = s:get_syn(a:group, 'fg')
  364   0.014681   0.002227   let bg = s:get_syn(a:group, 'bg')
  364              0.004657   let reverse = synIDattr(synIDtrans(hlID(a:group)), 'reverse', has('gui_running') ? 'gui' : 'term')
  364   0.008139   0.003078   return reverse ? s:get_array(bg, fg, a:000) : s:get_array(fg, bg, a:000)

FUNCTION  airline#extensions#syntastic#get_warnings()
Called 20 times
Total time:   0.002181
 Self time:   0.000302

count  total (s)   self (s)
   20   0.002022   0.000143   let errors = SyntasticStatuslineFlag()
   20              0.000058   if strlen(errors) > 0
                                return errors.(g:airline_symbols.space)
                              endif
   20              0.000018   return ''

FUNCTION  netrw#NetrwRestorePosn()
Called 50 times
Total time:   0.005008
 Self time:   0.005008

count  total (s)   self (s)
                            "  call Dfunc("netrw#NetrwRestorePosn() a:0=".a:0." winnr=".(exists("w:netrw_winnr")? w:netrw_winnr : -1)." line=".(exists("w:netrw_line")? w:netrw_line : -1)." col=".(exists("w:netrw_col")? w:netrw_col : -1)." hline=".(exists("w:netrw_hline")? w:netrw_hline : -1))
   50              0.000239   let eikeep= &ei
   50              0.000276   set ei=all
   50              0.000224   if expand("%") == "NetrwMessage"
                               if exists("s:winBeforeErr")
                                exe s:winBeforeErr."wincmd w"
                               endif
                              endif
                            
   50              0.000068   if a:0 > 0
   24              0.000231    exe "keepj ".a:1
   24              0.000017   endif
                            
                              " restore window
   50              0.000129   if exists("w:netrw_winnr")
                            "   call Decho("(NetrwRestorePosn) restore window: exe sil! ".w:netrw_winnr."wincmd w")
   50              0.000629    exe "sil! ".w:netrw_winnr."wincmd w"
   50              0.000042   endif
   50              0.000084   if v:shell_error == 0
                               " as suggested by Bram M: redraw on no error
                               " allows protocol error messages to remain visible
                            "   redraw!
   25              0.000017   endif
                            
                              " restore top-of-screen line
   50              0.000128   if exists("w:netrw_hline")
                            "   call Decho("(NetrwRestorePosn) restore topofscreen: exe keepj norm! ".w:netrw_hline."G0z")
   50              0.000765    exe "keepj norm! ".w:netrw_hline."G0z\<CR>"
   50              0.000050   endif
                            
                              " restore position
   50              0.000228   if exists("w:netrw_line") && exists("w:netrw_col")
                            "   call Decho("(NetrwRestorePosn) restore posn: exe keepj norm! ".w:netrw_line."G0".w:netrw_col."|")
   50              0.000648    exe "keepj norm! ".w:netrw_line."G0".w:netrw_col."\<bar>"
   50              0.000043   endif
                            
   50              0.000247   let &ei= eikeep
                            "  call Dret("netrw#NetrwRestorePosn : line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol())

FUNCTION  netrw#NetrwSavePosn()
Called 26 times
Total time:   0.003934
 Self time:   0.001426

count  total (s)   self (s)
                            "  call Dfunc("netrw#NetrwSavePosn() line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol())
                              " Save current line and column
   26              0.000100   let w:netrw_winnr= winnr()
   26              0.000083   let w:netrw_line = line(".")
   26              0.000106   let w:netrw_col  = virtcol(".")
                            "  call Decho("(NetrwSavePosn) currently, win#".w:netrw_winnr." line#".w:netrw_line." col#".w:netrw_col)
                            
                              " Save top-of-screen line
   26              0.000368   keepj norm! H0
   26              0.000094   let w:netrw_hline= line(".")
                            
                              " set up string holding position parameters
   26              0.000289   let ret          = "let w:netrw_winnr=".w:netrw_winnr."|let w:netrw_line=".w:netrw_line."|let w:netrw_col=".w:netrw_col."|let w:netrw_hline=".w:netrw_hline
                            
   26   0.002657   0.000149   keepj call netrw#NetrwRestorePosn()
                            "  call Dret("netrw#NetrwSavePosn : winnr=".w:netrw_winnr." line=".w:netrw_line." col=".w:netrw_col." hline=".w:netrw_hline)
   26              0.000044   return ret

FUNCTION  <SNR>139_NetrwBookHistHandler()
Called 12 times
Total time:   0.017368
 Self time:   0.002449

count  total (s)   self (s)
                            "  call Dfunc("s:NetrwBookHistHandler(chg=".a:chg." curdir<".a:curdir.">) cnt=".v:count." histcnt=".g:netrw_dirhist_cnt." histmax=".g:netrw_dirhistmax)
   12              0.000050   if !exists("g:netrw_dirhistmax") || g:netrw_dirhistmax <= 0
                            "   "  call Dret("s:NetrwBookHistHandler - suppressed due to g:netrw_dirhistmax")
                               return
                              endif
                            
   12              0.000038   let ykeep= @@
   12              0.000014   if a:chg == 0
                               " bookmark the current directory
                            "   call Decho("(user: <b>) bookmark the current directory")
                               if !exists("g:netrw_bookmarklist")
                                let g:netrw_bookmarklist= []
                               endif
                               if index(g:netrw_bookmarklist,a:curdir) == -1
                                " curdir not currently in g:netrw_bookmarklist, so include it
                                call add(g:netrw_bookmarklist,a:curdir)
                                call sort(g:netrw_bookmarklist)
                               endif
                               echo "bookmarked the current directory"
                            
                              elseif a:chg == 1
                               " change to the bookmarked directory
                            "   call Decho("(user: <".v:count."gb>) change to the bookmarked directory")
                               if exists("g:netrw_bookmarklist[v:count-1]")
                            "    call Decho("(user: <".v:count."gb>) bookmarklist=".string(g:netrw_bookmarklist))
                                exe "keepj e ".fnameescape(g:netrw_bookmarklist[v:count-1])
                               else
                                echomsg "Sorry, bookmark#".v:count." doesn't exist!"
                               endif
                            
                              elseif a:chg == 2
                            "   redraw!
                               let didwork= 0
                               " list user's bookmarks
                            "   call Decho("(user: <q>) list user's bookmarks")
                               if exists("g:netrw_bookmarklist")
                            "    call Decho('list '.len(g:netrw_bookmarklist).' bookmarks')
                                let cnt= 1
                                for bmd in g:netrw_bookmarklist
                            "     call Decho("Netrw Bookmark#".cnt.": ".g:netrw_bookmarklist[cnt-1])
                                 echo printf("Netrw Bookmark#%-2d: %s",cnt,g:netrw_bookmarklist[cnt-1])
                                 let didwork = 1
                                 let cnt     = cnt + 1
                                endfor
                               endif
                            
                               " list directory history
                               let cnt     = g:netrw_dirhist_cnt
                               let first   = 1
                               let histcnt = 0
                               if g:netrw_dirhistmax > 0
                                while ( first || cnt != g:netrw_dirhist_cnt )
                            "    call Decho("first=".first." cnt=".cnt." dirhist_cnt=".g:netrw_dirhist_cnt)
                                 if exists("g:netrw_dirhist_{cnt}")
                            "     call Decho("Netrw  History#".histcnt.": ".g:netrw_dirhist_{cnt})
                                  echo printf("Netrw  History#%-2d: %s",histcnt,g:netrw_dirhist_{cnt})
                                  let didwork= 1
                                 endif
                                 let histcnt = histcnt + 1
                                 let first   = 0
                                 let cnt     = ( cnt - 1 ) % g:netrw_dirhistmax
                                 if cnt < 0
                                  let cnt= cnt + g:netrw_dirhistmax
                                 endif
                                endwhile
                               else
                                let g:netrw_dirhist_cnt= 0
                               endif
                               if didwork
                                call inputsave()|call input("Press <cr> to continue")|call inputrestore()
                               endif
                            
                              elseif a:chg == 3
                               " saves most recently visited directories (when they differ)
                            "   call Decho("(browsing) record curdir history")
   12              0.000129    if !exists("g:netrw_dirhist_cnt") || !exists("g:netrw_dirhist_{g:netrw_dirhist_cnt}") || g:netrw_dirhist_{g:netrw_dirhist_cnt} != a:curdir
   11              0.000018     if g:netrw_dirhistmax > 0
   11              0.000043      let g:netrw_dirhist_cnt                   = ( g:netrw_dirhist_cnt + 1 ) % g:netrw_dirhistmax
   11              0.000084      let g:netrw_dirhist_{g:netrw_dirhist_cnt} = a:curdir
   11              0.000008     endif
                            "    call Decho("save dirhist#".g:netrw_dirhist_cnt."<".g:netrw_dirhist_{g:netrw_dirhist_cnt}.">")
   11              0.000004    endif
                            
   12              0.000012   elseif a:chg == 4
                               " u: change to the previous directory stored on the history list
                            "   call Decho("(user: <u>) chg to prev dir from history")
                               if g:netrw_dirhistmax > 0
                                let g:netrw_dirhist_cnt= ( g:netrw_dirhist_cnt - v:count1 ) % g:netrw_dirhistmax
                                if g:netrw_dirhist_cnt < 0
                                 let g:netrw_dirhist_cnt= g:netrw_dirhist_cnt + g:netrw_dirhistmax
                                endif
                               else
                                let g:netrw_dirhist_cnt= 0
                               endif
                               if exists("g:netrw_dirhist_{g:netrw_dirhist_cnt}")
                            "    call Decho("changedir u#".g:netrw_dirhist_cnt."<".g:netrw_dirhist_{g:netrw_dirhist_cnt}.">")
                                if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST && exists("b:netrw_curdir")
                                 setl ma noro
                            "     call Decho("(NetrwBookHistHandler) setl ma noro")
                                 sil! keepj %d
                                 setl nomod
                            "     call Decho("(NetrwBookHistHandler) setl nomod")
                            "     call Decho("(NetrwBookHistHandler)  ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
                                endif
                            "    "    call Decho("exe e! ".fnameescape(g:netrw_dirhist_{g:netrw_dirhist_cnt}))
                                exe "keepj e! ".fnameescape(g:netrw_dirhist_{g:netrw_dirhist_cnt})
                               else
                                if g:netrw_dirhistmax > 0
                                 let g:netrw_dirhist_cnt= ( g:netrw_dirhist_cnt + v:count1 ) % g:netrw_dirhistmax
                                else
                                 let g:netrw_dirhist_cnt= 0
                                endif
                                echo "Sorry, no predecessor directory exists yet"
                               endif
                            
                              elseif a:chg == 5
                               " U: change to the subsequent directory stored on the history list
                            "   call Decho("(user: <U>) chg to next dir from history")
                               if g:netrw_dirhistmax > 0
                                let g:netrw_dirhist_cnt= ( g:netrw_dirhist_cnt + 1 ) % g:netrw_dirhistmax
                                if exists("g:netrw_dirhist_{g:netrw_dirhist_cnt}")
                            "    call Decho("changedir U#".g:netrw_dirhist_cnt."<".g:netrw_dirhist_{g:netrw_dirhist_cnt}.">")
                                 if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST && exists("b:netrw_curdir")
                            "      call Decho("(NetrwBookHistHandler) setl ma noro")
                                  setl ma noro
                                  sil! keepj %d
                            "      call Decho("removed all lines from buffer (%d)")
                            "      call Decho("(NetrwBookHistHandler) setl nomod")
                                  setl nomod
                            "      call Decho("(set nomod)  ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
                                 endif
                            "    call Decho("exe e! ".fnameescape(g:netrw_dirhist_{g:netrw_dirhist_cnt}))
                                 exe "keepj e! ".fnameescape(g:netrw_dirhist_{g:netrw_dirhist_cnt})
                                else
                                 let g:netrw_dirhist_cnt= ( g:netrw_dirhist_cnt - 1 ) % g:netrw_dirhistmax
                                 if g:netrw_dirhist_cnt < 0
                                  let g:netrw_dirhist_cnt= g:netrw_dirhist_cnt + g:netrw_dirhistmax
                                 endif
                                 echo "Sorry, no successor directory exists yet"
                                endif
                               else
                                let g:netrw_dirhist_cnt= 0
                                echo "Sorry, no successor directory exists yet (g:netrw_dirhistmax is ".g:netrw_dirhistmax.")"
                               endif
                            
                              elseif a:chg == 6
                               " delete the v:count'th bookmark
                            "   call Decho("delete bookmark#".v:count."<".g:netrw_bookmarklist[v:count-1].">")
                               let savefile= s:NetrwHome()."/.netrwbook"
                               if filereadable(savefile)
                            "    call Decho("merge bookmarks (active and file)")
                                keepj call s:NetrwBookHistSave() " done here to merge bookmarks first
                            "    call Decho("bookmark delete savefile<".savefile.">")
                                keepj call delete(savefile)
                               endif
                            "   call Decho("remove g:netrw_bookmarklist[".(v:count-1)."]")
                               keepj call remove(g:netrw_bookmarklist,v:count-1)
                            "   call Decho("resulting g:netrw_bookmarklist=".string(g:netrw_bookmarklist))
                              endif
   12   0.006115   0.000068   call s:NetrwBookmarkMenu()
   12   0.008955   0.000083   call s:NetrwTgtMenu()
   12              0.000066   let @@= ykeep
                            "  call Dret("s:NetrwBookHistHandler")

FUNCTION  <SNR>139_NetrwTgtMenu()
Called 14 times
Total time:   0.010412
 Self time:   0.010412

count  total (s)   self (s)
   14              0.000045   if !exists("s:netrw_menucnt")
                               return
                              endif
                            "  call Dfunc("s:NetrwTgtMenu()")
                            
                              " the following test assures that gvim is running, has menus available, and has menus enabled.
   14              0.000187   if has("gui") && has("menu") && has("gui_running") && &go =~# 'm' && g:netrw_menu
   14              0.000043    if exists("g:NetrwTopLvlMenu")
                            "    call Decho("removing ".g:NetrwTopLvlMenu."Bookmarks menu item(s)")
   14              0.001604     exe 'sil! unmenu '.g:NetrwTopLvlMenu.'Targets'
   14              0.000016    endif
   14              0.000050    if !exists("s:netrw_initbookhist")
                                call s:NetrwBookHistRead()
                               endif
                            
                               " target bookmarked places
   14              0.000049    if exists("g:netrw_bookmarklist") && g:netrw_bookmarklist != [] && g:netrw_dirhistmax > 0
                            "    call Decho("installing bookmarks as easy targets")
                                let cnt= 1
                                for bmd in g:netrw_bookmarklist
                                 let ebmd= escape(bmd,g:netrw_menu_escape)
                                 " show bookmarks for goto menu
                            "     call Decho("menu: Targets: ".bmd)
                                 exe 'sil! menu <silent> '.g:NetrwMenuPriority.".19.1.".cnt." ".g:NetrwTopLvlMenu.'Targets.'.ebmd."	:call netrw#NetrwMakeTgt('".bmd."')\<cr>"
                                 let cnt= cnt + 1
                                endfor
                               endif
                            
                               " target directory browsing history
   14              0.000045    if exists("g:netrw_dirhistmax") && g:netrw_dirhistmax > 0
                            "    call Decho("installing history as easy targets (histmax=".g:netrw_dirhistmax.")")
   14              0.000026     let histcnt = 1
  154              0.000234     while histcnt <= g:netrw_dirhistmax
  140              0.000356      let priority = g:netrw_dirhist_cnt + histcnt
  140              0.000646      if exists("g:netrw_dirhist_{histcnt}")
   89              0.000323       let histentry  = g:netrw_dirhist_{histcnt}
   89              0.000460       let ehistentry = escape(histentry,g:netrw_menu_escape)
                            "      call Decho("menu: Targets: ".histentry)
   89              0.004588       exe 'sil! menu <silent> '.g:NetrwMenuPriority.".19.2.".priority." ".g:NetrwTopLvlMenu.'Targets.'.ehistentry."	:call netrw#NetrwMakeTgt('".histentry."')\<cr>"
   89              0.000097      endif
  140              0.000411      let histcnt = histcnt + 1
  140              0.000131     endwhile
   14              0.000009    endif
   14              0.000005   endif
                            "  call Dret("s:NetrwTgtMenu")

FUNCTION  <SNR>69_UpdateLastColumn()
Called 11 times
Total time:   0.000392
 Self time:   0.000392

count  total (s)   self (s)
                              " Function to save the current column and buffer and window numbers,
   11              0.000039   if !exists('w:BufKillList')
                                " Just give up for now.
                                return
                              endif
   11              0.000060   let index = index(w:BufKillList, bufnr('%'))
   11              0.000017   if index != -1
                                " Extend list if required, then set the value
   11              0.000103     let w:BufKillColumnList += repeat([0], index - len(w:BufKillColumnList) + 1)
   11              0.000057     let w:BufKillColumnList[index] = col('.')
   11              0.000012   else
                                echom 'UpdateLastColumn failed to find bufnr ' . bufnr('%') . ' in w:BufKillList'
                              endif

FUNCTION  <SNR>142_processingEditconfigFile()
Called 1 time
Total time:   0.000641
 Self time:   0.000641

count  total (s)   self (s)
    1              0.000002   let opts = {}
    1              0.000001   let content = a:content
                            
    4              0.000006   for type in ['js', 'css', 'html']
                                " Get settings for javascript files
                                " collect all data after [**.js] to
                                " empty string
    3              0.000012     let index = index(content, '[**.'.type.']')
    3              0.000005     let l:value = {}
                            
    3              0.000004     if index == -1
                                  " If section doesn't define then set it how
                                  " empty object
                                  " @fix issue-25
                                  let opts[type] = l:value
                                  continue
                                endif
                            
                                " line with declaration [**.type]
                                " we shoul skip.
    3              0.000015     let index = index + 1
    3              0.000008     let line = get(content, index)
                            
                                " if string start with bracket
                                " then we assumes that it's
                                " start new logical section
                                " and break processing
   13              0.000047     while (strpart(line, 0, 1) != '[' && index <= len(content))
                            
   10              0.000073       if (!empty(matchstr(line, ';\(vim:\)\@!')) || empty(line))
                                    " if we meet comment which is don't
                                    " special comment or empty string
                                    " then stop processing this line
    3              0.000006         let index = index + 1
    3              0.000006         let line = get(content, index)
    3              0.000003         continue
                                  endif
                            
                                  " special comment should look like
                                  " ';vim:key=value:second=value'
    7              0.000017       if strpart(line, 0, 1) == ';'
                                    " if it's special comment then procesisng
                                    " it separate and continue processing
    1              0.000006         let l:copts = split(strpart(line, 5), ':')
                            
    3              0.000004         for part in l:copts
    2              0.000017           let data = split(part, '\s*=\s*')
    2              0.000009           let l:value[get(data, 0)] = get(data, 1)
    2              0.000002         endfor
    1              0.000000       else
                                    " else we assumes that it is
                                    " .editorconfig setting
    6              0.000047         let data = split(line, '\s*=\s*')
    6              0.000024         let l:value[get(data, 0)] = get(data, 1)
    6              0.000004       endif
                            
    7              0.000015       let index = index + 1
    7              0.000017       let line = get(content, index)
    7              0.000005     endwhile
                            
    3              0.000007     let opts[type] = l:value
    3              0.000003   endfor
                            
    1              0.000002   return opts

FUNCTION  airline#extensions#branch#get_head()
Called 20 times
Total time:   0.008349
 Self time:   0.001230

count  total (s)   self (s)
   20              0.000046   let head = ''
                            
   20              0.000088   if s:has_fugitive && !exists('b:mercurial_dir')
   20   0.004561   0.000113     let head = fugitive#head()
                            
   20              0.000078     if empty(head) && s:has_fugitive_detect && !exists('b:git_dir')
                                  call fugitive#detect(getcwd())
                                  let head = fugitive#head()
                                endif
   20              0.000013   endif
                            
   20              0.000041   if empty(head)
                                if s:has_lawrencium
                                  let head = lawrencium#statusline()
                                endif
                              endif
                            
   20              0.000044   if empty(head)
                                if s:has_vcscommand
                                  call VCSCommandEnableBufferSetup()
                                  if exists('b:VCSCommandBufferInfo')
                                    let head = get(b:VCSCommandBufferInfo, 0, '')
                                  endif
                                endif
                              endif
                            
   20   0.002970   0.000299   return empty(head) || !s:check_in_path() ? s:empty_message : printf('%s%s', empty(s:symbol) ? '' : s:symbol.(g:airline_symbols.space), head)

FUNCTION  <SNR>139_NetrwSetSort()
Called 12 times
Total time:   0.048569
 Self time:   0.048569

count  total (s)   self (s)
                            "  call Dfunc("SetSort() bannercnt=".w:netrw_bannercnt)
   12              0.000039   let ykeep= @@
   12              0.000024   if w:netrw_liststyle == s:LONGLIST
                               let seqlist  = substitute(g:netrw_sort_sequence,'\$','\\%(\t\\|\$\\)','ge')
                              else
   12              0.000025    let seqlist  = g:netrw_sort_sequence
   12              0.000008   endif
                              " sanity check -- insure that * appears somewhere
   12              0.000021   if seqlist == ""
                               let seqlist= '*'
                              elseif seqlist !~ '\*'
                               let seqlist= seqlist.',*'
                              endif
   12              0.000020   let priority = 1
  168              0.000358   while seqlist != ""
  156              0.000568    if seqlist =~ ','
  144              0.001665     let seq     = substitute(seqlist,',.*$','','e')
  144              0.002474     let seqlist = substitute(seqlist,'^.\{-},\(.*\)$','\1','e')
  144              0.000136    else
   12              0.000019     let seq     = seqlist
   12              0.000016     let seqlist = ""
   12              0.000006    endif
  156              0.000204    if priority < 10
  108              0.000418     let spriority= "00".priority.g:netrw_sepchr
  108              0.000142    elseif priority < 100
   48              0.000186     let spriority= "0".priority.g:netrw_sepchr
   48              0.000032    else
                                let spriority= priority.g:netrw_sepchr
                               endif
                            "   call Decho("priority=".priority." spriority<".spriority."> seq<".seq."> seqlist<".seqlist.">")
                            
                               " sanity check
  156              0.000442    if w:netrw_bannercnt > line("$")
                                " apparently no files were left after a Hiding pattern was used
                            "    call Dret("SetSort : no files left after hiding")
                                return
                               endif
  156              0.000261    if seq == '*'
   12              0.000026     let starpriority= spriority
   12              0.000005    else
  144              0.016875     exe 'sil keepj '.w:netrw_bannercnt.',$g/'.seq.'/s/^/'.spriority.'/'
  144              0.000707     call histdel("/",-1)
                                " sometimes multiple sorting patterns will match the same file or directory.
                                " The following substitute is intended to remove the excess matches.
  144              0.016452     exe 'sil keepj '.w:netrw_bannercnt.',$g/^\d\{3}'.g:netrw_sepchr.'\d\{3}\//s/^\d\{3}'.g:netrw_sepchr.'\(\d\{3}\/\).\@=/\1/e'
  144              0.000712     keepj call histdel("/",-1)
  144              0.000138    endif
  156              0.000542    let priority = priority + 1
  156              0.000159   endwhile
   12              0.000040   if exists("starpriority")
   12              0.002073    exe 'sil keepj '.w:netrw_bannercnt.',$v/^\d\{3}'.g:netrw_sepchr.'/s/^/'.starpriority.'/'
   12              0.000057    keepj call histdel("/",-1)
   12              0.000014   endif
                            
                              " Following line associated with priority -- items that satisfy a priority
                              " pattern get prefixed by ###/ which permits easy sorting by priority.
                              " Sometimes files can satisfy multiple priority patterns -- only the latest
                              " priority pattern needs to be retained.  So, at this point, these excess
                              " priority prefixes need to be removed, but not directories that happen to
                              " be just digits themselves.
   12              0.000490   exe 'sil keepj '.w:netrw_bannercnt.',$s/^\(\d\{3}'.g:netrw_sepchr.'\)\%(\d\{3}'.g:netrw_sepchr.'\)\+\ze./\1/e'
   12              0.000040   keepj call histdel("/",-1)
   12              0.000071   let @@= ykeep
                            
                            "  call Dret("SetSort")

FUNCTION  <SNR>139_NetrwHome()
Called 1 time
Total time:   0.000180
 Self time:   0.000180

count  total (s)   self (s)
    1              0.000003   if exists("g:netrw_home")
                               let home= g:netrw_home
                              else
                               " go to vim plugin home
    1              0.000070    for home in split(&rtp,',') + ['']
    1              0.000034     if isdirectory(home) && filewritable(home) | break | endif
                                 let basehome= substitute(home,'[/\\]\.vim$','','')
                                if isdirectory(basehome) && filewritable(basehome)
                                 let home= basehome."/.vim"
                                 break
                                endif
                               endfor
    1              0.000003    if home == ""
                                " just pick the first directory
                                let home= substitute(&rtp,',.*$','','')
                               endif
    1              0.000014    if (has("win32") || has("win95") || has("win64") || has("win16"))
                                let home= substitute(home,'/','\\','g')
                               endif
    1              0.000001   endif
                              " insure that the home directory exists
    1              0.000006   if g:netrw_dirhistmax > 0 && !isdirectory(home)
                               if exists("g:netrw_mkdir")
                                call system(g:netrw_mkdir." ".shellescape(home))
                               else
                                call mkdir(home)
                               endif
                              endif
    1              0.000002   let g:netrw_home= home
    1              0.000002   return home

FUNCTION  airline#extensions#ctrlp#apply()
Called 45 times
Total time:   0.000446
 Self time:   0.000446

count  total (s)   self (s)
                              " disable statusline overwrite if ctrlp already did it
   45              0.000374   return match(&statusline, 'CtrlPwhite') >= 0 ? -1 : 0

FUNCTION  indent_guides#process_autocmds()
Called 46 times
Total time:   0.002363
 Self time:   0.000535

count  total (s)   self (s)
   46              0.000097   if g:indent_guides_autocmds_enabled
                                call indent_guides#enable()
                              else
   46   0.002019   0.000191     call indent_guides#disable()
   46              0.000037   end

FUNCTION  airline#extensions#hunks#get_hunks()
Called 20 times
Total time:   0.002563
 Self time:   0.001503

count  total (s)   self (s)
   20              0.000078   if !get(w:, 'airline_active', 0)
                                return ''
                              endif
   20   0.001193   0.000133   let hunks = s:get_hunks()
   20              0.000038   let string = ''
   20              0.000045   if !empty(hunks)
   80              0.000141     for i in [0, 1, 2]
   60              0.000148       if s:non_zero_only == 0 || hunks[i] > 0
   60              0.000508         let string .= printf('%s%s ', s:hunk_symbols[i], hunks[i])
   60              0.000056       endif
   60              0.000043     endfor
   20              0.000016   endif
   20              0.000028   return string

FUNCTION  <SNR>139_NetrwBrowse()
Called 12 times
Total time:   0.424393
 Self time:   0.004966

count  total (s)   self (s)
   12              0.000089   if !exists("w:netrw_liststyle")|let w:netrw_liststyle= g:netrw_liststyle|endif
                            "  call Dfunc("s:NetrwBrowse(islocal=".a:islocal." dirname<".a:dirname.">) liststyle=".w:netrw_liststyle." ".g:loaded_netrw." buf#".bufnr("%")."<".bufname("%")."> win#".winnr())
                            "  call Decho("(NetrwBrowse) tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")." modified=".&modified." modifiable=".&modifiable." readonly=".&readonly)
                              " s:NetrwBrowse: initialize history {{{3
   12              0.000037   if !exists("s:netrw_initbookhist")
    1   0.002648   0.000012    keepj call s:NetrwBookHistRead()
    1              0.000001   endif
                            
                              " s:NetrwBrowse: simplify the dirname (especially for ".."s in dirnames) {{{3
   12              0.000133   if a:dirname !~ '^\a\+://'
   12              0.000058    let dirname= simplify(a:dirname)
   12              0.000010   else
                               let dirname= a:dirname
                              endif
                            
   12              0.000041   if exists("s:netrw_skipbrowse")
                               unlet s:netrw_skipbrowse
                            "   call Decho("(NetrwBrowse)  ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
                            "   call Dret("s:NetrwBrowse : s:netrw_skipbrowse=".s:netrw_skipbrowse)
                               return
                              endif
                            
                              " s:NetrwBrowse: sanity checks: {{{3
   12              0.000041   if !exists("*shellescape")
                               keepj call netrw#ErrorMsg(s:ERROR,"netrw can't run -- your vim is missing shellescape()",69)
                            "   call Dret("s:NetrwBrowse : missing shellescape()")
                               return
                              endif
   12              0.000028   if !exists("*fnameescape")
                               keepj call netrw#ErrorMsg(s:ERROR,"netrw can't run -- your vim is missing fnameescape()",70)
                            "   call Dret("s:NetrwBrowse : missing fnameescape()")
                               return
                              endif
                            
                              " s:NetrwBrowse: save options: {{{3
   12   0.003322   0.000087   call s:NetrwOptionSave("w:")                                                                                                            
                            
                              " s:NetrwBrowse: re-instate any marked files {{{3
   12              0.000103   if exists("s:netrwmarkfilelist_{bufnr('%')}")
                            "   call Decho("(NetrwBrowse) clearing marked files")
                               exe "2match netrwMarkFile /".s:netrwmarkfilemtch_{bufnr("%")}."/"
                              endif
                            
   12              0.000050   if a:islocal && exists("w:netrw_acdkeep") && w:netrw_acdkeep
                               " s:NetrwBrowse: set up "safe" options for local directory/file {{{3
                            "   call Decho("(NetrwBrowse) handle w:netrw_acdkeep:")
                            "   call Decho("(NetrwBrowse) keepjumps lcd ".fnameescape(dirname)." (due to w:netrw_acdkeep=".w:netrw_acdkeep." - acd=".&acd.")")
                               exe 'keepj lcd '.fnameescape(dirname)
                               call s:NetrwSafeOptions()
                            "   call Decho("(NetrwBrowse) getcwd<".getcwd().">")
                            
                              elseif !a:islocal && dirname !~ '[\/]$' && dirname !~ '^"'
                               " s:NetrwBrowse: looks like a remote regular file, attempt transfer {{{3
                            "   call Decho("(NetrwBrowse) attempt transfer as regular file<".dirname.">")
                            
                               " remove any filetype indicator from end of dirname, except for the
                               " "this is a directory" indicator (/).
                               " There shouldn't be one of those here, anyway.
                               let path= substitute(dirname,'[*=@|]\r\=$','','e')
                            "   call Decho("(NetrwBrowse) new path<".path.">")
                               call s:RemotePathAnalysis(dirname)
                            
                               " s:NetrwBrowse: remote-read the requested file into current buffer {{{3
                               keepj mark '
                               call s:NetrwEnew(dirname)
                               call s:NetrwSafeOptions()
                               setl ma noro
                            "   call Decho("(NetrwBrowse) setl ma noro")
                               let b:netrw_curdir = dirname
                               let url            = s:method."://".s:user.s:machine.(s:port ? ":".s:port : "")."/".s:path
                            "   call Decho("(NetrwBrowse) exe sil! keepalt file ".fnameescape(url)." (bt=".&bt.")")
                               exe "sil! keepj keepalt file ".fnameescape(url)
                               exe "sil! keepj keepalt doau BufReadPre ".fnameescape(s:fname)
                               sil call netrw#NetRead(2,url)
                               if s:path !~ '.tar.bz2$' && s:path !~ '.tar.gz' && s:path !~ '.tar.xz' && s:path !~ '.txz'
                                " netrw.vim and tar.vim have already handled decompression of the tarball; avoiding gzip.vim error
                                exe "sil keepj keepalt doau BufReadPost ".fnameescape(s:fname)
                               endif
                            
                               " s:NetrwBrowse: save certain window-oriented variables into buffer-oriented variables {{{3
                               call s:SetBufWinVars()
                               call s:NetrwOptionRestore("w:")
                            "   call Decho("(NetrwBrowse) setl ma nomod")
                               setl ma nomod
                            "   call Decho("(NetrwBrowse)  ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
                            
                            "   call Dret("s:NetrwBrowse : file<".s:fname.">")
                               return
                              endif
                            
                              " use buffer-oriented WinVars if buffer variables exist but associated window variables don't {{{3
   12   0.000831   0.000070   call s:UseBufWinVars()
                            
                              " set up some variables {{{3
   12              0.000034   let b:netrw_browser_active = 1
   12              0.000028   let dirname                = dirname
   12              0.000042   let s:last_sort_by         = g:netrw_sort_by
                            
                              " set up menu {{{3
   12   0.013679   0.000071   keepj call s:NetrwMenu(1)
                            
                              " get/set-up buffer {{{3
   12   0.080671   0.000138   let reusing= s:NetrwGetBuffer(a:islocal,dirname)
                              " maintain markfile highlighting
   12              0.000105   if exists("s:netrwmarkfilemtch_{bufnr('%')}") && s:netrwmarkfilemtch_{bufnr("%")} != ""
                            "   call Decho("(NetrwBrowse) bufnr(%)=".bufnr('%'))
                            "   call Decho("(NetrwBrowse) exe 2match netrwMarkFile /".s:netrwmarkfilemtch_{bufnr("%")}."/")
                               exe "2match netrwMarkFile /".s:netrwmarkfilemtch_{bufnr("%")}."/"
                              else
                            "   call Decho("(NetrwBrowse) 2match none")
   12              0.000020    2match none
   12              0.000009   endif
   12              0.000026   if reusing && line("$") > 1
                               call s:NetrwOptionRestore("w:")
                            "   call Decho("(NetrwBrowse) setl noma nomod nowrap")
                               setl noma nomod nowrap
                            "   call Decho("(NetrwBrowse) (set noma nomod nowrap)  ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
                            "   call Dret("s:NetrwBrowse : re-using buffer")
                               return
                              endif
                            
                              " set b:netrw_curdir to the new directory name {{{3
                            "  call Decho("(NetrwBrowse) set b:netrw_curdir to the new directory name:  (buf#".bufnr("%").")")
   12              0.000039   let b:netrw_curdir= dirname
   12              0.000147   if b:netrw_curdir =~ '[/\\]$'
    8              0.000096    let b:netrw_curdir= substitute(b:netrw_curdir,'[/\\]$','','e')
    8              0.000008   endif
   12              0.000037   if b:netrw_curdir == ''
                               if has("amiga")
                                " On the Amiga, the empty string connotes the current directory
                                let b:netrw_curdir= getcwd()
                               else
                                " under unix, when the root directory is encountered, the result
                                " from the preceding substitute is an empty string.
                                let b:netrw_curdir= '/'
                               endif
                              endif
   12              0.000023   if !a:islocal && b:netrw_curdir !~ '/$'
                               let b:netrw_curdir= b:netrw_curdir.'/'
                              endif
                            "  call Decho("(NetrwBrowse) b:netrw_curdir<".b:netrw_curdir.">")
                            
                              " ------------
                              " (local only) {{{3
                              " ------------
   12              0.000015   if a:islocal
                            "   call Decho("(NetrwBrowse) local only:")
                            
                               " Set up ShellCmdPost handling.  Append current buffer to browselist
   12   0.000917   0.000083    call s:LocalFastBrowser()
                            
                              " handle g:netrw_keepdir: set vim's current directory to netrw's notion of the current directory {{{3
   12              0.000017    if !g:netrw_keepdir
                            "    call Decho("(NetrwBrowse) handle g:netrw_keepdir=".g:netrw_keepdir.": getcwd<".getcwd()."> acd=".&acd)
                            "    call Decho("(NetrwBrowse) l:acd".(exists("&l:acd")? "=".&l:acd : " doesn't exist"))
                                if !exists("&l:acd") || !&l:acd
                            "     call Decho('exe keepjumps lcd '.fnameescape(b:netrw_curdir))
                                 try
                                  exe 'keepj lcd '.fnameescape(b:netrw_curdir)
                                 catch /^Vim\%((\a\+)\)\=:E472/
                                  call netrw#ErrorMsg(s:ERROR,"unable to change directory to <".b:netrw_curdir."> (permissions?)",61)
                                  if exists("w:netrw_prvdir")
                                   let b:netrw_curdir= w:netrw_prvdir
                                  else
                                   call s:NetrwOptionRestore("w:")
                            "       call Decho("(NetrwBrowse) setl noma nomod nowrap")
                                   setl noma nomod nowrap
                            "       call Decho("(NetrwBrowse)  ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
                                   let b:netrw_curdir= dirname
                            "       call Dret("s:NetrwBrowse : reusing buffer#".(exists("bufnum")? bufnum : 'N/A')."<".dirname."> getcwd<".getcwd().">")
                                   return
                                  endif
                                 endtry
                                endif
                               endif
                            
                              " --------------------------------
                              " remote handling: {{{3
                              " --------------------------------
   12              0.000008   else
                            "   call Decho("(NetrwBrowse) remote only:")
                            
                               " analyze dirname and g:netrw_list_cmd {{{3
                            "   call Decho("(NetrwBrowse) b:netrw_curdir<".(exists("b:netrw_curdir")? b:netrw_curdir : "doesn't exist")."> dirname<".dirname.">")
                               if dirname =~ "^NetrwTreeListing\>"
                                let dirname= b:netrw_curdir
                            "    call Decho("(NetrwBrowse) (dirname was <NetrwTreeListing>) dirname<".dirname.">")
                               elseif exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST && exists("b:netrw_curdir")
                                let dirname= substitute(b:netrw_curdir,'\\','/','g')
                                if dirname !~ '/$'
                                 let dirname= dirname.'/'
                                endif
                                let b:netrw_curdir = dirname
                            "    call Decho("(NetrwBrowse) (liststyle is TREELIST) dirname<".dirname.">")
                               else
                                let dirname = substitute(dirname,'\\','/','g')
                            "    call Decho("(NetrwBrowse) (normal) dirname<".dirname.">")
                               endif
                            
                               let dirpat  = '^\(\w\{-}\)://\(\w\+@\)\=\([^/]\+\)/\(.*\)$'
                               if dirname !~ dirpat
                                if !exists("g:netrw_quiet")
                                 keepj call netrw#ErrorMsg(s:ERROR,"netrw doesn't understand your dirname<".dirname.">",20)
                                endif
                                keepj call s:NetrwOptionRestore("w:")
                            "    call Decho("(NetrwBrowse) setl noma nomod nowrap")
                                setl noma nomod nowrap
                            "    call Decho("(NetrwBrowse)  ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
                            "    call Dret("s:NetrwBrowse : badly formatted dirname<".dirname.">")
                                return
                               endif
                               let b:netrw_curdir= dirname
                            "   call Decho("(NetrwBrowse) b:netrw_curdir<".b:netrw_curdir."> (remote)")
                              endif  " (additional remote handling)
                            
                              " -----------------------
                              " Directory Listing: {{{3
                              " -----------------------
   12   0.030528   0.000092   keepj call s:NetrwMaps(a:islocal)
   12   0.287230   0.000096   keepj call s:PerformListing(a:islocal)
   12              0.000120   if v:version >= 700 && has("balloon_eval") && &beval == 0 && &l:bexpr == "" && !exists("g:netrw_nobeval")
    7              0.000038    let &l:bexpr= "netrw#NetrwBalloonHelp()"
                            "   call Decho("(NetrwBrowse) set up balloon help: l:bexpr=".&l:bexpr)
    7              0.000251    set beval
    7              0.000009   endif
   12   0.000325   0.000075   call s:NetrwOptionRestore("w:")
                            
                              " The s:LocalBrowseShellCmdRefresh() function is called by an autocmd
                              " installed by s:LocalFastBrowser() when g:netrw_fastbrowse <= 1 (ie. slow, medium speed).
                              " However, s:NetrwBrowse() causes the ShellCmdPost event itself to fire once; setting
                              " the variable below avoids that second refresh of the screen.  The s:LocalBrowseShellCmdRefresh()
                              " function gets called due to that autocmd; it notices that the following variable is set
                              " and skips the refresh and sets s:locbrowseshellcmd to zero. Oct 13, 2008
   12              0.000027   let s:locbrowseshellcmd= 1
                            
                            "  call Decho("(NetrwBrowse) ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
                            "  call Dret("s:NetrwBrowse : did PerformListing  ft<".&ft.">")
   12              0.000010   return

FUNCTION  neobundle#config#get()
Called 6 times
Total time:   0.000023
 Self time:   0.000023

count  total (s)   self (s)
    6              0.000020   return get(s:neobundles, a:name, {})

FUNCTION  <SNR>139_LocalListing()
Called 12 times
Total time:   0.047227
 Self time:   0.044497

count  total (s)   self (s)
                            "  call Dfunc("s:LocalListing()")
                            "  call Decho("(LocalListing) ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
                            "  call Decho("(LocalListing) tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> modified=".&modified." modifiable=".&modifiable." readonly=".&readonly)
                            
                            "  if exists("b:netrw_curdir") |call Decho('(LocalListing) b:netrw_curdir<'.b:netrw_curdir.">")  |else|call Decho("(LocalListing) b:netrw_curdir doesn't exist") |endif
                            "  if exists("g:netrw_sort_by")|call Decho('(LocalListing) g:netrw_sort_by<'.g:netrw_sort_by.">")|else|call Decho("(LocalListing) g:netrw_sort_by doesn't exist")|endif
                            
                              " get the list of files contained in the current directory
   12              0.000031   let dirname    = b:netrw_curdir
   12   0.000752   0.000083   let dirnamelen = s:Strlen(b:netrw_curdir)
   12   0.006363   0.005343   let filelist   = glob(s:ComposePath(dirname,"*"),0,1)
   12   0.003672   0.002631   let filelist   = filelist + glob(s:ComposePath(dirname,".*"),0,1)
                            "  call Decho("(LocalListing) filelist=".filelist)
                            
   12              0.000170   if g:netrw_cygwin == 0 && (has("win32") || has("win95") || has("win64") || has("win16"))
                            "   call Decho("(LocalListing) filelist=".string(filelist))
                              elseif index(filelist,'..') == -1 && b:netrw_curdir !~ '/'
                                " include ../ in the glob() entry if its missing
                            "   call Decho("(LocalListing) forcibly including on \"..\"")
                               let filelist= filelist+[s:ComposePath(b:netrw_curdir,"../")]
                            "   call Decho("(LocalListing) filelist=".string(filelist))
                              endif
                            
                            "  call Decho("(LocalListing) (before while) dirname<".dirname.">")
                            "  call Decho("(LocalListing) (before while) dirnamelen<".dirnamelen.">")
                            "  call Decho("(LocalListing) (before while) filelist=".string(filelist))
                            
   12              0.000037   if get(g:, 'netrw_dynamic_maxfilenamelen', 0)
                               let filelistcopy           = map(deepcopy(filelist),'fnamemodify(v:val, ":t")')
                               let g:netrw_maxfilenamelen = max(map(filelistcopy,'len(v:val)')) + 1
                            "   call Decho("(LocalListing) dynamic_maxfilenamelen: filenames             =".string(filelistcopy))
                            "   call Decho("(LocalListing) dynamic_maxfilenamelen: g:netrw_maxfilenamelen=".g:netrw_maxfilenamelen)
                              endif
                            
  280              0.000338   for filename in filelist
                            "   call Decho("(LocalListing)  ")
                            "   call Decho("(LocalListing) (while) filename<".filename.">")
                            
  268              0.001660    if getftype(filename) == "link"
                                " indicate a symbolic link
                            "    call Decho("(LocalListing) indicate <".filename."> is a symbolic link with trailing @")
    2              0.000007     let pfile= filename."@"
                            
    2              0.000003    elseif getftype(filename) == "socket"
                                " indicate a socket
                            "    call Decho("(LocalListing) indicate <".filename."> is a socket with trailing =")
                                let pfile= filename."="
                            
                               elseif getftype(filename) == "fifo"
                                " indicate a fifo
                            "    call Decho("(LocalListing) indicate <".filename."> is a fifo with trailing |")
                                let pfile= filename."|"
                            
                               elseif isdirectory(filename)
                                " indicate a directory
                            "    call Decho("(LocalListing) indicate <".filename."> is a directory with trailing /")
  163              0.000416     let pfile= filename."/"
                            
  163              0.000408    elseif exists("b:netrw_curdir") && b:netrw_curdir !~ '^.*://' && !isdirectory(filename)
  103              0.001205     if (has("win32") || has("win95") || has("win64") || has("win16"))
                                 if filename =~ '\.[eE][xX][eE]$' || filename =~ '\.[cC][oO][mM]$' || filename =~ '\.[bB][aA][tT]$'
                                  " indicate an executable
                            "      call Decho("(LocalListing) indicate <".filename."> is executable with trailing *")
                                  let pfile= filename."*"
                                 else
                                  " normal file
                                  let pfile= filename
                                 endif
                                elseif executable(filename)
                                 " indicate an executable
                            "     call Decho("(LocalListing) indicate <".filename."> is executable with trailing *")
                                 let pfile= filename."*"
                                else
                                 " normal file
  103              0.000170      let pfile= filename
  103              0.000066     endif
                            
  103              0.000052    else
                                " normal file
                                let pfile= filename
                               endif
                            "   call Decho("(LocalListing) pfile<".pfile."> (after *@/ appending)")
                            
  268              0.001288    if pfile =~ '//$'
                                let pfile= substitute(pfile,'//$','/','e')
                            "    call Decho("(LocalListing) change // to /: pfile<".pfile.">")
                               endif
  268              0.000781    let pfile= strpart(pfile,dirnamelen)
  268              0.001870    let pfile= substitute(pfile,'^[/\\]','','e')
                            "   call Decho("(LocalListing) filename<".filename.">")
                            "   call Decho("(LocalListing) pfile   <".pfile.">")
                            
  268              0.000548    if w:netrw_liststyle == s:LONGLIST
                                let sz   = getfsize(filename)
                                let fsz  = strpart("               ",1,15-strlen(sz)).sz
                                let pfile= pfile."\t".fsz." ".strftime(g:netrw_timefmt,getftime(filename))
                            "    call Decho("(LocalListing) sz=".sz." fsz=".fsz)
                               endif
                            
  268              0.000827    if     g:netrw_sort_by =~ "^t"
                                " sort by time (handles time up to 1 quintillion seconds, US)
                            "    call Decho("(LocalListing) getftime(".filename.")=".getftime(filename))
                                let t  = getftime(filename)
                                let ft = strpart("000000000000000000",1,18-strlen(t)).t
                            "    call Decho("(LocalListing) exe keepjumps put ='".ft.'/'.filename."'")
                                let ftpfile= ft.'/'.pfile
                                sil! keepj put=ftpfile
                            
                               elseif g:netrw_sort_by =~ "^s"
                                " sort by size (handles file sizes up to 1 quintillion bytes, US)
                            "    call Decho("(LocalListing) getfsize(".filename.")=".getfsize(filename))
                                let sz   = getfsize(filename)
                                let fsz  = strpart("000000000000000000",1,18-strlen(sz)).sz
                            "    call Decho("(LocalListing) exe keepj put ='".fsz.'/'.filename."'")
                                let fszpfile= fsz.'/'.pfile
                                sil! keepj put =fszpfile
                            
                               else
                                " sort by name
                            "    call Decho("(LocalListing) exe keepjumps put ='".pfile."'")
  268              0.001466     sil! keepj put=pfile
  268              0.000211    endif
  268              0.000185   endfor
                            
                              " cleanup any windows mess at end-of-line
   12              0.002049   sil! keepj g/^$/d
   12              0.000146   sil! keepj %s/\r$//e
   12              0.000068   call histdel("/",-1)
                            "  call Decho("(LocalListing) exe setl ts=".(g:netrw_maxfilenamelen+1))
   12              0.000143   exe "setl ts=".(g:netrw_maxfilenamelen+1)
                            
                            "  call Dret("s:LocalListing")

FUNCTION  neobundle#util#substitute_path_separator()
Called 16 times
Total time:   0.000086
 Self time:   0.000086

count  total (s)   self (s)
   16              0.000071   return (s:is_windows && a:path =~ '\\') ? substitute(a:path, '\\', '/', 'g') : a:path

FUNCTION  AutoPairsTryInit()
Called 11 times
Total time:   0.008280
 Self time:   0.001651

count  total (s)   self (s)
   11              0.000041   if exists('b:autopairs_loaded')
    1              0.000002     return
                              end
                            
                              " for auto-pairs starts with 'a', so the priority is higher than supertab and vim-endwise
                              "
                              " vim-endwise doesn't support <Plug>AutoPairsReturn
                              " when use <Plug>AutoPairsReturn will cause <Plug> isn't expanded
                              "
                              " supertab doesn't support <SID>AutoPairsReturn
                              " when use <SID>AutoPairsReturn  will cause Duplicated <CR>
                              "
                              " and when load after vim-endwise will cause unexpected endwise inserted. 
                              " so always load AutoPairs at last
                              
                              " Buffer level keys mapping
                              " comptible with other plugin
   10              0.000018   if g:AutoPairsMapCR
   10              0.000031     if v:version == 703 && has('patch32') || v:version > 703
                                  " VIM 7.3 supports advancer maparg which could get <expr> info
                                  " then auto-pairs could remap <CR> in any case.
   10              0.000394       let info = maparg('<CR>', 'i', 0, 1)
   10              0.000023       if empty(info)
                                    let old_cr = '<CR>'
                                    let is_expr = 0
                                  else
   10              0.000028         let old_cr = info['rhs']
   10   0.000383   0.000075         let old_cr = s:ExpandMap(old_cr)
   10              0.000101         let old_cr = substitute(old_cr, '<SID>', '<SNR>' . info['sid'] . '_', 'g')
   10              0.000029         let is_expr = info['expr']
   10              0.000023         let wrapper_name = '<SID>AutoPairsOldCRWrapper73'
   10              0.000007       endif
   10              0.000005     else
                                  " VIM version less than 7.3
                                  " the mapping's <expr> info is lost, so guess it is expr or not, it's
                                  " not accurate.
                                  let old_cr = maparg('<CR>', 'i')
                                  if old_cr == ''
                                    let old_cr = '<CR>'
                                    let is_expr = 0
                                  else
                                    let old_cr = s:ExpandMap(old_cr)
                                    " old_cr contain (, I guess the old cr is in expr mode
                                    let is_expr = old_cr =~ '\V(' && toupper(old_cr) !~ '\V<C-R>'
                            
                                    " The old_cr start with " it must be in expr mode
                                    let is_expr = is_expr || old_cr =~ '\v^"'
                                    let wrapper_name = '<SID>AutoPairsOldCRWrapper'
                                  end
                                end
                            
   10              0.000054     if old_cr !~ 'AutoPairsReturn'
   10              0.000012       if is_expr
                                    " remap <expr> to `name` to avoid mix expr and non-expr mode
                                    execute 'inoremap <buffer> <expr> <script> '. wrapper_name . ' ' . old_cr
                                    let old_cr = wrapper_name
                                  end
                                  " Always silent mapping
   10              0.000246       execute 'inoremap <script> <buffer> <silent> <CR> '.old_cr.'<SID>AutoPairsReturn'
   10              0.000011     end
   10              0.000004   endif
   10   0.006387   0.000066   call AutoPairsInit()

FUNCTION  neobundle#config#rtp_add()
Called 6 times
Total time:   0.000969
 Self time:   0.000323

count  total (s)   self (s)
    6              0.000019   if has_key(s:neobundles, a:bundle.name)
    6   0.000278   0.000035     call neobundle#config#rtp_rm(s:neobundles[a:bundle.name])
    6              0.000001   endif
                            
    6              0.000012   let rtp = a:bundle.rtp
    6              0.000030   if isdirectory(rtp)
                                " Join to the tail in runtimepath.
    6   0.000304   0.000036     let rtps = neobundle#util#split_rtp(&runtimepath)
    6   0.000205   0.000070     let &runtimepath = neobundle#util#join_rtp( insert(rtps, rtp,   (a:bundle.lazy ? 0 : index(rtps, neobundle#get_rtp_dir()))), &runtimepath, rtp)
    6              0.000006   endif
    6              0.000030   if isdirectory(rtp.'/after')
    2              0.000046     execute 'set rtp+='.fnameescape(rtp.'/after')
    2              0.000000   endif

FUNCTION  SyntasticStatuslineFlag()
Called 20 times
Total time:   0.001879
 Self time:   0.001375

count  total (s)   self (s)
   20   0.000360   0.000133     let loclist = g:SyntasticLoclist.current()
   20   0.000231   0.000114     let issues = loclist.filteredRaw()
   20   0.000170   0.000103     let num_issues = loclist.getLength()
   20   0.000173   0.000080     if loclist.hasErrorsOrWarningsToDisplay()
                                    let errors = loclist.errors()
                                    let warnings = loclist.warnings()
                            
                                    let num_errors = len(errors)
                                    let num_warnings = len(warnings)
                            
                                    let output = g:syntastic_stl_format
                            
                                    "hide stuff wrapped in %E(...) unless there are errors
                                    let output = substitute(output, '\m\C%E{\([^}]*\)}', num_errors ? '\1' : '' , 'g')
                            
                                    "hide stuff wrapped in %W(...) unless there are warnings
                                    let output = substitute(output, '\m\C%W{\([^}]*\)}', num_warnings ? '\1' : '' , 'g')
                            
                                    "hide stuff wrapped in %B(...) unless there are both errors and warnings
                                    let output = substitute(output, '\m\C%B{\([^}]*\)}', (num_warnings && num_errors) ? '\1' : '' , 'g')
                            
                            
                                    "sub in the total errors/warnings/both
                                    let output = substitute(output, '\m\C%w', num_warnings, 'g')
                                    let output = substitute(output, '\m\C%e', num_errors, 'g')
                                    let output = substitute(output, '\m\C%t', num_issues, 'g')
                            
                                    "first error/warning line num
                                    let output = substitute(output, '\m\C%F', num_issues ? issues[0]['lnum'] : '', 'g')
                            
                                    "first error line num
                                    let output = substitute(output, '\m\C%fe', num_errors ? errors[0]['lnum'] : '', 'g')
                            
                                    "first warning line num
                                    let output = substitute(output, '\m\C%fw', num_warnings ? warnings[0]['lnum'] : '', 'g')
                            
                                    return output
                                else
   20              0.000018         return ''
                                endif

FUNCTION  airline#util#prepend()
Called 20 times
Total time:   0.000184
 Self time:   0.000184

count  total (s)   self (s)
   20              0.000057   if a:minwidth > 0 && winwidth(0) < a:minwidth
                                return ''
                              endif
   20              0.000073   return empty(a:text) ? '' : a:text.s:spc.g:airline_right_alt_sep.s:spc

FUNCTION  <SNR>108_get_buffer_list()
Called 20 times
Total time:   0.003134
 Self time:   0.003134

count  total (s)   self (s)
   20              0.000055   let buffers = []
   20              0.000068   let cur = bufnr('%')
  163              0.000255   for nr in range(1, bufnr('$'))
  143              0.000360     if buflisted(nr) && bufexists(nr)
   33              0.000066       for ex in s:excludes
                                    if match(bufname(nr), ex)
                                      continue
                                    endif
                                  endfor
   33              0.000147       if getbufvar(nr, 'current_syntax') == 'qf'
                                    continue
                                  endif
   33              0.000095       call add(buffers, nr)
   33              0.000027     endif
  143              0.000086   endfor
                            
   20              0.000078   let s:current_buffer_list = buffers
   20              0.000028   return buffers

FUNCTION  neobundle#util#get_filetypes()
Called 35 times
Total time:   0.000532
 Self time:   0.000532

count  total (s)   self (s)
   35              0.000245   let filetype = exists('b:neocomplcache.context_filetype') ? b:neocomplcache.context_filetype : &filetype
   35              0.000252   return split(filetype, '\.')

FUNCTION  neobundle#util#convert2list()
Called 227 times
Total time:   0.001051
 Self time:   0.001051

count  total (s)   self (s)
  227              0.000919   return type(a:expr) ==# type([]) ? a:expr : [a:expr]

FUNCTION  <SNR>86_Highlight_Matching_Pair()
Called 107 times
Total time:   0.027810
 Self time:   0.027810

count  total (s)   self (s)
                              " Remove any previous match.
  107              0.001146   if exists('w:paren_hl_on') && w:paren_hl_on
                                3match none
                                let w:paren_hl_on = 0
                              endif
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
  107              0.001384   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
                              endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
  107              0.000581   let c_lnum = line('.')
  107              0.000377   let c_col = col('.')
  107              0.000190   let before = 0
                            
  107              0.000756   let c = getline(c_lnum)[c_col - 1]
  107              0.002990   let plist = split(&matchpairs, '.\zs[:,]')
  107              0.000586   let i = index(plist, c)
  107              0.000204   if i < 0
                                " not found, in Insert mode try character before the cursor
  106              0.000402     if c_col > 1 && (mode() == 'i' || mode() == 'R')
                                  let before = 1
                                  let c = getline(c_lnum)[c_col - 2]
                                  let i = index(plist, c)
                                endif
  106              0.000145     if i < 0
                                  " not found, nothing to do
  106              0.000165       return
                                endif
                              endif
                            
                              " Figure out the arguments for searchpairpos().
    1              0.000001   if i % 2 == 0
    1              0.000002     let s_flags = 'nW'
    1              0.000004     let c2 = plist[i + 1]
    1              0.000000   else
                                let s_flags = 'nbW'
                                let c2 = c
                                let c = plist[i - 1]
                              endif
    1              0.000002   if c == '['
                                let c = '\['
                                let c2 = '\]'
                              endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
    1              0.000002   if before > 0
                                let save_cursor = winsaveview()
                                call cursor(c_lnum, c_col - before)
                              endif
                            
                              " When not in a string or comment ignore matches inside them.
                              " We match "escape" for special items, such as lispEscapeSpecial.
    1              0.000004   let s_skip ='synIDattr(synID(line("."), col("."), 0), "name") ' . '=~?  "string\\|character\\|singlequote\\|escape\\|comment"'
    1              0.000164   execute 'if' s_skip '| let s_skip = 0 | endif'
                            
                              " Limit the search to lines visible in the window.
    1              0.014798   let stoplinebottom = line('w$')
    1              0.000005   let stoplinetop = line('w0')
    1              0.000002   if i % 2 == 0
    1              0.000002     let stopline = stoplinebottom
    1              0.000001   else
                                let stopline = stoplinetop
                              endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
    1              0.000003   if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
                              else
    1              0.000004     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
    1              0.000000   endif
    1              0.000001   try
    1              0.000479     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
    1              0.000002   catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
    1              0.000001   if before > 0
                                call winrestview(save_cursor)
                              endif
                            
                              " If a match is found setup match highlighting.
    1              0.000002   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
                                exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                let w:paren_hl_on = 1
                              endif

FUNCTION  <SNR>38_init()
Called 45 times
Total time:   0.000949
 Self time:   0.000949

count  total (s)   self (s)
   45              0.000101   if !s:airline_initialized
                                let s:airline_initialized = 1
                            
                                call airline#init#bootstrap()
                                call airline#extensions#load()
                                call airline#init#sections()
                            
                                let s:airline_theme_defined = exists('g:airline_theme')
                                if s:airline_theme_defined || !airline#switch_matching_theme()
                                  let g:airline_theme = get(g:, 'airline_theme', 'dark')
                                  call airline#switch_theme(g:airline_theme)
                                endif
                              endif

FUNCTION  netrw#LocalBrowseCheck()
Called 14 times
Total time:   0.428669
 Self time:   0.001262

count  total (s)   self (s)
                              " unfortunate interaction -- split window debugging can't be
                              " used here, must use D-echoRemOn or D-echoTabOn -- the BufEnter
                              " event triggers another call to LocalBrowseCheck() when attempts
                              " to write to the DBG buffer are made.
                              " The &ft == "netrw" test was installed because the BufEnter event
                              " would hit when re-entering netrw windows, creating unexpected
                              " refreshes (and would do so in the middle of NetrwSaveOptions(), too)
                            "  call Decho("(LocalBrowseCheck) isdir<".a:dirname.">=".isdirectory(a:dirname).((exists("s:treeforceredraw")? " treeforceredraw" : "")))
                            "  call Dredir("LocalBrowseCheck","ls!")|redraw!|sleep 3
   14              0.000050   let ykeep= @@
   14              0.000134   if isdirectory(a:dirname)
                            "   call Decho("(LocalBrowseCheck) is-directory ft<".&ft."> b:netrw_curdir<".(exists("b:netrw_curdir")? b:netrw_curdir : " doesn't exist")."> dirname<".a:dirname.">"." line($)=".line("$")." ft<".&ft."> g:netrw_fastbrowse=".g:netrw_fastbrowse)
   12   0.001877   0.000079    let svposn= netrw#NetrwSavePosn()
   12              0.000120    if &ft != "netrw" || (exists("b:netrw_curdir") && b:netrw_curdir != a:dirname) || g:netrw_fastbrowse <= 1
   12   0.424516   0.000123     sil! keepj keepalt call s:NetrwBrowse(1,a:dirname)
   12   0.001294   0.000078     keepalt call netrw#NetrwRestorePosn(svposn)
   12              0.000031    elseif &ft == "netrw" && line("$") == 1
                                sil! keepj keepalt call s:NetrwBrowse(1,a:dirname)
                                keepalt call netrw#NetrwRestorePosn(svposn)
                               elseif exists("s:treeforceredraw")
                                unlet s:treeforceredraw
                                sil! keepj keepalt call s:NetrwBrowse(1,a:dirname)
                                keepalt call netrw#NetrwRestorePosn(svposn)
                               endif
   12              0.000007   endif
                              " following code wipes out currently unused netrw buffers
                              "       IF g:netrw_fastbrowse is zero (ie. slow browsing selected)
                              "   AND IF the listing style is not a tree listing
   14              0.000059   if exists("g:netrw_fastbrowse") && g:netrw_fastbrowse == 0 && g:netrw_liststyle != s:TREELIST
                               let ibuf    = 1
                               let buflast = bufnr("$")
                               while ibuf <= buflast
                                if bufwinnr(ibuf) == -1 && isdirectory(bufname(ibuf))
                                 exe "sil! keepalt ".ibuf."bw!"
                                endif
                                let ibuf= ibuf + 1
                               endwhile
                              endif
   14              0.000035   let @@= ykeep
                              " not a directory, ignore it

FUNCTION  <SNR>138_Init()
Called 20 times
Total time:   0.000098
 Self time:   0.000098

count  total (s)   self (s)
   20              0.000052     if s:checked_ctags == 2 && a:silent
   20              0.000021         return 0
                                elseif s:checked_ctags != 1
                                    if !s:CheckForExCtags(a:silent)
                                        return 0
                                    endif
                                endif
                            
                                if !s:checked_ctags_types
                                    call s:GetSupportedFiletypes()
                                endif
                            
                                if !s:type_init_done
                                    call s:InitTypes()
                                endif
                            
                                if !s:autocommands_done
                                    call s:CreateAutocommands()
                                    call s:AutoUpdate(fnamemodify(expand('%'), ':p'), 0)
                                endif
                            
                                return 1

FUNCTION  airline#builder#new()
Called 65 times
Total time:   0.002200
 Self time:   0.002200

count  total (s)   self (s)
   65              0.000477   let builder = copy(s:prototype)
   65              0.000210   let builder._context = a:context
   65              0.000136   let builder._side = 1
   65              0.000130   let builder._curgroup = ''
   65              0.000114   let builder._line = ''
                            
   65              0.000822   call extend(builder._context, { 'left_sep': g:airline_left_sep, 'left_alt_sep': g:airline_left_alt_sep, 'right_sep': g:airline_right_sep, 'right_alt_sep': g:airline_right_alt_sep, }, 'keep')
   65              0.000108   return builder

FUNCTION  <SNR>20_DetectCoffee()
Called 2 times
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
    2              0.000010     if getline(1) =~ '^#!.*\<coffee\>'
                                    set filetype=coffee
                                endif

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
   12  18.836833   8.063079  <SNR>139_NetrwBrowseChgDir()
    2   2.275659   0.322073  sy#start()
    2   1.873726   0.006278  sy#repo#process_diff()
   28   1.867448             sy#sign#set()
   14   0.428669   0.001262  netrw#LocalBrowseCheck()
   12   0.424393   0.004966  <SNR>139_NetrwBrowse()
   12   0.287134   0.006334  <SNR>139_PerformListing()
   24   0.192069   0.007332  <SNR>139_NetrwSafeOptions()
   35   0.158536   0.004144  neobundle#autoload#filetype()
   37   0.148020   0.000367  neobundle#config#source_bundles()
    1   0.147653   0.006397  neobundle#config#source()
   35   0.140671   0.077343  <SNR>30_LoadFTPlugin()
   45   0.118597   0.000676  <SNR>38_on_window_changed()
   45   0.116972   0.003972  airline#update_statusline()
   45   0.113000   0.001964  <SNR>39_invoke_funcrefs()
   45   0.109242   0.002956  airline#util#exec_funcrefs()
  256   0.096660   0.024903  119()
   45   0.091267   0.002206  airline#extensions#default#apply()
   35   0.089321   0.043897  <SNR>33_SynSet()
   57   0.086597   0.003090  <SNR>115_build_sections()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
   12  18.836833   8.063079  <SNR>139_NetrwBrowseChgDir()
   28              1.867448  sy#sign#set()
    2   2.275659   0.322073  sy#start()
   35   0.140671   0.077343  <SNR>30_LoadFTPlugin()
   12              0.048569  <SNR>139_NetrwSetSort()
   12   0.047227   0.044497  <SNR>139_LocalListing()
   35   0.089321   0.043897  <SNR>33_SynSet()
   12   0.030436   0.030329  <SNR>139_NetrwMaps()
  107              0.027810  <SNR>86_Highlight_Matching_Pair()
  728              0.026415  <SNR>110_get_syn()
   45   0.030911   0.025785  <SNR>139_NetrwOptionRestore()
  256   0.096660   0.024903  119()
   35   0.015341   0.014552  <SNR>31_LoadIndent()
   14   0.017068   0.013739  <SNR>139_NetrwMenu()
  182              0.013084  airline#highlighter#exec()
  364   0.044181   0.012705  airline#highlighter#get_highlight()
  139              0.012514  airline#check_mode()
   14              0.010412  <SNR>139_NetrwTgtMenu()
   31              0.009069  <SNR>139_NetrwOptionSave()
   12   0.080533   0.008522  <SNR>139_NetrwGetBuffer()

